{
  "9787111255833": {
    "rating": { "max": 10, "numRaters": 1487, "average": "9.1", "min": 0 },
    "subtitle": "",
    "author": ["Joshua Bloch"],
    "pubdate": "2009-1-1",
    "tags": [
      { "count": 1176, "name": "java", "title": "java" },
      { "count": 838, "name": "Java", "title": "Java" },
      { "count": 627, "name": "编程", "title": "编程" },
      { "count": 399, "name": "effective", "title": "effective" },
      { "count": 350, "name": "计算机", "title": "计算机" },
      { "count": 323, "name": "程序设计", "title": "程序设计" },
      { "count": 271, "name": "经典", "title": "经典" },
      { "count": 225, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "Effective Java Second Edition",
    "image": "https://img3.doubanio.com/view/subject/m/public/s3479802.jpg",
    "binding": "平装",
    "translator": ["俞黎敏"],
    "catalog": "译者序\n序\n前言\n致谢\n第1章 引言\n第2章 创建和销毁对象\n第1条：考虑用静态工厂方法代替构造器\n第2条：遇到多个构造器参数时要考虑用构建器\n第3条：用私有构造器或者枚举类型强化Singleton属性\n第4条：通过私有构造器强化不可实例化的能力\n第5条：避免创建不必要的对象\n第6条：消除过期的对象引用\n第7条：避免使用终结方法\n第3章 对于所有对象都通用的方法\n第8条：覆盖equals时请遵守通用约定\n第9条：覆盖equals时总要覆盖hashCode\n第10条：始终要覆盖toString\n第11条：谨慎地覆盖clone\n第12条：考虑实现Comparable接口\n第4章 类和接口\n第13条：使类和成员的可访问性最小化\n第14条：在公有类中使用访问方法而非公有域\n第15条：使可变性最小化\n第16条：复合优先于继承\n第17条：要么为继承而设计，并提供文档说明，要么就禁止继承\n第18条：接口优于抽象类\n第19条：接口只用于定义类型\n第20条：类层次优于标签类\n第21条：用函数对象表示策略\n第22条：优先考虑静态成员类\n第5章 泛型\n第23条：请不要在新代码中使用原生态类型\n第24条：消除非受检警告\n第25条：列表优先于数组\n第26条：优先考虑泛型\n第27条：优先考虑泛型方法\n第28条：利用有限制通配符来提升API的灵活性\n第29条：优先考虑类型安全的异构容器\n第6章 枚举和注解\n第30条：用enum代替int常量\n第31条：用实例域代替序数\n第32条：用EnumSet代替位域\n第33条：用EnumMap代替序数索引\n第34条：用接口模拟可伸缩的枚举\n第35条：注解优先于命名模式\n第36条：坚持使用Override注解\n第37条：用标记接口定义类型\n第7章 方法\n第38条：检查参数的有效性\n第39条：必要时进行保护性拷贝\n第40条：谨慎设计方法签名\n第41条：慎用重载\n第42条：慎用可变参数\n第43条：返回零长度的数组或者集合，而不是：null\n第44条：为所有导出的API元素编写文档注释\n第8章 通用程序设计\n第45条：将局部变量的作用域最小化\n第46条：for-each循环优先于传统的for循环\n第47条：了解和使用类库\n第48条：如果需要精确的答案，请避免使用float和double\n第49条：基本类型优先于装箱基本类型\n第50条：如果其他类型更适合，则尽量避免使用字符串\n第51条：当心字符串连接的性能\n第52条：通过接口引用对象\n第53条：接口优先于反射机制\n第54条：谨慎地使用本地方法\n第55条：谨慎地进行优化\n第56条：遵守普遍接受的命名惯例\n第9章 异常\n第57条：只针对异常的情况才使用异常\n第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n第59条：避免不必要地使用受检的异常\n第60条：优先使用标准的异常\n第61条：抛出与抽象相对应的异常\n第62条：每个方法抛出的异常都要有文档\n第63条：在细节消息中包含能捕获失败的信息\n第64条：努力使失败保持原子性\n第65条：不要忽略异常\n第10章 并发\n第66条：同步访问共享的可变数据\n第67条：避免过度同步\n第68条：executor和task优先干线程\n第69条：并发工具优先于wait和notify\n第70条：线程安全性的文档化\n第71条：慎用延迟初始化\n第72条：不要依赖于线程调度器\n第73条：避免使用线程组\n第11章 序列化\n第74条：谨慎地实现Serializable接口\n第75条：考虑使用自定义的序列化形式\n第76条：保护性地编写readObject方法\n第77条：对于实例控制，枚举类型优先于readResolve\n第78条：考虑用序列化代理代替序列化实例\n附录 第1版与第2版条目对照\n中英文术语对照\n参考文献",
    "pages": "287",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s3479802.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s3479802.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s3479802.jpg"
    },
    "alt": "https://book.douban.com/subject/3360807/",
    "id": "3360807",
    "publisher": "机械工业出版社",
    "isbn10": "7111255836",
    "isbn13": "9787111255833",
    "title": "Effective java 中文版（第2版）",
    "url": "https://api.douban.com/v2/book/3360807",
    "alt_title": "Effective Java Second Edition",
    "author_intro": "Joshua Bloch是Google公司的首席Java架构师。是Jolt大奖的获得者。他曾是Sun公司的杰出工程师，和Transarc公司的高级系统设计师。Bloch曾带领团队设计和实现过无数的Java平台特性，包括JDK 5.0语言增强版和获奖的Java Collections Framework。他的著作还包括：《Java Puzzlers》、《Java Concurrency in Practive》等。",
    "summary": "本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。\n本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。",
    "series": { "id": "28333", "title": "Sun公司核心技术丛书" },
    "price": "52.00元"
  },
  "9787508353937": {
    "rating": { "max": 10, "numRaters": 2735, "average": "9.2", "min": 0 },
    "subtitle": "",
    "author": ["弗里曼"],
    "pubdate": "2007-9",
    "tags": [
      { "count": 2832, "name": "设计模式", "title": "设计模式" },
      { "count": 836, "name": "计算机", "title": "计算机" },
      { "count": 662, "name": "编程", "title": "编程" },
      { "count": 579, "name": "软件工程", "title": "软件工程" },
      { "count": 506, "name": "Headfirst", "title": "Headfirst" },
      { "count": 496, "name": "软件设计", "title": "软件设计" },
      { "count": 419, "name": "java", "title": "java" },
      { "count": 342, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s2686916.jpg",
    "binding": "平装",
    "translator": ["O'Reilly Taiwan公司"],
    "catalog": "引子\n谁适合读这本书?\n我们知道你的大脑在想什么\n元认知\n让你的大脑就范\n技术审校\n致谢\n1　欢迎来到设计模式世界：设计模式入门\n模拟鸭子应用\nJoe想到继承\n利用接口如何？\n软件开发的不变真理\n分开变化和不变部分\n设计鸭子的行为\n测试鸭子的代码\n动态地设置行为\n封装行为的大局观\n“有一个”比“是一个”更好\n策略模式\n共享模式词汇的威力\n我如何使用设计模式？\n设计箱内的工具\n习题解答\n2　让你的对象知悉现况\n气象观测站\n认识观察者模式\n出版者＋订阅者＝观罕者模式\n五分钟短剧：观察主题\n定义观察者模式\n松耦合的威力\n设计气象站\n实现气象站\n使用Java内建的观察者模式\njava.util.Observable的黑暗面\n设计箱内的工具\n习题解答\n……\n3　装饰者模式：装饰对象\n4　工厂模式：烘烤OO的精华\n5　单件模式：独一无二的对象\n6　命令模式：封装调用\n7　适配器模式与外观模式：随遇而安\n8　模板方法模式：封装算法\n9　送代器与组合模式：管理良好的集合\n10　状态模式：事物的状态\n11　代理模式：控制对象访问\n12　复合模式：模式中的模式\n13　与设计模式相处：真实世界中的模式\nA　附录A：剩下的模式",
    "pages": "637",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s2686916.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s2686916.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s2686916.jpg"
    },
    "alt": "https://book.douban.com/subject/2243615/",
    "id": "2243615",
    "publisher": "中国电力出版社",
    "isbn10": "7508353935",
    "isbn13": "9787508353937",
    "title": "Head First 设计模式（中文版）",
    "url": "https://api.douban.com/v2/book/2243615",
    "alt_title": "",
    "author_intro": "",
    "summary": "《Head First设计模式》(中文版)共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本全部23个设计模式。前言先介绍这本书的用法；第1章到第11章陆续介绍的设计模式为Strategy、Observer、Decorator、Abstract Factory、Factory Method、Singleton，Command、Adapter、Facade、TemplateMethod、Iterator、Composite、State、Proxy。最后三章比较特别。第12章介绍如何将两个以上的设计模式结合起来成为新的设计模式(例如著名的MVC模式)，作者称其为复合设计模式(这是作者自创的名称，并非四人组的标准名词)，第13章介绍如何进一步学习设计模式，如何发觉新的设计模式等主题，至于第14章则很快地浏览尚未介绍的设计模式，包括Bridge、Builder、Chain of Responsibility、Flyweight、Interpreter、Mediator、Memento、Prototype，Visitor。第1章还介绍了四个○○基本概念(抽象、封装、继承、多态)，而第1章到第9章也陆续介绍了九个○○原则(Principle)。千万不要轻视这些○○原则，因为每个设计模式背后都包含了几个○○原则的概念。很多时候，在设计时有两难的情况，这时候我们必须回归到○○原则，以方便判断取舍。可以这么说：○○原则是我们的目标，而设计模式是我们的做法。",
    "series": { "id": "10044", "title": "O'Reilly深入浅出系列" },
    "price": "98.00元"
  },
  "9787115384881": {
    "rating": { "max": 10, "numRaters": 179, "average": "7.8", "min": 0 },
    "subtitle": "",
    "author": ["[英] Richard Warburton"],
    "pubdate": "2015-3",
    "tags": [
      { "count": 117, "name": "Java", "title": "Java" },
      { "count": 93, "name": "函数式编程", "title": "函数式编程" },
      { "count": 39, "name": "Java8", "title": "Java8" },
      { "count": 34, "name": "编程", "title": "编程" },
      { "count": 27, "name": "计算机", "title": "计算机" },
      { "count": 25, "name": "java", "title": "java" },
      { "count": 24, "name": "函数", "title": "函数" },
      { "count": 21, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28028344.jpg",
    "binding": "平装",
    "translator": ["王群锋"],
    "catalog": "前言　　IX\n第1章　简介　　1\n1.1　为什么需要再次修改Java　　1\n1.2　什么是函数式编程　　2\n1.3　示例　　2\n第2章　Lambda 表达式　　5\n2.1　第一个Lambda 表达式　　5\n2.2　如何辨别Lambda 表达式　　6\n2.3　引用值，而不是变量　　8\n2.4　函数接口　　9\n2.5　类型推断　　10\n2.6　要点回顾　　12\n2.7　练习　　12\n第3章　流　　15\n3.1　从外部迭代到内部迭代　　15\n3.2　实现机制　　17\n3.3　常用的流操作　　19\n3.3.1　collect(toList())　　19\n3.3.2　map　　19\n3.3.3　filter　　21\n3.3.4　flatMap　　22\n3.3.5　max 和min　　23\n3.3.6　通用模式　　24\n3.3.7　reduce　　24\n3.3.8　整合操作　　26\n3.4　重构遗留代码　　27\n3.5　多次调用流操作　　30\n3.6　高阶函数　　31\n3.7　正确使用Lambda 表达式　　31\n3.8　要点回顾　　32\n3.9　练习　　32\n3.10　进阶练习　　33\n第4章　类库　　35\n4.1　在代码中使用Lambda 表达式　　35\n4.2　基本类型　　36\n4.3　重载解析　　38\n4.4　@FunctionalInterface　　40\n4.5　二进制接口的兼容性　　40\n4.6　默认方法　　41\n4.7　多重继承　　45\n4.8　权衡　　46\n4.9　接口的静态方法　　46\n4.10　Optional　　47\n4.11　要点回顾　　48\n4.12　练习　　48\n4.13　开放练习　　49\n第5章　高级集合类和收集器　　51\n5.1　方法引用　　51\n5.2　元素顺序　　52\n5.3　使用收集器　　54\n5.3.1　转换成其他集合　　54\n5.3.2　转换成值　　55\n5.3.3　数据分块　　55\n5.3.4　数据分组　　56\n5.3.5　字符串　　57\n5.3.6　组合收集器　　58\n5.3.7　重构和定制收集器　　60\n5.3.8　对收集器的归一化处理　　65\n5.4　一些细节　　66\n5.5　要点回顾　　67\n5.6　练习　　67\n第6章　数据并行化　　69\n6.1　并行和并发　　69\n6.2　为什么并行化如此重要　　70\n6.3　并行化流操作　　71\n6.4　模拟系统　　72\n6.5　限制　　75\n6.6　性能　　75\n6.7　并行化数组操作　　78\n6.8　要点回顾　　80\n6.9　练习　　80\n第7章　测试、调试和重构　　81\n7.1　重构候选项　　81\n7.1.1　进进出出、摇摇晃晃　　82\n7.1.2　孤独的覆盖　　82\n7.1.3　同样的东西写两遍　　83\n7.2　Lambda 表达式的单元测试　　85\n7.3　在测试替身时使用Lambda 表达式　　87\n7.4　惰性求值和调试　　89\n7.5　日志和打印消息　　89\n7.6　解决方案：peak　　90\n7.7　在流中间设置断点　　90\n7.8　要点回顾　　90\n第8章　设计和架构的原则　　91\n8.1　Lambda 表达式改变了设计模式　　92\n8.1.1　命令者模式　　92\n8.1.2　策略模式　　95\n8.1.3　观察者模式　　97\n8.1.4　模板方法模式　　100\n8.2　使用Lambda 表达式的领域专用语言　　102\n8.2.1　使用Java 编写DSL　　103\n8.2.2　实现　　104\n8.2.3　评估　　106\n8.3　使用Lambda 表达式的SOLID 原则　　106\n8.3.1　单一功能原则　　107\n8.3.2　开闭原则　　109\n8.3.3　依赖反转原则　　 111\n8.4　进阶阅读　　114\n8.5　要点回顾　　114\n第9章　使用Lambda 表达式编写并发程序　　115\n9.1　为什么要使用非阻塞式I/O　　115\n9.2　回调　　116\n9.3　消息传递架构　　119\n9.4　末日金字塔　　120\n9.5　Future　　122\n9.6　CompletableFuture　　123\n9.7　响应式编程　　126\n9.8　何时何地使用新技术　　128\n9.9　要点回顾　　129\n9.10　练习　　129\n第10章　下一步该怎么办　　131\n封面介绍　　133",
    "ebook_url": "https://read.douban.com/ebook/12187857/",
    "pages": "148",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28028344.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28028344.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28028344.jpg"
    },
    "alt": "https://book.douban.com/subject/26346017/",
    "id": "26346017",
    "publisher": "人民邮电出版社",
    "isbn10": "7115384886",
    "isbn13": "9787115384881",
    "title": "Java 8函数式编程",
    "url": "https://api.douban.com/v2/book/26346017",
    "alt_title": "",
    "author_intro": "作者简介：\nRichard Warburton\n一位经验丰富的技术专家，善于解决复杂深奥的技术问题，拥有华威大学计算机科学专业博士学位。近期他一直从事高性能计算方面的数据分析工作。他是英国伦敦Java社区的领导者，组织过面向Java 8中Lambda表达式、日期和时间的Adopt-a-JSR项目，以及Openjdk Hackdays活动。Richard还是知名的会议演讲嘉宾，曾在JavaOne、DevoxxUK和JAX London等会议上演讲。\n译者简介：\n王群锋\n毕业于西安电子科技大学，现任职于IBM西安研发中心，从事下一代统计预测软件的开发运维工作。",
    "summary": "通过每一章的练习快速掌握Java 8中的Lambda表达式\n分析流、高级集合和其他Java 8类库的改进\n利用多核CPU提高数据并发的性能\n将现有代码库和库代码Lambda化\n学习Lambda表达式单元测试和调试的实践解决方案\n用Lambda表达式实现面向对象编程的SOLID原则\n编写能有效执行消息传送和非阻塞I/O的并发应用",
    "ebook_price": "19.99",
    "series": { "id": "46192", "title": "图灵程序设计丛书·Java系列" },
    "price": "39.00元"
  },
  "9787115419347": {
    "rating": { "max": 10, "numRaters": 272, "average": "9.2", "min": 0 },
    "subtitle": "",
    "author": [
      "厄马(Raoul-Gabriel Urma)",
      "弗斯科(Mario Fusco)",
      "米克罗夫特(Alan Mycroft)"
    ],
    "pubdate": "2016-4-1",
    "tags": [
      { "count": 249, "name": "Java", "title": "Java" },
      { "count": 154, "name": "java8", "title": "java8" },
      { "count": 85, "name": "编程", "title": "编程" },
      { "count": 80, "name": "函数式编程", "title": "函数式编程" },
      { "count": 65, "name": "java", "title": "java" },
      { "count": 62, "name": "计算机", "title": "计算机" },
      { "count": 41, "name": "软件开发", "title": "软件开发" },
      { "count": 24, "name": "开发", "title": "开发" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29343267.jpg",
    "binding": "平装",
    "translator": ["陆明刚", "劳佳"],
    "catalog": "第一部分 基础知识\n第1章　为什么要关心Java 8　　2\n1.1　Java怎么还在变　　4\n1.1.1　Java在编程语言生态系统中的位置　　4\n1.1.2　流处理　　6\n1.1.3　用行为参数化把代码传递给方法　　7\n1.1.4　并行与共享的可变数据　　7\n1.1.5　Java需要演变　　8\n1.2　Java中的函数　　8\n1.2.1　方法和Lambda作为一等公民　　9\n1.2.2　传递代码：一个例子　　11\n1.2.3　从传递方法到Lambda　　12\n1.3　流　　13\n1.4　默认方法　　17\n1.5　来自函数式编程的其他好思想　　18\n1.6　小结　　19\n第2章　通过行为参数化传递代码　　20\n2.1　应对不断变化的需求　　21\n2.1.1　初试牛刀：筛选绿苹果　　21\n2.1.2　再展身手：把颜色作为参数　　21\n2.1.3　第三次尝试：对你能想到的每个属性做筛选　　22\n2.2　行为参数化　　23\n2.3　对付啰嗦　　27\n2.3.1　匿名类　　28\n2.3.2　第五次尝试：使用匿名类　　28\n2.3.3　第六次尝试：使用Lambda表达式　　30\n2.3.4　第七次尝试：将List类型抽象化　　31\n2.4　真实的例子　　31\n2.4.1　用Comparator来排序　　31\n2.4.2　用Runnable执行代码块　　32\n2.4.3　GUI事件处理　　32\n2.5　小结　　33\n第3章　Lambda表达式　　34\n3.1　Lambda管中窥豹　　35\n3.2　在哪里以及如何使用Lambda　　37\n3.2.1　函数式接口　　37\n3.2.2　函数描述符　　39\n3.3　把Lambda付诸实践：环绕执行模式　　41\n3.3.1　第1步记得行为参数化　　41\n3.3.2　第2步：使用函数式接口来传递行为　　42\n3.3.3　第3步：执行一个行为　　42\n3.3.4　第4步：传递Lambda　　42\n3.4　使用函数式接口　　43\n3.4.1　Predicate　　44\n3.4.2　Consumer　　44\n3.4.3　Function　　45\n3.5　类型检查、类型推断以及限制　　49\n3.5.1　类型检查　　49\n3.5.2　同样的Lambda，不同的函数式接口　　50\n3.5.3　类型推断　　51\n3.5.4　使用局部变量　　52\n3.6　方法引用　　53\n3.6.1　管中窥豹　　53\n3.6.2　构造函数引用　　55\n3.7　Lambda和方法引用实战　　57\n3.7.1　第1步：传递代码　　58\n3.7.2　第2步：使用匿名类　　58\n3.7.3　第3步：使用Lambda表达式　　58\n3.7.4　第4步：使用方法引用　　59\n3.8　复合Lambda表达式的有用方法　　59\n3.8.1　比较器复合　　60\n3.8.2　谓词复合　　60\n3.8.3　函数复合　　61\n3.9　数学中的类似思想　　62\n3.9.1　积分　　62\n3.9.2　与Java 8的Lambda联系起来　　63\n3.10　小结　　64\n第二部分 函数式数据处理\n第4章　引入流　　68\n4.1　流是什么　　68\n4.2　流简介　　72\n4.3　流与集合　　74\n4.3.1　只能遍历一次　　75\n4.3.2　外部迭代与内部迭代　　76\n4.4　流操作　　78\n4.4.1　中间操作　　78\n4.4.2　终端操作　　79\n4.4.3　使用流　　80\n4.5　小结　　81\n第5章　使用流　　82\n5.1　筛选和切片　　83\n5.1.1　用谓词筛选　　83\n5.1.2　筛选各异的元素　　83\n5.1.3　截短流　　84\n5.1.4　跳过元素　　85\n5.2　映射　　86\n5.2.1　对流中每一个元素应用函数　　86\n5.2.2　流的扁平化　　87\n5.3　查找和匹配　　90\n5.3.1　检查谓词是否至少匹配一个元素　　90\n5.3.2　检查谓词是否匹配所有元素　　90\n5.3.3　查找元素　　91\n5.3.4　查找第一个元素　　92\n5.4　归约　　92\n5.4.1　元素求和　　93\n5.4.2　最大值和最小值　　94\n5.5　付诸实践　　97\n5.5.1　领域：交易员和交易　　98\n5.5.2　解答　　99\n5.6　数值流　　101\n5.6.1　原始类型流特化　　101\n5.6.2　数值范围　　102\n5.6.3　数值流应用：勾股数　　103\n5.7　构建流　　105\n5.7.1　由值创建流　　106\n5.7.2　由数组创建流　　106\n5.7.3　由文件生成流　　106\n5.7.4　由函数生成流：创建无限流　　107\n5.8　小结　　110\n第6章　用流收集数据　　111\n6.1　收集器简介　　112\n6.1.1　收集器用作高级归约　　112\n6.1.2　预定义收集器　　113\n6.2　归约和汇总　　114\n6.2.1　查找流中的最大值和最小值　　114\n6.2.2　汇总　　115\n6.2.3　连接字符串　　116\n6.2.4　广义的归约汇总　　117\n6.3　分组　　120\n6.3.1　多级分组　　121\n6.3.2　按子组收集数据　　122\n6.4　分区　　126\n6.4.1　分区的优势　　126\n6.4.2　将数字按质数和非质数分区　　128\n6.5　收集器接口　　129\n6.5.1　理解Collector接口声明的方法　　130\n6.5.2　全部融合到一起　　134\n6.6　开发你自己的收集器以获得更好的性能　　135\n6.6.1　仅用质数做除数　　136\n6.6.2　比较收集器的性能　　139\n6.7　小结　　140\n第7章　并行数据处理与性能　　141\n7.1　并行流　　141\n7.1.1　将顺序流转换为并行流　　142\n7.1.2　测量流性能　　144\n7.1.3　正确使用并行流　　147\n7.1.4　高效使用并行流　　148\n7.2　分支/合并框架　　149\n7.2.1　使用RecursiveTask　　149\n7.2.2　使用分支/合并框架的最佳做法　　153\n7.2.3　工作窃取　　154\n7.3　Spliterator　　155\n7.3.1　拆分过程　　155\n7.3.2　实现你自己的Spliterator　　157\n7.4　小结　　162\n第三部分 高效Java 8编程\n第8章　重构、测试和调试　　164\n8.1　为改善可读性和灵活性重构代码　　164\n8.1.1　改善代码的可读性　　165\n8.1.2　从匿名类到Lambda表达式的转换　　165\n8.1.3　从Lambda表达式到方法引用的转换　　166\n8.1.4　从命令式的数据处理切换到Stream　　167\n8.1.5　增加代码的灵活性　　168\n8.2　使用Lambda重构面向对象的设计模式　　170\n8.2.1　策略模式　　171\n8.2.2　模板方法　　172\n8.2.3　观察者模式　　173\n8.2.4　责任链模式　　175\n8.2.5　工厂模式　　177\n8.3　测试Lambda表达式　　178\n8.3.1　测试可见Lambda函数的行为　　179\n8.3.2　测试使用Lambda的方法的行为　　179\n8.3.3　将复杂的Lambda表达式分到不同的方法　　180\n8.3.4　高阶函数的测试　　180\n8.4　调试　　181\n8.4.1　查看栈跟踪　　181\n8.4.2　使用日志调试　　183\n8.5　小结　　184\n第9章　默认方法　　 185\n9.1　不断演进的API　　 187\n9.1.1　初始版本的API　　188\n9.1.2　第二版API　　188\n9.2　概述默认方法　　190\n9.3　默认方法的使用模式　　192\n9.3.1　可选方法　　192\n9.3.2　行为的多继承　　192\n9.4　解决冲突的规则　　196\n9.4.1　解决问题的三条规则　　196\n9.4.2　选择提供了最具体实现的默认方法的接口　　197\n9.4.3　冲突及如何显式地消除歧义　　198\n9.4.4　菱形继承问题　　200\n9.5　小结　　201\n第10章　用Optional取代null　　202\n10.1　如何为缺失的值建模　　 203\n10.1.1　采用防御式检查减少Null-PointerException　　203\n10.1.2　null带来的种种问题　　204\n10.1.3　其他语言中null的替代品　　205\n10.2　Optional类入门　　206\n10.3　应用Optional的几种模式　　 207\n10.3.1　创建Optional对象　　208\n10.3.2　使用map从Optional对象中提取和转换值　　208\n10.3.3　使用flatMap链接Optional对象　　209\n10.3.4　默认行为及解引用Optional对象　　213\n10.3.5　两个Optional对象的组合　　213\n10.3.6　使用filter剔除特定的值　　214\n10.4　使用Optional的实战示例　　 216\n10.4.1　用Optional封装可能为null的值　　216\n10.4.2　异常与Optional的对比　　217\n10.4.3　把所有内容整合起来　　218\n10.5　小结　　219\n第11章　CompletableFuture：组合式异步编程　　220\n11.1　Future接口　　222\n11.1.1　Future接口的局限性　　223\n11.1.2　使用CompletableFuture构建异步应用　　223\n11.2　实现异步API　　 224\n11.2.1　将同步方法转换为异步方法　　225\n11.2.2　错误处理　　227\n11.3　让你的代码免受阻塞之苦　　228\n11.3.1　使用并行流对请求进行并行操作　　229\n11.3.2　使用CompletableFuture发起异步请求　　230\n11.3.3　寻找更好的方案　　232\n11.3.4　使用定制的执行器　　233\n11.4　对多个异步任务进行流水线操作　　234\n11.4.1　实现折扣服务　　235\n11.4.2　使用Discount服务　　236\n11.4.3　构造同步和异步操作　　237\n11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　239\n11.4.5　对Future和Completable-Future的回顾　　241\n11.5　响应CompletableFuture的completion事件　　242\n11.5.1　对最佳价格查询器应用的优化　　243\n11.5.2　付诸实践　　244\n11.6　小结　　245\n第12章　新的日期和时间API　　246\n12.1　LocalDate、LocalTime、Instant、Duration以及Period　　247\n12.1.1　使用LocalDate和LocalTime　　247\n12.1.2　合并日期和时间　　248\n12.1.3　机器的日期和时间格式　　249\n12.1.4　定义Duration或Period　　249\n12.2　操纵、解析和格式化日期　　251\n12.2.1　使用TemporalAdjuster　　253\n12.2.2　打印输出及解析日期－时间对象　　255\n12.3　处理不同的时区和历法　　256\n12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　257\n12.3.2　使用别的日历系统　　258\n12.4　小结　　259\n第四部分 超越Java 8\n第13章　函数式的思考　　262\n13.1　实现和维护系统　　262\n13.1.1　共享的可变数据　　263\n13.1.2　声明式编程　　264\n13.1.3　为什么要采用函数式编程　　265\n13.2　什么是函数式编程　　265\n13.2.1　函数式Java编程　　266\n13.2.2　引用透明性　　268\n13.2.3　面向对象的编程和函数式编程的对比　　 268\n13.2.4　函数式编程实战　　269\n13.3　递归和迭代　　271\n13.4　小结　　274\n第14章　函数式编程的技巧　　275\n14.1　无处不在的函数　　275\n14.1.1　高阶函数　　275\n14.1.2　科里化　　277\n14.2　持久化数据结构　　278\n14.2.1　破坏式更新和函数式更新的比较　　279\n14.2.2　另一个使用Tree的例子　　281\n14.2.3　采用函数式的方法　　282\n14.3　Stream的延迟计算　　283\n14.3.1　自定义的Stream　　 283\n14.3.2　创建你自己的延迟列表　　286\n14.4　模式匹配　　290\n14.4.1　访问者设计模式　　291\n14.4.2　用模式匹配力挽狂澜　　292\n14.5　杂项　　295\n14.5.1　缓存或记忆表　　295\n14.5.2　“返回同样的对象”意味着什么　　296\n14.5.3　结合器　　296\n14.6　小结　　297\n第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 299\n15.1　Scala简介　　300\n15.1.1　你好，啤酒　　300\n15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　302\n15.2　函数　　306\n15.2.1　Scala中的一等函数　　307\n15.2.2　匿名函数和闭包　　307\n15.2.3　科里化　　309\n15.3　类和trait　　310\n15.3.1　更加简洁的Scala类　　310\n15.3.2　Scala的trait与Java 8的接口对比　　311\n15.4　小结　　312\n第16章　结论以及Java的未来　　313\n16.1　回顾Java 8的语言特性　　 313\n16.1.1　行为参数化（Lambda 以及方法引用）　　314\n16.1.2　流　　314\n16.1.3　CompletableFuture　　315\n16.1.4　Optional　　315\n16.1.5　默认方法　　316\n16.2　Java 的未来　　316\n16.2.1　集合　　316\n16.2.2　类型系统的改进　　317\n16.2.3　模式匹配　　318\n16.2.4　更加丰富的泛型形式　　319\n16.2.5　对不变性的更深层支持　　321\n16.2.6　值类型　　322\n16.3　写在最后的话　　325\n附录A　其他语言特性的更新　　326\n附录B　类库的更新　　330\n附录C　如何以并发方式在同一个流上执行多种操作　　338\n附录D　Lambda表达式和JVM 字节码　　346",
    "pages": "349",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29343267.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29343267.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29343267.jpg"
    },
    "alt": "https://book.douban.com/subject/26772632/",
    "id": "26772632",
    "publisher": "人民邮电出版社",
    "isbn10": "7115419345",
    "isbn13": "9787115419347",
    "title": "Java 8实战",
    "url": "https://api.douban.com/v2/book/26772632",
    "alt_title": "",
    "author_intro": "作者简介：\nRaoul-Gabriel Urma\n剑桥大学计算机科学博士，软件工程师，演讲者，培训师，Cambridge Coding Academy联合创始人、CEO。曾与谷歌、eBay、甲骨文和高盛集团等大公司合作，并参与过多个创业项目。撰写过十余篇经同行审阅的技术文章，并在国际会议上发表过40多篇演讲。\nMario Fusco\nRed Hat高级软件工程师，负责JBoss规则引擎Drools的核心开发。拥有丰富的Java开发经验，曾领导媒体公司、金融部门等多个行业的企业级项目开发。对函数式编程和领域特定语言等有浓厚兴趣，并创建了开放源码库lambdaj。\nAlan Mycroft\n剑桥大学计算机实验室计算学教授，剑桥大学罗宾逊学院研究员，欧洲编程语言和系统协会联合创始人，树莓派基金会联合创始人和理事。发表过大约100篇研究论文，指导过20多篇博士论文。他的研究主要关注编程语言及其语义、优化和实施。他与业界联系紧密，曾于学术休假期间在AT&T实验室和英特尔工作，还创立了Codemist公司，该公司设计了最初的ARM C编译器Norcroft。\n译者简介：\n陆明刚\n毕业于四川大学，目前在EMC中国卓越研发集团任首席工程师，曾任趋势科技中国软件研发中心技术经理，在信息科学和工程领域有十余年的实践和研究经验，拥有多项中国及美国专利。关注JVM性能调优和大数据及其实践，喜欢挖掘技术背后的内幕并乐此不疲。\n劳佳\n硕士毕业于上海交通大学，现在SAP美国任高级软件支持顾问。业余爱好语言、数学、设计，近年翻译出版了《咨询的奥秘》《卓越程序员密码》等书。",
    "summary": "本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。全书分四个部分：基础知识、函数式数据处理、高效Java 8 编程和超越Java 8，清晰明了地向读者展现了一幅Java 与时俱进的现代化画卷。",
    "series": { "id": "46192", "title": "图灵程序设计丛书·Java系列" },
    "price": "CNY 79.00"
  },
  "9787115413765": {
    "rating": { "max": 10, "numRaters": 89, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["奥克斯 (Scott Oaks)"],
    "pubdate": "2016-3-1",
    "tags": [
      { "count": 162, "name": "Java", "title": "Java" },
      { "count": 104, "name": "性能优化", "title": "性能优化" },
      { "count": 67, "name": "JVM", "title": "JVM" },
      { "count": 56, "name": "java", "title": "java" },
      { "count": 44, "name": "性能", "title": "性能" },
      { "count": 38, "name": "计算机", "title": "计算机" },
      { "count": 34, "name": "java性能优化", "title": "java性能优化" },
      { "count": 30, "name": "编程", "title": "编程" }
    ],
    "origin_title": "Java Performance: The Definitive Guide",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28487617.jpg",
    "binding": "平装",
    "translator": ["柳飞", "陆明刚", "臧秀涛"],
    "catalog": "推荐序　　xi\n前言　　xii\n第1章　导论　　1\n1.1　概述　　2\n1.2　平台版本约定　　2\n1.3　全面的性能调优　　4\n1.3.1　编写更好的算法　　4\n1.3.2　编写更少的代码　　4\n1.3.3　老调重弹的过早优化　　5\n1.3.4　其他：数据库很可能就是瓶颈　　6\n1.3.5　常见的优化　　7\n1.4　小结　　8\n第2章　性能测试方法　　9\n2.1　原则1：测试真实应用　　9\n2.1.1　微基准测试　　9\n2.1.2　宏基准测试　　13\n2.1.3　介基准测试　　15\n2.1.4　代码示例　　16\n2.2　原则2：理解批处理流逝时间、吞吐量和响应时间　　19\n2.2.1　批处理流逝时间　　19\n2.2.2　吞吐量测试　　20\n2.2.3　响应时间测试　　20\n2.3　原则3：用统计方法应对性能的变化　　23\n2.4　原则4：尽早频繁测试　　26\n2.5　小结　　28\n第3章　Java性能调优工具箱　　29\n3.1　操作系统的工具和分析　　29\n3.1.1　CPU使用率　　29\n3.1.2　CPU运行队列　　32\n3.1.3　磁盘使用率　　33\n3.1.4　网络使用率　　34\n3.2　Java监控工具　　35\n3.2.1　基本的VM信息　　36\n3.2.2　线程信息　　39\n3.2.3　类信息　　39\n3.2.4　实时GC分析　　39\n3.2.5　事后堆转储　　39\n3.3　性能分析工具　　39\n3.3.1　采样分析器　　40\n3.3.2　探查分析器　　41\n3.3.3　阻塞方法和线程时间线　　42\n3.3.4　本地分析器　　44\n3.4　Java任务控制　　45\n3.4.1　Java飞行记录器　　46\n3.4.2　开启JFR　　52\n3.4.3　选择JFR 事件　　54\n3.5　小结　　56\n第4章　JIT编译器　　58\n4.1　JIT编译器：概览　　58\n4.2　调优入门：选择编译器类型（Client、Server或二者同用）　　61\n4.2.1　优化启动　　62\n4.2.2　优化批处理　　63\n4.2.3　优化长时间运行的应用　　64\n4.3　Java和JIT编译器版本　　64\n4.4　编译器中级调优　　67\n4.4.1　调优代码缓存　　67\n4.4.2　编译阈值　　68\n4.4.3　检测编译过程　　70\n4.5　高级编译器调优　　73\n4.5.1　编译线程　　73\n4.5.2　内联　　74\n4.5.3　逃逸分析　　75\n4.6　逆优化　　76\n4.6.1　代码被丢弃　　77\n4.6.2　逆优化僵尸代码　　78\n4.7　分层编译级别　　79\n4.8　小结　　80\n第5章　垃圾收集入门　　81\n5.1　垃圾收集概述　　81\n5.1.1　分代垃圾收集器　　83\n5.1.2　GC算法　　84\n5.1.3　选择GC算法　　87\n5.2　GC调优基础　　92\n5.2.1　调整堆的大小　　92\n5.2.2　代空间的调整　　95\n5.2.3　永久代和元空间的调整　　96\n5.2.4　控制并发　　97\n5.2.5　自适应调整　　98\n5.3　垃圾回收工具　　99\n5.4　小结　　102\n第6章　垃圾收集算法　　103\n6.1　理解Throughput收集器　　103\n6.2　理解CMS收集器　　109\n6.2.1　针对并发模式失效的调优　　113\n6.2.2　CMS收集器的永久代调优　　116\n6.2.3　增量式CMS垃圾收集　　117\n6.3　理解G1垃圾收集器　　118\n6.4　高级调优　　126\n6.4.1　晋升及Survivor空间　　126\n6.4.2　分配大对象　　129\n6.4.3　AggressiveHeap标志　　136\n6.4.4　全盘掌控堆空间的大小　　137\n6.5　小结　　138\n第7章　堆内存最佳实践　　140\n7.1　堆分析　　140\n7.1.1　堆直方图　　141\n7.1.2　堆转储　　142\n7.1.3　内存溢出错误　　146\n7.2　减少内存使用　　149\n7.2.1　减少对象大小　　149\n7.2.2　延迟初始化　　152\n7.2.3　不可变对象和标准化对象　　156\n7.2.4　字符串的保留　　157\n7.3　对象生命周期管理　　160\n7.3.1　对象重用　　160\n7.3.2　弱引用、软引用与其他引用　　165\n7.4　小结　　175\n第8章　原生内存最佳实践　　176\n8.1　内存占用　　176\n8.1.1　测量内存占用　　177\n8.1.2　内存占用最小化　　178\n8.1.3　原生NIO缓冲区　　178\n8.1.4　原生内存跟踪　　179\n8.2　针对不同操作系统优化JVM　　182\n8.2.1　大页　　182\n8.2.2　压缩的oop　　185\n8.3　小结　　187\n第9章　线程与同步的性能　　188\n9.1　线程池与ThreadPoolExecutor　　188\n9.1.1　设置最大线程数　　189\n9.1.2　设置最小线程数　　192\n9.1.3　线程池任务大小　　193\n9.1.4　设置ThreadPoolExecutor的大小　　193\n9.2　ForkJoinPool　　195\n9.3　线程同步　　201\n9.3.1　同步的代价　　202\n9.3.2　避免同步　　205\n9.3.3　伪共享　　208\n9.4　JVM线程调优　　211\n9.4.1　调节线程栈大小　　211\n9.4.2　偏向锁　　212\n9.4.3　自旋锁　　212\n9.4.4　线程优先级　　213\n9.5　监控线程与锁　　213\n9.5.1　查看线程　　214\n9.5.2　查看阻塞线程　　214\n9.6　小结　　217\n第10章　Java EE 性能调优　　218\n10.1　Web容器的基本性能　　218\n10.2　线程池　　222\n10.3　EJB会话Bean　　223\n10.3.1　调优EJB对象池　　223\n10.3.2　调优EJB缓存　　225\n10.3.3　本地和远程实例　　226\n10.4　XML和JSON处理　　227\n10.4.1　数据大小　　227\n10.4.2　解析和编组概述　　229\n10.4.3　选择解析器　　230\n10.4.4　XML验证　　235\n10.4.5　文档模型　　237\n10.4.6　Java对象模型　　240\n10.5　对象序列化　　241\n10.5.1　transient字段　　241\n10.5.2　覆盖默认的序列化　　241\n10.5.3　压缩序列化数据　　244\n10.5.4　追踪对象复制　　246\n10.6　Java EE网络API　　248\n10.7　小结　　250\n第11章　数据库性能的最佳实践　　251\n11.1　JDBC　　251\n11.1.1　JDBC驱动程序　　252\n11.1.2　预处理语句和语句池　　253\n11.1.3　JDBC连接池　　255\n11.1.4　事务　　256\n11.1.5　结果集的处理　　262\n11.2　JPA　　264\n11.2.1　事务处理　　264\n11.2.2　对JPA的写性能进行优化　　267\n11.2.3　对JPA的读性能进行优化　　268\n11.2.4　JPA缓存　　271\n11.2.5　JPA的只读实体　　276\n11.3　小结　　277\n第12章　Java SE API技巧　　278\n12.1　缓冲式I/O　　278\n12.2　类加载　　280\n12.3　随机数　　284\n12.4　Java原生接口　　285\n12.5　异常　　287\n12.6　字符串的性能　　290\n12.7　日志　　291\n12.8　Java集合类API　　292\n12.8.1　同步还是非同步　　293\n12.8.2　设定集合的大小　　294\n12.8.3　集合与内存使用效率　　295\n12.9　AggressiveOpts标志　　296\n12.9.1　替代实现　　296\n12.9.2　其他标志　　297\n12.10　Lambda表达式和匿名类　　297\n12.11　流和过滤器的性能　　300\n12.12　小结　　302\n附录A　性能调优标志摘要　　303\n作者简介　　312\n关于封面　　312",
    "pages": "312",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28487617.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28487617.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28487617.jpg"
    },
    "alt": "https://book.douban.com/subject/26740520/",
    "id": "26740520",
    "publisher": "人民邮电出版社",
    "isbn10": "7115413762",
    "isbn13": "9787115413765",
    "title": "Java性能权威指南",
    "url": "https://api.douban.com/v2/book/26740520",
    "alt_title": "Java Performance: The Definitive Guide",
    "author_intro": "Scott Oaks是Oracle公司的一位架构师，专注研究Oracle中间件软件的性能。加入Oracle之前，他曾于Sun Microsystem公司任职多年，在多个技术领域都有建树，包括SunOS的内核、网络程序设计、Windows系统的远程方法调用（RPC）以及 OPEN LOOK虚拟窗口管理器。1996年，Scott成为Sun公司的Java布道师，并于2001年加入Sun公司的Java性能小组——从那时起他就一直专注于Java的性能提升。此外，Scott也在O'Reilly出版社出版了多部书籍，包括Java Security、Java Threads、JXTA in a Nutshell和Jini in a Nutshell。",
    "summary": "市面上介绍Java的书有很多，但专注于Java性能的并不多，能游刃有余地展示Java性能优化难点的更是凤毛麟角，本书即是其中之一。通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。\n通过阅读本书，你可以：\n运用四个基本原则最大程度地提升性能测试的效果\n使用JDK中自带的工具收集Java应用的性能数据\n理解JIT编译器的优缺点\n调优JVM垃圾收集器以减少对程序的影响\n学习管理堆内存和JVM原生内存的方法\n了解如何最大程度地优化Java线程及同步的性能\n解决Java EE和Java SE应用程序接口的性能问题\n改善Java驱动的数据库应用程序的性能",
    "series": { "id": "46192", "title": "图灵程序设计丛书·Java系列" },
    "price": "CNY 79.00"
  },
  "9787115406095": {
    "rating": { "max": 10, "numRaters": 40, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["Benjamin J Evans", "David Flanagan"],
    "pubdate": "2015-12-1",
    "tags": [
      { "count": 29, "name": "Java", "title": "Java" },
      { "count": 14, "name": "计算机", "title": "计算机" },
      { "count": 12, "name": "JAVA", "title": "JAVA" },
      { "count": 11, "name": "编程语言", "title": "编程语言" },
      { "count": 9, "name": "编程", "title": "编程" },
      { "count": 6, "name": "O'Reilly", "title": "O'Reilly" },
      { "count": 5, "name": "程序设计", "title": "程序设计" },
      { "count": 3, "name": "基础", "title": "基础" }
    ],
    "origin_title": "Java in a Nutshell",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28350194.jpg",
    "binding": "平装",
    "translator": ["安道"],
    "catalog": "序 xv\n前言 xvi\n第一部分　Java 介绍\n第1 章　Java 环境介绍 2\n1．1　Java 语言、JVM 和生态系统 2\n1．1．1　Java 语言是什么 3\n1．1．2　JVM 是什么 4\n1．1．3　Java 生态系统是什么 5\n1．2　Java 和JVM 简史 6\n1．3　Java 程序的生命周期 7\n1．4　Java 的安全性 9\n1．5　Java 和其他语言比较 9\n1．5．1　Java 和C 语言比较 9\n1．5．2　Java 和C++ 比较 10\n1．5．3　Java 和PHP 比较 10\n1．5．4　Java 和JavaScript 比较 10\n1．6　回应对Java 的一些批评 10\n1．6．1　过度复杂 10\n1．6．2　变化慢 11\n1．6．3　性能问题 12\n1．6．4　不安全 12\n1．6．5　太注重企业 12\n第2 章　Java 基本句法 13\n2．1　Java 程序概览 14\n2．2　词法结构 14\n2．2．1　Unicode 字符集 14\n2．2．2　区分大小写与空白 14\n2．2．3　注释 15\n2．2．4　保留字 16\n2．2．5　标识符 16\n2．2．6　字面量 17\n2．2．7　标点符号 17\n2．3　基本数据类型 17\n2．3．1　布尔类型 18\n2．3．2　字符类型 18\n2．3．3　整数类型 20\n2．3．4　浮点数类型 21\n2．3．5　基本类型之间的转换 22\n2．4　表达式和运算符 24\n2．4．1　运算符概述 25\n2．4．2　算术运算符 28\n2．4．3　字符串连接运算符 30\n2．4．4　递增和递减运算符 30\n2．4．5　比较运算符 31\n2．4．6　逻辑运算符 32\n2．4．7　位运算符和位移运算符 33\n2．4．8　赋值运算符 35\n2．4．9　条件运算符 36\n2．4．10　instanceof 操作符 36\n2．4．11　特殊运算符 37\n2．5　语句 38\n2．5．1　表达式语句 39\n2．5．2　复合语句 39\n2．5．3　空语句 39\n2．5．4　标注语句 40\n2．5．5　局部变量声明语句 40\n2．5．6　if/else 语句 41\n2．5．7　switch 语句 43\n2．5．8　while 语句 45\n2．5．9　do 语句 45\n2．5．10　for 语句 46\n2．5．11　遍历语句 47\n2．5．12　break 语句 48\n2．5．13　continue 语句 49\n2．5．14　return 语句 49\n2．5．15　synchronized 语句 50\n2．5．16　throw 语句 50\n2．5．17　try/catch/finally 语句 51\n2．5．18　处理资源的try 语句 53\n2．5．19　assert 语句 54\n2．6　方法 55\n2．6．1　定义方法 55\n2．6．2　方法修饰符 57\n2．6．3　已检异常和未检异常 59\n2．6．4　变长参数列表 60\n2．7　介绍类和对象 61\n2．7．1　定义类 62\n2．7．2　创建对象 62\n2．7．3　使用对象 63\n2．7．4　对象字面量 63\n2．7．5　lambda 表达式 64\n2．8　数组 65\n2．8．1　数组的类型 65\n2．8．2　创建和初始化数组 67\n2．8．3　使用数组 68\n2．8．4　多维数组 70\n2．9　引用类型 72\n2．9．1　引用类型与基本类型比较 72\n2．9．2　处理对象和引用副本 73\n2．9．3　比较对象 74\n2．9．4　装包和拆包转换 75\n2．10　包和Java 命名空间 76\n2．10．1　声明包 76\n2．10．2　全局唯一的包名 77\n2．10．3　导入类型 77\n2．10．4　导入静态成员 79\n2．11　Java 文件的结构 80\n2．12　定义并运行Java 程序 81\n2．13　小结 82\n第3 章　Java 面向对象编程 83\n3．1　类简介 83\n3．1．1　面向对象的基本概念 83\n3．1．2　其他引用类型 84\n3．1．3　定义类的句法 85\n3．2　字段和方法 85\n3．2．1　声明字段的句法 86\n3．2．2　类字段 87\n3．2．3　类方法 88\n3．2．4　实例字段 89\n3．2．5　实例方法 89\n3．2．6　this 引用的工作方式 90\n3．3　创建和初始化对象 91\n3．3．1　定义构造方法 91\n3．3．2　定义多个构造方法 92\n3．3．3　在一个构造方法中调用另一个构造方法 92\n3．3．4　字段的默认值和初始化程序 93\n3．4　子类和继承 95\n3．4．1　扩展类 95\n3．4．2　超类、对象和类层次结构 97\n3．4．3　子类的构造方法 98\n3．4．4　构造方法链和默认构造方法 98\n3．4．5　遮盖超类的字段 100\n3．4．6　覆盖超类的方法 101\n3．5　数据隐藏和封装 104\n3．5．1　访问控制 105\n3．5．2　数据访问器方法 110\n3．6　抽象类和方法 111\n3．7　修饰符总结 115\n第4 章　Java 类型系统 117\n4．1　接口 118\n4．1．1　定义接口 118\n4．1．2　扩展接口 119\n4．1．3　实现接口 119\n4．1．4　实现多个接口 121\n4．1．5　默认方法 121\n4．1．6　标记接口 123\n4．2　Java 泛型 123\n4．2．1　介绍泛型 124\n4．2．2　泛型和类型参数 125\n4．2．3　菱形句法 126\n4．2．4　类型擦除 126\n4．2．5　通配符 127\n4．2．6　编译时和运行时类型 131\n4．3　枚举和注解 131\n4．3．1　枚举 131\n4．3．2　注解 133\n4．3．3　自定义注解 134\n4．3．4　类型注解 135\n4．4　嵌套类型 135\n4．4．1　静态成员类型 136\n4．4．2　非静态成员类 138\n4．4．3　局部类 141\n4．4．4　词法作用域和局部变量 144\n4．4．5　匿名类 145\n4．4．6　嵌套类型的运作方式 147\n4．5　lambda 表达式 148\n4．5．1　转换lambda 表达式 150\n4．5．2　方法引用 150\n4．5．3　函数式编程 151\n4．6　小结 152\n第5 章　Java 的面向对象设计 154\n5．1　Java 的值 154\n5．2　java．lang．Object 类的重要方法 155\n5．2．1　toString() 方法 157\n5．2．2　equals() 方法 157\n5．2．3　hashCode() 方法 158\n5．2．4　Comparable：：compareTo() 方法 158\n5．2．5　clone() 方法 159\n5．3　面向对象设计要略 159\n5．3．1　常量 159\n5．3．2　用接口还是抽象类 160\n5．3．3　实例方法还是类方法 161\n5．3．4　合成还是继承 163\n5．3．5　字段继承和访问器 165\n5．3．6　单例 167\n5．4　异常和异常处理 168\n5．5　Java 编程的安全性 170\n第6 章　Java 实现内存管理和并发编程的方式 172\n6．1　Java 内存管理的基本概念 172\n6．1．1　Java 中的内存泄露 173\n6．1．2　标记清除算法简介 173\n6．1．3　基本标记清除算法 174\n6．2　JVM 优化垃圾回收的方式 175\n6．3　HotSpot 堆 178\n6．3．1　回收老年代 178\n6．3．2　其他回收程序 179\n6．4　终结机制 180\n6．5　Java 对并发编程的支持 181\n6．5．1　线程的生命周期 182\n6．5．2　可见性和可变性 184\n6．5．3　互斥和状态保护 185\n6．5．4　volatile 关键字 187\n6．5．5　Thread 类中有用的方法 188\n6．6　使用线程 190\n6．7　小结 192\n第二部分　使用Java 平台\n第7 章　编程和文档约定 194\n7．1　命名和大小写约定 194\n7．2　实用的命名方式 196\n7．3　Java 文档注释 197\n7．3．1　文档注释的结构 198\n7．3．2　文档注释标签 198\n7．3．3　行内文档注释标签 201\n7．3．4　文档注释中的交叉引用 203\n7．3．5　包的文档注释 204\n7．4　可移植程序的约定 205\n第8 章　使用Java 集合 208\n8．1　介绍集合API 208\n8．1．1　Collection 接口 209\n8．1．2　Set 接口 211\n8．1．3　List 接口 213\n8．1．4　Map 接口 217\n8．1．5　Queue 接口和BlockingQueue 接口 220\n8．1．6　实用方法 222\n8．1．7　数组和辅助方法 224\n8．2　在Java 集合框架中使用lambda 表达式 225\n8．2．1　函数式方式 226\n8．2．2　流API 229\n8．3　小结 232\n第9 章　处理常见的数据格式 233\n9．1　文本 233\n9．1．1　字符串的特殊句法 233\n9．1．2　字符串的不可变性 235\n9．1．3　正则表达式 237\n9．2　数字和数学运算 240\n9．2．1　Java 表示整数类型的方式 240\n9．2．2　Java 中的浮点数 241\n9．2．3　Java 的数学函数标准库 243\n9．3　在Java 8 中处理日期和时间 245\n9．3．1　介绍Java 8 的日期和时间API 245\n9．3．2　查询 248\n9．3．3　调节器 249\n9．3．4　过时的日期和时间API 250\n9．4　小结 251\n第10 章　处理文件和I/O 252\n10．1　Java 处理I/O 的经典方式 252\n10．1．1　文件 253\n10．1．2　流 254\n10．1．3　Reader 和Writer 类 255\n10．1．4　再次介绍TWR 256\n10．1．5　I/O 经典处理方式的问题 257\n10．2　Java 处理I/O 的现代方式 257\n10．2．1　文件 258\n10．2．2　路径 259\n10．3　NIO 中的通道和缓冲区 261\n10．3．1　ByteBuffer 对象 261\n10．3．2　映射字节缓冲区 263\n10．4　异步I/O 263\n10．4．1　基于Future 接口的方式 264\n10．4．2　基于回调的方式 264\n10．4．3　监视服务和目录搜索 265\n10．5　网络 266\n10．5．1　HTTP 266\n10．5．2　TCP 268\n10．5．3　IP 270\n第11 章　类加载、反射和方法句柄 271\n11．1　类文件、类对象和元数据 271\n11．1．1　类对象示例 271\n11．1．2　类对象和元数据 272\n11．2　类加载的各个阶段 273\n11．2．1　加载 273\n11．2．2　验证 274\n11．2．3　准备和解析 274\n11．2．4　初始化 275\n11．3　安全的编程和类加载 276\n11．4　应用类加载知识 277\n11．5　反射 280\n11．5．1　什么时候使用反射 280\n11．5．2　如何使用反射 280\n11．6　动态代理 284\n11．7　方法句柄 285\n11．7．1　MethodType 对象 285\n11．7．2　方法查找 286\n11．7．3　调用方法句柄 287\n第12 章　Nashorn 289\n12．1　介绍Nashorn 289\n12．1．1　在JVM 中运行Java 之外的语言 289\n12．1．2　目的 290\n12．2　在Nashorn 中执行JavaScript 代码 290\n12．2．1　在命令行中运行 291\n12．2．2　使用Nashorn shell 291\n12．2．3　在jjs 中编写脚本 293\n12．3　Nashorn 和javax．script 包 297\n12．4　Nashorn 的高级用法 299\n12．4．1　在Nashorn 中调用Java 代码 299\n12．4．2　Nashorn 对JavaScript 语言所做的扩展 302\n12．4．3　实现细节 303\n12．5　小结 304\n第13 章　平台工具和配置 306\n13．1　命令行工具 306\n13．1．1　javac 307\n13．1．2　java 309\n13．1．3　jar 310\n13．1．4　javadoc 312\n13．1．5　jdeps 313\n13．1．6　jps 314\n13．1．7　jstat 315\n13．1．8　jstatd 315\n13．1．9　jinfo 316\n13．1．10　jstack 317\n13．1．11　jmap 317\n13．1．12　javap 318\n13．2　VisualVM 318\n13．3　Java 8 配置 324\n13．3．1　目的 324\n13．3．2　紧凑配置 325\n13．4　小结 328\n作者简介 329\n封面介绍 329",
    "pages": "329",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28350194.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28350194.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28350194.jpg"
    },
    "alt": "https://book.douban.com/subject/26674131/",
    "id": "26674131",
    "publisher": "人民邮电出版社",
    "isbn10": "711540609X",
    "isbn13": "9787115406095",
    "title": "Java技术手册（第6版）",
    "url": "https://api.douban.com/v2/book/26674131",
    "alt_title": "Java in a Nutshell",
    "author_intro": "Benjamin J. Evans是jClarity公司的联合创始人，伦敦Java用户组的组织者，JCP执行委员会委员。Java Champion和JavaOne Rockstar荣誉得主。与人合著有《Java程序员修炼之道》。他经常就Java平台、性能、并发和相关主题 发表公开演讲。\nDavid Flanagan是Mozilla的高级前端软件工程师，著有《JavaScript权威指南》《Ruby编程语言》等。博客地址是：davidflanagan.com。",
    "summary": "《Java技术手册 第6版》为《Java 技术手册》的升级版，涵盖全新的Java 7 和Java 8。第1部分介绍Java 编程语言和Java 平台，主要内容有Java 环境、Java 基本句法、Java 面向对象编程、Java 类型系统、Java的面向对象设计、Java 实现内存管理和并发编程的方式。第2部分通过大量示例来阐述如何在Java 环境中完成实际的编程任务，主要内容有编程和文档约定，使用Java 集合和数组，处理常见的数据格式，处理文件和I/O，类加载、反射和方法句柄，Nashorn，以及平台工具和配置。",
    "series": { "id": "46192", "title": "图灵程序设计丛书·Java系列" },
    "price": "79.00"
  },
  "9787111321545": {
    "rating": { "max": 10, "numRaters": 694, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["许晓斌"],
    "pubdate": "2010年12月",
    "tags": [
      { "count": 562, "name": "Maven", "title": "Maven" },
      { "count": 311, "name": "Java", "title": "Java" },
      { "count": 246, "name": "系统构建&自动化", "title": "系统构建&自动化" },
      { "count": 107, "name": "编程", "title": "编程" },
      { "count": 94, "name": "计算机", "title": "计算机" },
      { "count": 85, "name": "软件工程", "title": "软件工程" },
      { "count": 79, "name": "软件开发", "title": "软件开发" },
      { "count": 57, "name": "敏捷开发", "title": "敏捷开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s4524240.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "1. Maven简介\n1.1 何为Maven\n1.2 为什么需要Maven\n1.3 Maven与极限编程\n1.4 被误解的Maven\n2. Maven安装\n2.1 在Windows上安装Maven\n2.2 在基于Unix的系统上安装Maven\n2.3 安装目录分析\n2.4 设置HTTP代理\n2.5 安装m2eclipse\n2.6 安装NetBeans Maven插件\n2.7 Maven安装最佳实践\n3. Hello World\n3.1 编写POM\n3.2 编写主代码\n3.3 编写测试代码\n3.4 打包和运行\n3.5 使用Archetype生成项目骨架\n3.6 m2eclipse简单使用\n3.7 NetBeans Maven插件简单使用\n4. 背景案例\n4.1 简单的账户注册服务\n4.2 需求阐述\n4.3 简要设计\n5. 坐标和依赖\n5.1 何为Maven坐标\n5.2 坐标详解\n5.3 account-email\n5.4 依赖的配置\n5.5 依赖范围\n5.6 传递性依赖\n5.7 依赖调解\n5.8 可选依赖\n5.9 最佳实践\n6. 仓库\n6.1 何为Maven仓库\n6.2 仓库的布局\n6.3 仓库的分类\n6.4 远程仓库的配置\n6.5 快照版本\n6.6 从仓库解析依赖的机制\n6.7 镜像\n6.8 仓库搜索服务\n7. 生命周期和插件\n7.1 何为生命周期\n7.2 生命周期详解\n7.3 插件目标\n7.4 插件绑定\n7.5 插件配置\n7.6 获取插件信息\n7.7 从命令行调用插件\n7.8 插件解析机制\n8. 聚合与继承\n8.1 account-persist\n8.2 聚合\n8.3 继承\n8.4 聚合与继承的关系\n8.5 约定优于配置\n8.6 反应堆\n9. 使用 Nexus 创建私服\n9.1 Nexus简介\n9.2 安装Nexus\n9.3 Nexus的仓库与仓库组\n9.4 Nexus的索引与构件搜索\n9.5 配置Maven从Nexus下载构件\n9.6 部署构件至Nexus\n9.7 Nexus的权限管理\n9.8 Nexus的调度任务\n9.9 其他私服软件\n10. 使用 Maven 进行测试\n10.1 account-captcha\n10.2 maven-surefire-plugin简介\n10.3 跳过测试\n10.4 动态指定要运行的测试用例\n10.5 包含与排除测试用例\n10.6 测试报告\n10.7 运行TestNG测试\n10.8 重用测试代码\n11. 使用 Hudson 进行持续集成\n11.1 持续集成的作用、过程和优势\n11.2 Hudson简介\n11.3 安装Hudson\n11.4 准备Subversion仓库\n11.5 Hudson的基本系统设置\n11.6 创建Hudson任务\n11.7 监视Hudson任务状态\n11.8 Hudson用户管理\n11.9 邮件反馈\n11.10 Hudson工作目录\n12. 构建 Web 应用\n12.1 Web项目的基本结构\n12.2 account-service\n12.3 account-web\n12.4 使用jetty-maven-plugin进行测试\n12.5 使用Cargo实现自动化部署\n13. 版本管理\n13.1 何为版本管理\n13.2 Maven的版本号定义约定\n13.3 主干、标签与分支\n13.4 自动化版本发布\n13.5 自动化创建分支\n13.6 GPG签名\n14. 灵活的构建\n14.1 Maven属性\n14.2 构建环境的差异\n14.3 资源过滤\n14.4 Maven Profile\n14.5 Web资源过滤\n14.6 在Profile中激活集成测试\n15. 生成项目站点\n15.1 最简单的站点\n15.2 丰富项目信息\n15.3 项目报告插件\n15.4 自定义站点外观\n15.5 创建自定义页面\n15.6 国际化\n15.7 部署站点\n16. m2eclipse\n16.1 m2eclipse简介\n16.2 安装m2eclipse\n16.3 新建Maven项目\n16.4 导入Maven项目\n16.5 执行mvn命令\n16.6 访问Maven仓库\n16.7 管理项目依赖\n16.8 其它实用功能\n17. 编写 Maven 插件\n17.1 编写Maven插件的一般步骤\n17.2 代码行统计Maven插件\n17.3 Mojo标注\n17.4 Mojo参数\n17.5 错误处理和日志\n17.6 测试Maven插件\n18. Archetype\n18.1 Archetype使用再叙\n18.2 编写Archetype\n18.3 Archetype Catalog",
    "ebook_url": "https://read.douban.com/ebook/15131794/",
    "pages": "361",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s4524240.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s4524240.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s4524240.jpg"
    },
    "alt": "https://book.douban.com/subject/5345682/",
    "id": "5345682",
    "publisher": "机械工业出版社",
    "isbn10": "7111321545",
    "isbn13": "9787111321545",
    "title": "Maven实战",
    "url": "https://api.douban.com/v2/book/5345682",
    "alt_title": "",
    "author_intro": "许晓斌（Juven Xu），国内社区公认的Maven技术专家、Maven中文用户组创始人、Maven技术的先驱和积极推动者。对Maven有深刻的认识，实战经验丰富，不仅撰写了大量关于Maven的技术文章，而且还翻译了开源书籍《Maven权威指南》，对Maven技术在国内的普及和发展做出了很大的贡献。就职于Maven之父的公司，负责维护Maven中央仓库，是Maven仓库管理器Nexus（著名开源软件）的核心开发者之一，曾多次受邀到淘宝等大型企业开展Maven方面的培训。此外，他还是开源技术的积极倡导者和推动者，擅长Java开发和敏捷开发实践。",
    "summary": "你是否早已厌倦了日复一日的手工构建工作？你是否对各个项目风格迥异的构建系统感到恐惧？Maven——这一Java社区事实标准的项目管理工具，能帮你从琐碎的手工劳动中解脱出来，帮你规范整个组织的构建系统。不仅如此，它还有依赖管理、自动生成项目站点等超酷的特性，已经有无数的开源项目使用它来构建项目并促进团队交流，每天都有数以万计的开发者在访问中央仓库以获取他们需要的依赖。\n本书内容全面而系统，Maven的原理、使用方法和高级应用尽含其中；注重实战是本书的另一个特点，不仅在各个知识点都辅有大量的小案例，而且还有一个综合性的案例贯穿全书。如果你想使用Maven，或正在使用Maven，本书将给你绝佳的指导。\n本书讨论专区：http://www.juvenxu.com/mvn-in-action/",
    "ebook_price": "25.00",
    "series": { "id": "19972", "title": "实战系列" },
    "price": "65.00元"
  },
  "9787115453686": {
    "rating": { "max": 10, "numRaters": 121, "average": "7.8", "min": 0 },
    "subtitle": "Netty IN ACTION",
    "author": [
      "诺曼·毛瑞尔（Norman Maurer）",
      "马文·艾伦·沃尔夫泰尔（Marvin Allen Wolfthal）"
    ],
    "pubdate": "2017-5-1",
    "tags": [
      { "count": 128, "name": "Netty", "title": "Netty" },
      { "count": 83, "name": "Java", "title": "Java" },
      { "count": 68, "name": "网络编程", "title": "网络编程" },
      { "count": 37, "name": "Netty实战", "title": "Netty实战" },
      { "count": 21, "name": "计算机", "title": "计算机" },
      { "count": 21, "name": "网络", "title": "网络" },
      { "count": 14, "name": "分布式", "title": "分布式" },
      { "count": 13, "name": "性能优化", "title": "性能优化" }
    ],
    "origin_title": "Netty IN ACTION",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29444565.jpg",
    "binding": "平装",
    "translator": ["何品"],
    "catalog": "第一部分 Netty的概念及体系结构\n第1 章 Netty——异步和事件驱动 3\n1.1 Java 网络编程 4\n1.1.1 Java NIO 5\n1.1.2 选择器 6\n1.2 Netty 简介 6\n1.2.1 谁在使用Netty 7\n1.2.2 异步和事件驱动 8\n1.3 Netty 的核心组件 9\n1.3.1 Channel 9\n1.3.2 回调 9\n1.3.3 Future 10\n1.3.4 事件和ChannelHandler 11\n1.3.5 把它们放在一起 12\n1.4 小结 13\n第2 章 你的第一款Netty应用程序 14\n2.1 设置开发环境 14\n2.1.1 获取并安装Java 开发工具包 14\n2.1.2 下载并安装IDE 15\n2.1.3 下载和安装Apache Maven 15\n2.1.4 配置工具集 16\n2.2 Netty 客户端/服务器概览 16\n2.3 编写Echo 服务器 17\n2.3.1 ChannelHandler 和业务逻辑 17\n2.3.2 引导服务器 18\n2.4 编写Echo 客户端 21\n2.4.1 通过ChannelHandler 实现客户端逻辑 21\n2.4.2 引导客户端 22\n2.5 构建和运行Echo 服务器和客户端 24\n2.5.1 运行构建 24\n2.5.2 运行Echo 服务器和客户端 27\n2.6 小结 29\n第3 章 Netty 的组件和设计 30\n3.1 Channel、EventLoop 和ChannelFuture 30\n3.1.1 Channel 接口 31\n3.1.2 EventLoop 接口 31\n3.1.3 ChannelFuture 接口 32\n3.2 ChannelHandler 和ChannelPipeline 32\n3.2.1 ChannelHandler 接口 32\n3.2.2 ChannelPipeline 接口 33\n3.2.3 更加深入地了解ChannelHandler 34\n3.2.4 编码器和解码器 35\n3.2.5 抽象类SimpleChannelInboundHandler 35\n3.3 引导 36\n3.4 小结 37\n第4 章 传输 38\n4.1 案例研究：传输迁移 38\n4.1.1 不通过Netty 使用OIO和NIO 39\n4.1.2 通过Netty 使用OIO和NIO 41\n4.1.3 非阻塞的Netty 版本 42\n4.2 传输API 43\n4.3 内置的传输 45\n4.3.1 NIO——非阻塞I/O 46\n4.3.2 Epoll——用于Linux的本地非阻塞传输 47\n4.3.3 OIO——旧的阻塞I/O 48\n4.3.4 用于JVM 内部通信的Local 传输 48\n4.3.5 Embedded 传输 49\n4.4 传输的用例 49\n4.5 小结 51\n第5 章 ByteBuf 52\n5.1 ByteBuf 的API 52\n5.2 ByteBuf 类——Netty的数据容器 53\n5.2.1 它是如何工作的 53\n5.2.2 ByteBuf 的使用模式 53\n5.3 字节级操作 57\n5.3.1 随机访问索引 57\n5.3.2 顺序访问索引 57\n5.3.3 可丢弃字节 58\n5.3.4 可读字节 58\n5.3.5 可写字节 59\n5.3.6 索引管理 59\n5.3.7 查找操作 60\n5.3.8 派生缓冲区 60\n5.3.9 读/写操作 62\n5.3.10 更多的操作 64\n5.4 ByteBufHolder 接口 65\n5.5 ByteBuf 分配 65\n5.5.1 按需分配：ByteBufAllocator 接口 65\n5.5.2 Unpooled 缓冲区 67\n5.5.3 ByteBufUtil 类 67\n5.6 引用计数 67\n5.7 小结 68\n第6 章 ChannelHandler 和ChannelPipeline 70\n6.1 ChannelHandler 家族 70\n6.1.1 Channel 的生命周期 70\n6.1.2 ChannelHandler的生命周期 71\n6.1.3 ChannelInboundHandler接口 71\n6.1.4 ChannelOutboundHandler接口 73\n6.1.5 ChannelHandler 适配器 74\n6.1.6 资源管理 74\n6.2 ChannelPipeline 接口 76\n6.2.1 修改ChannelPipeline 78\n6.2.2 触发事件 79\n6.3 ChannelHandlerContext接口 80\n6.3.1 使用ChannelHandlerContext 82\n6.3.2 ChannelHandler 和ChannelHandlerContext 的高级用法 84\n6.4 异常处理 86\n6.4.1 处理入站异常 86\n6.4.2 处理出站异常 87\n6.5 小结 88\n第7 章 EventLoop 和线程模型 89\n7.1 线程模型概述 89\n7.2 EventLoop 接口 90\n7.2.1 Netty 4 中的I/O 和事件处理 92\n7.2.2 Netty 3 中的I/O 操作 92\n7.3 任务调度 93\n7.3.1 JDK 的任务调度API 93\n7.3.2 使用EventLoop调度任务 94\n7.4 实现细节 95\n7.4.1 线程管理 95\n7.4.2 EventLoop/线程的分配 96\n7.5 小结 98\n第8 章 引导 99\n8.1 Bootstrap 类 99\n8.2 引导客户端和无连接协议 101\n8.2.1 引导客户端 102\n8.2.2 Channel 和EventLoopGroup 的兼容性 103\n8.3 引导服务器 104\n8.3.1 ServerBootstrap 类 104\n8.3.2 引导服务器 105\n8.4 从Channel引导客户端 107\n8.5 在引导过程中添加多个ChannelHandler 108\n8.6 使用Netty 的ChannelOption 和属性 110\n8.7 引导DatagramChannel 111\n8.8 关闭 112\n8.9 小结 112\n第9 章 单元测试 113\n9.1 EmbeddedChannel概述 113\n9.2 使用EmbeddedChannel测试ChannelHandler 115\n9.2.1 测试入站消息 115\n9.2.2 测试出站消息 118\n9.3 测试异常处理 119\n9.4 小结 121\n第二部分 编解码器\n第10 章 编解码器框架 125\n10.1 什么是编解码器 125\n10.2 解码器 125\n10.2.1 抽象类ByteToMessageDecoder 126\n10.2.2 抽象类ReplayingDecoder 127\n10.2.3 抽象类MessageToMessageDecoder 128\n10.2.4 TooLongFrameException 类 130\n10.3 编码器 131\n10.3.1 抽象类MessageToByteEncoder 131\n10.3.2 抽象类MessageToMessageEncoder 132\n10.4 抽象的编解码器类 133\n10.4.1 抽象类ByteToMessageCodec 133\n10.4.2 抽象类MessageToMessageCodec 134\n10.4.3 CombinedChannelDuplexHandler 类 137\n10.5 小结 138\n第11 章 预置的ChannelHandler和编解码器 139\n11.1 通过SSL/TLS 保护Netty 应用程序 139\n11.2 构建基于Netty 的HTTP/HTTPS 应用程序 141\n11.2.1 HTTP 解码器、编码器和编解码器 141\n11.2.2 聚合HTTP 消息 143\n11.2.3 HTTP 压缩 144\n11.2.4 使用HTTPS 145\n11.2.5 WebSocket 146\n11.3 空闲的连接和超时 148\n11.4 解码基于分隔符的协议和基于长度的协议 150\n11.4.1 基于分隔符的协议 150\n11.4.2 基于长度的协议 153\n11.5 写大型数据 155\n11.6 序列化数据 1 57\n11.6.1 JDK 序列化 157\n11.6.2 使用JBoss Marshalling进行序列化 157\n11.6.3 通过Protocol Buffers序列化 159\n11.7 小结 160\n第三部分 网络协议\n第12 章 WebSocket 163\n12.1 WebSocket 简介 163\n12.2 我们的WebSocket 示例应用程序 164\n12.3 添加WebSocket支持 165\n12.3.1 处理HTTP 请求 165\n12.3.2 处理WebSocket 帧 168\n12.3.3 初始化ChannelPipeline 169\n12.3.4 引导 171\n12.4 测试该应用程序 173\n12.5 小结 176\n第13章 使用UDP 广播事件 177\n13.1 UDP 的基础知识 177\n13.2 UDP 广播 178\n13.3 UDP 示例应用程序 178\n13.4 消息 POJO:LogEvent 179\n13.5 编写广播者 180\n13.6 编写监视器 185\n13.7 运行LogEventBroadcaster 和LogEventMonitor 187\n13.8 小结 189\n第四部分 案例研究\n第14 章 案例研究，第一部分 193\n14.1 Droplr—构建移动服务 193\n14.1.1 这一切的起因 193\n14.1.2 Droplr 是怎样工作的 194\n14.1.3 创造一个更加快速的上传体验 194\n14.1.4 技术栈 196\n14.1.5 性能 199\n14.1.6 小结——站在巨人的肩膀上 200\n14.2 Firebase—实时的数据同步服务 200\n14.2.1 Firebase 的架构 201\n14.2.2 长轮询 201\n14.2.3 HTTP 1.1 keep-alive和流水线化 204\n14.2.4 控制SslHandler 205\n14.2.5 Firebase 小结 207\n14.3 Urban Airship—构建移动服务 207\n14.3.1 移动消息的基础知识 207\n14.3.2 第三方递交 208\n14.3.3 使用二进制协议的例子 209\n14.3.4 直接面向设备的递交 211\n14.3.5 Netty 擅长管理大量的并发连接 212\n14.3.6 Urban Airship 小结——跨越防火墙边界 213\n14.4 小结 214\n第15 章 案例研究，第二部分 215\n15.1 Netty 在Facebook 的使用：Nifty 和Swift 215\n15.1.1 什么是Thrift 215\n15.1.2 使用Netty 改善Java Thrift 的现状 216\n15.1.3 Nifty 服务器的设计 217\n15.1.4 Nifty 异步客户端的设计 220\n15.1.5 Swift：一种更快的构建Java Thrift 服务的方式 221\n15.1.6 结果 221\n15.1.7 Facebook 小结 224\n15.2 Netty 在Twitter的使用：Finagle 224\n15.2.1 Twitter 成长的烦恼 224\n15.2.2 Finagle 的诞生 224\n15.2.3 Finagle 是如何工作的 225\n15.2.4 Finagle 的抽象 230\n15.2.5 故障管理 231\n15.2.6 组合服务 232\n15.2.7 未来：Netty 232\n15.2.8 Twitter 小结 233\n15.3 小结 233\n附录 Maven 介绍 234",
    "pages": "276",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29444565.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29444565.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29444565.jpg"
    },
    "alt": "https://book.douban.com/subject/27038538/",
    "id": "27038538",
    "publisher": "人民邮电出版社",
    "isbn10": "7115453683",
    "isbn13": "9787115453686",
    "title": "Netty实战",
    "url": "https://api.douban.com/v2/book/27038538",
    "alt_title": "Netty IN ACTION",
    "author_intro": "Norman Maurer，是苹果公司的资深软件工程师，同时也是Netty的核心开发人员。\nMarvin Allen Wolfthal，是Dell Services的顾问，他使用Netty实现了多个任务关键型的企业系统。\n何品，目前是淘宝的一名资深软件工程师，热爱网络、并发、异步相关的主题以及函数式编程，同时也是Netty、Akka等项目的贡献者，活跃于Scala社区，目前也在从事GraphQL相关的开发工作。",
    "summary": "编辑推荐\n\n- Netty之父”Trustin Lee作序推荐\n- 阿里巴巴中间件高级技术专家为本书中文版作序推荐\n- 系统而详细地介绍了Netty的各个方面并附带了即用型的优质示例\n- 附带行业一线公司的案例研究\n- 极实用的Netty技术书\n无论是构建高性能的Web、游戏服务器、推送系统、RPC框架、消息中间件还是分布式大数据处理引擎，都离不开Netty，在整个行业中，Netty广泛而成功的应用，使其成为了Java高性能网络编程的卓绝框架。\nNetty的现Tech Lead Norman在本书中循序渐进地讲解了Netty的各个关键部分，在看完本书后，你不但可以熟练地使用Netty来构建以上系统，并且还可以避免很多常见的陷阱。\n无论是想要学习Spring 5 、Spark、Cassandra等这样的系统，还是通过学习Netty来构建自己的基于Java的高性能网络框架，或者是更加具体的高性能Web或者游戏服务器等，本书都将是你的超强拍档。\n本书中文版基于Netty4.1.9做了修订，希望本书能够给你带来一个接近完美的阅读体验，并能帮到你。\n内容提要\n本书是为想要或者正在使用Java从事高性能网络编程的人而写的，循序渐进地介绍了Netty各个方面的内容。\n本书共分为4个部分：第一部分详细地介绍Netty的相关概念以及核心组件，第二部分介绍自定义协议经常用到的编解码器，第三部分介绍Netty对于应用层高级协议的支持，会覆盖常见的协议及其在实践中的应用，第四部分是几个案例研究。此外，附录部分还会简单地介绍Maven，以及如何通过使用Maven编译和运行本书中的示例。\n阅读本书不需要读者精通Java网络和并发编程。如果想要更加深入地理解本书背后的理念以及Netty源码本身，可以系统地学习一下Java网络编程、NIO、并发和异步编程以及相关的设计模式。\n本文仅用于学习和交流目的，不代表异步社区观点。非商业转载请注明作译者、出处，并保留本文的原始链接。",
    "price": "69.00"
  },
  "9787115433145": {
    "rating": { "max": 10, "numRaters": 208, "average": "7.2", "min": 0 },
    "subtitle": "",
    "author": ["[美]克雷格·沃斯"],
    "pubdate": "2016-9",
    "tags": [
      { "count": 130, "name": "SpringBoot", "title": "SpringBoot" },
      { "count": 120, "name": "Spring", "title": "Spring" },
      { "count": 113, "name": "Java", "title": "Java" },
      { "count": 38, "name": "计算机", "title": "计算机" },
      { "count": 38, "name": "编程", "title": "编程" },
      { "count": 31, "name": "微服务", "title": "微服务" },
      { "count": 22, "name": "软件开发", "title": "软件开发" },
      { "count": 22, "name": "技术", "title": "技术" }
    ],
    "origin_title": "Spring Boot in Action",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28983685.jpg",
    "binding": "平装",
    "translator": ["丁雪丰"],
    "catalog": "第1章　入门　　1\n1.1　Spring风云再起　　1\n1.1.1　重新认识Spring　　2\n1.1.2　Spring Boot精要　　3\n1.1.3　Spring Boot不是什么　　6\n1.2　Spring Boot入门　　6\n1.2.1　安装Spring Boot CLI　　7\n1.2.2　使用Spring Initializr初始化Spring Boot项目　　10\n1.3　小结　　18\n第2章　开发第一个应用程序　　19\n2.1　运用Spring Boot　　19\n2.1.1　查看初始化的Spring Boot新项目　　21\n2.1.2　Spring Boot项目构建过程解析　　24\n2.2　使用起步依赖　　27\n2.2.1　指定基于功能的依赖　　28\n2.2.2　覆盖起步依赖引入的传递依赖　　29\n2.3　使用自动配置　　30\n2.3.1　专注于应用程序功能　　31\n2.3.2　运行应用程序　　36\n2.3.3　刚刚发生了什么　　38\n2.4　小结　　41\n第3章　自定义配置　　42\n3.1　覆盖Spring Boot自动配置　　42\n3.1.1　保护应用程序　　43\n3.1.2　创建自定义的安全配置　　44\n3.1.3　掀开自动配置的神秘面纱　　48\n3.2　通过属性文件外置配置　　49\n3.2.1　自动配置微调　　50\n3.2.2　应用程序Bean的配置外置　　55\n3.2.3　使用Profile进行配置　　59\n3.3　定制应用程序错误页面　　62\n3.4　小结　　64\n第4章　测试　　66\n4.1　集成测试自动配置　　66\n4.2　测试Web应用程序　　68\n4.2.1　模拟Spring MVC　　69\n4.2.2　测试Web安全　　72\n4.3　测试运行中的应用程序　　74\n4.3.1　用随机端口启动服务器　　75\n4.3.2　使用Selenium测试HTML页面　　76\n4.4　小结　　78\n第5章　Groovy与Spring Boot CLI　　80\n5.1　开发Spring Boot CLI应用程序　　80\n5.1.1　设置CLI项目　　81\n5.1.2　通过Groovy消除代码噪声　　81\n5.1.3　发生了什么　　85\n5.2　获取依赖　　86\n5.2.1　覆盖默认依赖版本　　87\n5.2.2　添加依赖仓库　　88\n5.3　用CLI运行测试　　89\n5.4　创建可部署的产物　　91\n5.5　小结　　91\n第6章　在Spring Boot中使用Grails　　93\n6.1　使用GORM进行数据持久化　　93\n6.2　使用Groovy Server Pages定义视图　　98\n6.3　结合Spring Boot与Grails 3　　100\n6.3.1　创建新的Grails项目　　100\n6.3.2　定义领域模型　　103\n6.3.3　开发Grails控制器　　104\n6.3.4　创建视图　　105\n6.4　小结　　107\n第7章　深入Actuator　　108\n7.1　揭秘Actuator的端点　　108\n7.1.1　查看配置明细　　109\n7.1.2　运行时度量　　115\n7.1.3　关闭应用程序　　121\n7.1.4　获取应用信息　　121\n7.2　连接Actuator的远程shell　　122\n7.2.1　查看autoconfig报告　　123\n7.2.2　列出应用程序的Bean　　124\n7.2.3　查看应用程序的度量信息　　124\n7.2.4　调用Actuator端点　　125\n7.3　通过JMX监控应用程序　　126\n7.4　定制Actuator　　128\n7.4.1　修改端点ID　　128\n7.4.2　启用和禁用端点　　129\n7.4.3　添加自定义度量信息　　129\n7.4.4　创建自定义跟踪仓库　　132\n7.4.5　插入自定义健康指示器　　134\n7.5　保护Actuator端点　　136\n7.6　小结　　138\n第8章　部署Spring Boot应用程序　　139\n8.1　衡量多种部署方式　　139\n8.2　部署到应用服务器　　140\n8.2.1　构建WAR文件　　141\n8.2.2　创建生产Profile　　142\n8.2.3　开启数据库迁移　　145\n8.3　推上云端　　150\n8.3.1　部署到Cloud Foundry　　150\n8.3.2　部署到Heroku　　153\n8.4　小结　　155\n附录A　Spring Boot开发者工具　　157\n附录B　Spring Boot起步依赖　　163\n附录C　配置属性　　169\n附录D　Spring Boot依赖　　202",
    "pages": "209",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28983685.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28983685.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28983685.jpg"
    },
    "alt": "https://book.douban.com/subject/26857423/",
    "id": "26857423",
    "publisher": "人民邮电出版社",
    "isbn10": "7115433143",
    "isbn13": "9787115433145",
    "title": "Spring Boot实战",
    "url": "https://api.douban.com/v2/book/26857423",
    "alt_title": "Spring Boot in Action",
    "author_intro": "Craig Walls\nPivotal高级工程师，Spring Social及Spring Sync项目领导者，著名技术博主，畅销书《Spring实战》作者。他致力于推广Spring框架，笔耕不辍，亦时常作为演讲嘉宾出席各类相关会议。\n译者简介：\n丁雪丰　 资深开发及运维工程师，活跃的技术图书译者，致力于推动优秀技术在国内的发展，出版了《Spring攻略》《MongoDB实战》《RESTful Web Service Cookbook中文版》等6部译著。",
    "summary": "本书以Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。作者行文亲切流畅，以大量示例讲解了Spring Boot在各类情境中的应用，内容涵盖起步依赖、Spring Boot CLI、Groovy、Grails、Actuator。对于Spring Boot开发应用中较为繁琐的内容，附录奉上整理完毕的表格，一目了然，方便读者查阅。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "59.00元"
  },
  "9787121313011": {
    "rating": { "max": 10, "numRaters": 138, "average": "7.9", "min": 0 },
    "subtitle": "",
    "author": ["翟永超"],
    "pubdate": "2017-5",
    "tags": [
      { "count": 129, "name": "微服务", "title": "微服务" },
      { "count": 100, "name": "SpringCloud", "title": "SpringCloud" },
      { "count": 84, "name": "Spring", "title": "Spring" },
      { "count": 64, "name": "Java", "title": "Java" },
      { "count": 41, "name": "架构", "title": "架构" },
      { "count": 39, "name": "计算机", "title": "计算机" },
      { "count": 32, "name": "Cloud", "title": "Cloud" },
      { "count": 23, "name": "编程", "title": "编程" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29434190.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章　基础知识\t1\n什么是微服务架构\t1\n-- 与单体系统的区别\t1\n-- 如何实施微服务\t2\n为什么选择Spring Cloud\t6\nSpring Cloud简介\t7\n版本说明\t8\n第2章　微服务构建：Spring Boot\t11\n框架简介\t12\n快速入门\t13\n-- 项目构建与解析\t13\n-- 实现RESTful API\t17\n配置详解\t20\n-- 配置文件\t20\n-- 自定义参数\t22\n-- 参数引用\t22\n-- 使用随机数\t23\n-- 命令行参数\t23\n-- 多环境配置\t24\n-- 加载顺序\t25\n监控与管理\t26\n-- 初识actuator\t27\n-- 原生端点\t28\n小结\t38\n第3章　服务治理：Spring Cloud Eureka\t39\n服务治理\t39\n-- Netflix Eureka\t40\n--搭建服务注册中心\t41\n--注册服务提供者\t43\n--高可用注册中心\t46\n--服务发现与消费\t48\nEureka详解\t51\n--基础架构\t52\n--服务治理机制\t52\n--源码分析\t56\n配置详解\t65\n--服务注册类配置\t65\n--服务实例类配置\t67\n跨平台支持\t71\n第4章　客户端负载均衡：Spring Cloud Ribbon\t73\n客户端负载均衡\t73\nRestTemplate详解\t75\n-- GET请求\t75\n-- POST请求\t77\n-- PUT请求\t79\n-- DELETE请求\t79\n源码分析\t80\n-- 负载均衡器\t91\n-- 负载均衡策略\t109\n配置详解\t123\n--自动化配置\t124\n-- Camden版本对RibbonClient配置的优化\t125\n-- 参数配置\t127\n-- 与Eureka结合\t127\n重试机制\t128\n第5章　服务容错保护：Spring Cloud Hystrix\t130\n快速入门\t131\n原理分析\t135\n-- 工作流程\t135\n-- 断路器原理\t144\n-- 依赖隔离\t148\n使用详解\t151\n-- 创建请求命令\t151\n-- 定义服务降级\t154\n-- 异常处理\t157\n-- 命令名称、分组以及线程池划分\t158\n-- 请求缓存\t159\n-- 请求合并\t166\n属性详解\t172\n-- Command属性\t174\n-- collapser属性\t184\n-- threadPool属性\t185\nHystrix仪表盘\t187\nTurbine集群监控\t192\n-- 构建监控聚合服务\t192\n-- 与消息代理结合\t196\n第6章　声明式服务调用：Spring Cloud Feign\t199\n快速入门\t200\n参数绑定\t202\n继承特性\t205\nRibbon配置\t209\n全局配置\t209\n指定服务配置\t209\n重试机制\t210\nHystrix配置\t211\n全局配置\t211\n禁用Hystrix\t211\n指定命令配置\t212\n服务降级配置\t212\n其他配置\t214\n第7章　API网关服务：Spring Cloud Zuul\t217\n快速入门\t219\n-- 构建网关\t220\n-- 请求路由\t221\n-- 请求过滤\t223\n路由详解\t226\n-- 传统路由配置\t226\n-- 服务路由配置\t228\n-- 服务路由的默认规则\t229\n-- 自定义路由映射规则\t229\n-- 路径匹配\t230\n-- 路由前缀\t233\n-- 本地跳转\t234\n--  Cookie与头信息\t235\n-- Hystrix和Ribbon支持\t236\n过滤器详解\t238\n-- 过滤器\t238\n-- 请求生命周期\t239\n-- 核心过滤器\t240\n-- 异常处理\t244\n-- 禁用过滤器\t256\n动态加载\t257\n-- 动态路由\t257\n-- 动态过滤器\t261\n第8章　分布式配置中心：Spring Cloud Config\t267\n快速入门\t267\n-- 构建配置中心\t268\n-- 配置规则详解\t269\n-- 客户端配置映射\t272\n服务端详解\t274\n-- 基础架构\t274\n-- Git配置仓库\t276\n-- SVN配置仓库\t279\n-- 本地仓库\t279\n-- 本地文件系统\t279\n-- 健康监测\t280\n-- 属性覆盖\t281\n-- 安全保护\t281\n-- 加密解密\t282\n-- 高可用配置\t286\n客户端详解\t286\n--  URI指定配置中心\t287\n-- 服务化配置中心\t287\n-- 失败快速响应与重试\t290\n-- 获取远程配置\t292\n-- 动态刷新配置\t293\n第9章　消息总线：Spring Cloud Bus\t295\n消息代理\t295\nRabbitMQ实现消息总线\t296\n-- 基本概念\t297\n-- 安装与使用\t298\n-- 快速入门\t302\n-- 整合Spring Cloud Bus\t306\n-- 原理分析\t307\n-- 指定刷新范围\t308\n-- 架构优化\t309\n-- RabbitMQ配置\t310\nKafka实现消息总线\t312\n-- Kafka简介\t312\n-- 快速入门\t313\n--整合Spring Cloud Bus\t315\n-- Kafka配置\t318\n深入理解\t318\n-- 源码分析\t320\n-- 其他消息代理的支持\t342\n第10章　消息驱动的微服务：Spring Cloud Stream\t344\n快速入门\t344\n核心概念\t349\n-- 绑定器\t350\n-- 发布-订阅模式\t351\n-- 消费组\t353\n-- 消息分区\t354\n使用详解\t355\n-- 开启绑定功能\t355\n-- 绑定消息通道\t356\n-- 消息生产与消费\t360\n-- 响应式编程\t366\n-- 消费组与消息分区\t368\n-- 消息类型\t370\n绑定器详解\t373\n-- 绑定器SPI\t373\n-- 自动化配置\t374\n-- 多绑定器配置\t374\n--  RabbitMQ与Kafka绑定器\t376\n配置详解\t376\n-- 基础配置\t377\n-- 绑定通道配置\t377\n-- 绑定器配置\t379\n第11章　分布式服务跟踪：Spring Cloud Sleuth\t386\n快速入门\t386\n-- 准备工作\t386\n-- 实现跟踪\t389\n跟踪原理\t390\n抽样收集\t392\n与Logstash整合\t394\n与Zipkin整合\t397\n--  HTTP收集\t398\n-- 消息中间件收集\t402\n-- 收集原理\t404\n-- 数据存储\t414\n--  API接口\t417\n附录A　Starter POMs\t419\n后记\t421",
    "pages": "440",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29434190.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29434190.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29434190.jpg"
    },
    "alt": "https://book.douban.com/subject/27025912/",
    "id": "27025912",
    "publisher": "电子工业出版社",
    "isbn10": "7121313014",
    "isbn13": "9787121313011",
    "title": "Spring Cloud微服务实战",
    "url": "https://api.douban.com/v2/book/27025912",
    "alt_title": "",
    "author_intro": "",
    "summary": "《Spring Cloud微服务实战》从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。\n《Spring Cloud微服务实战》适合所有Java开发人员，尤其适合正在做微服务架构技术选型或正在实施微服务架构的团队查阅和参考。",
    "price": "89"
  },
  "9787115209429": {
    "rating": { "max": 10, "numRaters": 240, "average": "9.1", "min": 0 },
    "subtitle": "",
    "author": ["王福强"],
    "pubdate": "2009.8",
    "tags": [
      { "count": 502, "name": "Spring", "title": "Spring" },
      { "count": 307, "name": "Java", "title": "Java" },
      { "count": 171, "name": "框架", "title": "框架" },
      { "count": 103, "name": "Web开发", "title": "Web开发" },
      { "count": 90, "name": "J2EE", "title": "J2EE" },
      { "count": 82, "name": "编程", "title": "编程" },
      { "count": 78, "name": "计算机", "title": "计算机" },
      { "count": 62, "name": "Framework", "title": "Framework" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s3949449.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第一部分 掀起Spring的盖头来\n第1章 Spring框架的由来 2\n1.1 Spring之崛起 2\n1.2 Spring框架概述 3\n1.3 Spring大观园 5\n1.4 小结 8\n第二部分 Spring的IoC容器\n第2章 IoC的基本概念 10\n2.1 我们的理念是：让别人为你服务 10\n2.2 手语，呼喊，还是心有灵犀 13\n2.2.1 构造方法注入 13\n2.2.2 setter方法注入 13\n2.2.3 接口注入 14\n2.2.4 三种注入方式的比较 15\n2.3 IoC的附加值 15\n2.4 小结 17\n第3章 掌管大局的IoC Service Provider 18\n3.1 IoC Service Provider的职责 18\n3.2 运筹帷幄的秘密——IoC Service Provider如何管理对象间的依赖关系 19\n3.2.1 直接编码方式 19\n3.2.2 配置文件方式 20\n3.2.3 元数据方式 21\n3.3 小结 21\n第4章 Spring的IoC容器之BeanFactory 22\n4.1 拥有BeanFactory之后的生活 24\n4.2 BeanFactory的对象注册与依赖绑定方式 26\n4.2.1 直接编码方式 26\n4.2.2 外部配置文件方式 28\n4.2.3 注解方式 31\n4.3 BeanFactory的XML之旅 33\n4.3.1 beans和bean 33\n4.3.2 孤孤单单一个人 35\n4.3.3 Help Me， Help You 36\n4.3.4 继承？我也会！ 50\n4.3.5 bean的scope 51\n4.3.6 工厂方法与FactoryBean 56\n4.3.7 偷梁换柱之术 61\n4.4 容器背后的秘密 66\n4.4.1 “战略性观望” 66\n4.4.2 插手“容器的启动” 67\n4.4.3 了解bean的一生 74\n4.5 小结 85\n第5章 Spring IoC容器ApplicationContext 86\n5.1 统一资源加载策略 86\n5.1.1 Spring中的Resource 87\n5.1.2 ResourceLoader，“更广义的URL” 88\n5.1.3 ApplicationContext与ResourceLoader 91\n5.2 国际化信息支持(I18n MessageSource) 97\n5.2.1 Java SE提供的国际化支持 97\n5.2.2 MessageSource与ApplicationContext 98\n5.3 容器内部事件发布 102\n5.3.1 自定义事件发布 102\n5.3.2 Spring的容器内事件发布类结构分析 105\n5.3.3 Spring容器内事件发布的应用 107\n5.4 多配置模块加载的简化 109\n5.5 小结 110\n第6章 Spring IoC容器之扩展篇 111\n6.1 Spring 2.5的基于注解的依赖注入 111\n6.1.1 注解版的自动绑定(@Autowired) 111\n6.1.2 @Autowired之外的选择——使用JSR250标注依赖注入关系 115\n6.1.3 将革命进行得更彻底一些(class-path-scanning功能介绍) 116\n6.2 Spring 3.0展望 119\n6.3 小结 120\n第三部分 Spring AOP框架\n第7章 一起来看AOP 122\n7.1 AOP的尴尬 124\n7.2 AOP走向现实 125\n7.2.1 静态AOP时代 125\n7.2.2 动态AOP时代 126\n7.3 Java平台上的AOP实现机制 126\n7.3.1 动态代理 126\n7.3.2 动态字节码增强 126\n7.3.3 Java代码生成 127\n7.3.4 自定义类加载器 127\n7.3.5 AOL扩展 127\n7.4 AOP国家的公民 128\n7.4.1 Joinpoint 128\n7.4.2 Pointcut 130\n7.4.3 Advice 131\n7.4.4 Aspect 133\n7.4.5 织入和织入器 133\n7.4.6 目标对象 133\n7.5 小结 134\n第8章 Spring AOP概述及其实现机制 135\n8.1 Spring AOP概述 135\n8.2 Spring AOP的实现机制 136\n8.2.1 设计模式之代理模式 136\n8.2.2 动态代理 139\n8.2.3 动态字节码生成 141\n8.3 小结 142\n第9章 Spring AOP一世 143\n9.1 Spring AOP中的Joinpoint 143\n9.2 Spring AOP中的Pointcut 144\n9.2.1 常见的Pointcut 146\n9.2.2 扩展Pointcut(Customize Pointcut) 151\n9.2.3 IoC容器中的Pointcut 152\n9.3 Spring AOP中的Advice 153\n9.3.1 per-class类型的Advice 153\n9.3.2 per-instance类型的Advice 159\n9.4 Spring AOP中的Aspect 163\n9.4.1 PointcutAdvisor家族 164\n9.4.2 IntroductionAdvisor分支 167\n9.4.3 Ordered的作用 168\n9.5 Spring AOP的织入 170\n9.5.1 如何与ProxyFactory打交道 170\n9.5.2 看清ProxyFactory的本质 175\n9.5.3 容器中的织入器——ProxyFactoryBean 179\n9.5.4 加快织入的自动化进程 185\n9.6 TargetSource 190\n9.6.1 可用的TargetSource实现类 191\n9.6.2 自定义TargetSource 195\n9.7 小结 197\n第10章 Spring AOP二世 198\n10.1 @AspectJ形式的Spring AOP 198\n10.1.1 @AspectJ形式AOP使用之先睹为快 199\n10.1.2 @AspectJ形式的Pointcut 201\n10.1.3 @AspectJ形式的Advice 211\n10.1.4 @AspectJ中的Aspect更多话题 220\n10.2 基于Schema的AOP 223\n10.2.1 基于Schema的AOP配置概览 223\n10.2.2 向基于Schema的AOP迁移 225\n10.2.3 @AspectJ到“基于Schema的AOP”迁移 227\n10.3 小结 235\n第11章 AOP应用案例 237\n11.1 异常处理 237\n11.1.1 Java异常处理 237\n11.1.2 Fault Barrier 238\n11.2 安全检查 239\n11.3 缓存 240\n11.4 小结 240\n第12章 Spring AOP之扩展篇 241\n12.1 有关公开当前调用的代理对象的探讨 241\n12.1.1 问题的现象 241\n12.1.2 原因的分析 242\n12.1.3 解决方案 243\n12.2 小结 245\n第四部分 使用Spring访问数据\n第13章 统一的数据访问异常层次体系 249\n13.1 DAO模式的背景 249\n13.2 梦想照进现实 251\n13.3 发现问题，解决问题 252\n13.4 不重新发明轮子 254\n13.5 小结 257\n第14章 JDBC API的最佳实践 258\n14.1 基于Template的JDBC使用方式 258\n14.1.1 JDBC的尴尬 258\n14.1.2 JdbcTemplate的诞生 261\n14.1.3 JdbcTemplate和它的兄弟们 274\n14.1.4 Spring中的DataSource 296\n14.1.5 JdbcDaoSupport 301\n14.2 基于操作对象的JDBC使用方式 302\n14.2.1 基于操作对象的查询 303\n14.2.2 基于操作对象的更新 310\n14.2.3 基于操作对象的存储过程调用 313\n14.3 小结 316\n第15章 Spring对各种ORM的集成 317\n15.1 Spring对Hibernate的集成 318\n15.1.1 旧日“冬眠”时光 318\n15.1.2 “春天”里的“冬眠” 321\n15.2 Spring对iBATIS的集成 329\n15.2.1 iBATIS实践之“前生”篇 329\n15.2.2 iBATIS实践之“今世”篇 331\n15.3 Spring中对其他ORM方案的集成概述 337\n15.3.1 Spring对JDO的集成 337\n15.3.2 Spring对TopLink的集成 340\n15.3.3 Spring对JPA的集成 341\n15.4 小结 344\n第16章 Spring数据访问之扩展篇 345\n16.1 活用模板方法模式及Callback 345\n16.1.1 FTPClientTemplate 345\n16.1.2 HttpClientTemplate 349\n16.2 数据访问中的多数据源 350\n16.2.1 “主权独立”的多数据源 350\n16.2.2 “合纵连横”的多数据源 352\n16.2.3 结束语 354\n16.3 Spring 3.0展望 356\n16.4 小结 356\n第五部分 事务管理\n第17章 有关事务的楔子 358\n17.1 认识事务本身 358\n17.2 初识事务家族成员 360\n17.3 小结 362\n第18章 群雄逐鹿下的Java事务管理 363\n18.1 Java平台的局部事务支持 363\n18.2 Java平台的分布式事务支持 365\n18.2.1 基于JTA的分布式事务管理 366\n18.2.2 基于JCA的分布式事务管理 367\n18.3 继续前行之前的反思 367\n18.4 小结 369\n第19章 Spring事务王国的架构 370\n19.1 统一中原的过程 371\n19.2 和平年代 376\n19.2.1 TransactionDefinition 376\n19.2.2 TransactionStatus 382\n19.2.3 PlatformTransac-tionManager 382\n19.3 小结 392\n第20章 使用Spring进行事务管理 393\n20.1 编程式事务管理 393\n20.1.1 直接使用PlatformTran-sactionManager进行编程式事务管理 393\n20.1.2 使用TransactionTemp-late进行编程式事务管理 394\n20.1.3 编程创建基于Savepoint的嵌套事务 396\n20.2 声明式事务管理 397\n20.2.1 引子 397\n20.2.2 XML元数据驱动的声明式事务 399\n20.2.3 注解元数据驱动的声明式事务 410\n20.3 小结 413\n第21章 Spring事务管理之扩展篇 414\n21.1 理解并活用ThreadLocal 414\n21.1.1 理解ThreadLocal的存在背景 414\n21.1.2 理解ThreadLocal的实现 415\n21.1.3 ThreadLocal的应用场景 416\n21.1.4 使用ThreadLocal管理多数据源切换的条件 417\n21.2 谈Strategy模式在开发过程中的应用 420\n21.3 Spring与JTA背后的奥秘 423\n21.4 小结 427\n第六部分 Spring的Web MVC框架\n第22章 迈向Spring MVC的旅程 430\n22.1 Servlet独行天下的时代 430\n22.2 繁盛一时的JSP时代 433\n22.3 Servlet与JSP的联盟 436\n22.4 数英雄人物，还看今朝 438\n22.5 小结 440\n第23章 Spring MVC初体验 441\n23.1 鸟瞰Spring MVC 442\n23.2 实践出真知 446\n23.2.1 Spring MVC应用的物理结构 447\n23.2.2 按部就班地开始工作 451\n23.3 小结 459\n第24章 近距离接触Spring MVC主要角色 460\n24.1 忙碌的协调人HandlerMapping 460\n24.1.1 可用的HandlerMapping 461\n24.1.2 HandlerMapping执行序列(Chain Of HandlerMapping) 463\n24.2 我们的亲密伙伴Controller 464\n24.2.1 AbstractController 465\n24.2.2 MultiActionController 468\n24.2.3 SimpleFormController 476\n24.2.4 AbstractWizard-FormController 496\n24.2.5 其他可用的Controller实现 503\n24.3 ModelAndView 505\n24.3.1 ModelAndView中的视图信息 505\n24.3.2 ModelAndView中的模型数据 506\n24.4 视图定位器ViewResolver 506\n24.4.1 可用的ViewResolver实现类 507\n24.4.2 ViewResolver查找序列(Chain Of ViewResolver) 511\n24.5 各司其职的View 511\n24.5.1 View实现原理回顾 512\n24.5.2 可用的View实现类 515\n24.5.3 自定义View实现 521\n24.6 小结 523\n第25章 认识更多Spring MVC家族成员 524\n25.1 文件上传与MultipartResolver 525\n25.1.1 使用MultipartResolver进行文件上传的简单分析 526\n25.1.2 文件上传实践 527\n25.2 Handler与HandlerAdaptor 530\n25.2.1 问题的起源 530\n25.2.2 深入了解Handler 531\n25.2.3 近看HandlerAdaptor的奥秘 533\n25.2.4 告知Handler与Handler-Adaptor的存在 535\n25.3 框架内处理流程拦截与Handler-Interceptor 536\n25.3.1 可用的Handler-Interceptor实现 537\n25.3.2 自定义实现Handler-Interceptor 538\n25.3.3 HandlerInterceptor寻根 540\n25.3.4 HandlerInterceptor之外的选择 541\n25.4 框架内的异常处理与Handler-ExceptionResolver 544\n25.5 国际化视图与LocalResolver 548\n25.5.1 可用的LocaleResolver 549\n25.5.2 LocaleResolver的足迹 550\n25.5.3 Locale的变更与LocaleChangeHandler 551\n25.6 主题(Theme)与ThemeResolver 552\n25.6.1 提供主题资源的ThemeSource 552\n25.6.2 管理主题的ThemeResolver 554\n25.6.3 切换主题的ThemeChange-Interceptor 555\n25.7 小结 556\n第26章 Spring MVC中基于注解的Controller 557\n26.1 初识基于注解的Controller 557\n26.2 基于注解的Controller原型分析 558\n26.2.1 自定义用于基于注解的Contro-ller的HandlerMapping 558\n26.2.2 自定义用于基于注解的Contro-ller的HandlerAdaptor 560\n26.3 近看基于注解的Controller 563\n26.3.1 声明基于注解的Controller 563\n26.3.2 请求参数到方法参数的绑定 569\n26.3.3 使用@ModelAttribute访问模型数据 572\n26.3.4 通过@SessionAttribute管理Session数据 574\n26.4 小结 576\n第27章 Spring MVC之扩展篇 577\n27.1 Spring MVC也Convention Over Configuration 577\n27.1.1 Convention Over Configuration简介 577\n27.1.2 Spring MVC中的Convention Over Configuration 578\n27.2 Spring 3.0展望 581\n27.3 小结 582\n第七部分 Spring框架对J2EE服务的集成和支持\n第28章 Spring框架内的JNDI支持 584\n28.1 JNDI简单回顾 584\n28.2 Spring框架内JNDI访问的基石——JndiTemplate 585\n28.3 JNDI对象的依赖注入——JndiObjectFactoryBean 587\n28.4 小结 588\n第29章 Spring框架对JMS的集成 589\n29.1 说说JMS的身世 589\n29.2 使用JMS API进行应用开发的传统套路 590\n29.3 Spring改进后的JMS实战格斗术 592\n29.3.1 消息发送和同步接收 592\n29.3.2 异步消息接收 601\n29.3.3 JMS相关异常处理 607\n29.3.4 框架内的事务管理支持 608\n29.4 小结 609\n第30章 使用Spring发送E-mail 610\n30.1 思甜前，先忆苦 610\n30.2 Spring的E-mail抽象层分析 612\n30.2.1 直接创建邮件消息并发送 614\n30.2.2 使用MimeMessage-Preparator发送邮件 615\n30.3 Spring的E-mail支持在实际开发中的应用 616\n30.4 小结 622\n第31章 Spring中的任务调度和线程池支持 623\n31.1 Spring与Quartz 623\n31.1.1 初识Quartz 623\n31.1.2 融入Spring大家庭的Quartz 626\n31.2 Spring对JDK Timer的集成 631\n31.2.1 JDK Timer小记 631\n31.2.2 Spring集成后的JDK Timer 632\n31.3 Executor的孪生兄弟TaskExecutor 634\n31.3.1 可用的TaskExecutor 635\n31.3.2 TaskExecutor使用实例 637\n31.4 小结 639\n第32章 Spring框架对J2EE服务的集成之扩展篇 640\n32.1 MailMonitor的延伸 640\n32.2 Spring 3.0展望 642\n32.3 小结 642\n第33章 Spring远程方案 643\n33.1 从“对面交谈”到“千里传声” 643\n33.2 Spring Remoting架构分析 645\n33.2.1 Spring Remoting之远程访问异常体系 645\n33.2.2 统一风格的远程服务公开与访问方式 646\n33.3 Spring Remoting提供的远程服务支持 648\n33.3.1 基于RMI的Remoting方案 648\n33.3.2 基于HTTP的轻量级Remoting方案 651\n33.3.3 基于Web服务的远程方案 655\n33.3.4 基于JMS的远程方案 658\n33.4 扩展Spring Remoting 660\n33.5 Spring Remoting之扩展篇 663\n33.5.1 拉开JMX演出的序幕 663\n33.5.2 Spring 3.0展望 664\n参考文献 665",
    "pages": "680",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s3949449.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s3949449.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s3949449.jpg"
    },
    "alt": "https://book.douban.com/subject/3897837/",
    "id": "3897837",
    "publisher": "人民邮电出版社",
    "isbn10": "7115209421",
    "isbn13": "9787115209429",
    "title": "Spring揭秘",
    "url": "https://api.douban.com/v2/book/3897837",
    "alt_title": "",
    "author_intro": "王福强，资深软件开发专家和系统架构师，原任花旗软件（大连）资深软件工程师，现任阿里巴巴B2B平台技术部架构师。多年来一直专注于Java平台的技术发展，以及一线产品的技术选型和框架设计。拥有多年金融行业软件开发经历，负责过信贷、外汇交易、固定收益等金融系统的分析、设计、开发、维护、集成、扩展和性能调优等，对各种大型金融机构体系的技术架构和实现有丰富经验和独到的见解。作为国内最早使用Spring的开发者之一,他对Spring的使用、设计和实现原理有着非常深入的了解。在本书中，他与读者分享了多年的Spring开发经验和探索企业级解决方案的心得。",
    "summary": "没有教程似的训导，更多的是说故事般的娓娓道来，本书是作者在多年的工作中积累的第一手Spring框架使用经验的总结，深入剖析了Spring框架各个模块的功能、出现的背景、设计理念和设计原理，揭开了Spring框架的神秘面纱，使你“知其然，更知其所以然”。每部分的扩展篇帮助读者活学活用Spring框架的方方面面，同时可以触类旁通，衍生出新的思路和解决方案。\n本书内容全面，论述深刻入理，必将成为每个Java专业开发人员必备的Spring图书。",
    "price": "99.00元"
  },
  "9787121273049": {
    "rating": { "max": 10, "numRaters": 164, "average": "8.3", "min": 0 },
    "subtitle": "",
    "author": ["葛一鸣", "郭超"],
    "pubdate": "2015-10-1",
    "tags": [
      { "count": 214, "name": "Java", "title": "Java" },
      { "count": 182, "name": "并发编程", "title": "并发编程" },
      { "count": 111, "name": "并发", "title": "并发" },
      { "count": 56, "name": "java", "title": "java" },
      { "count": 47, "name": "编程", "title": "编程" },
      { "count": 36, "name": "计算机", "title": "计算机" },
      { "count": 28, "name": "软件开发", "title": "软件开发" },
      { "count": 27, "name": "Java并发实战", "title": "Java并发实战" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29405037.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章　走入并行世界\t1\n1.1　何去何从的并行计算 \t1\n1.1.1　忘掉那该死的并行\t2\n1.1.2　可怕的现实：摩尔定律的失效\t4\n1.1.3　柳暗花明：不断地前进\t5\n1.1.4　光明或是黑暗\t6\n1.2　你必须知道的几个概念\t6\n1.2.1　同步（Synchronous）和异步（Asynchronous）\t7\n1.2.2　并发（Concurrency）和并行（Parallelism）\t8\n1.2.3　临界区\t9\n1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）\t9\n1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）\t9\n1.3　并发级别\t11\n1.3.1　阻塞（Blocking）\t11\n1.3.2　无饥饿（Starvation-Free）\t11\n1.3.3　无障碍（Obstruction-Free）\t12\n1.3.4　无锁（Lock-Free）\t12\n1.3.5　无等待（Wait-Free）\t13\n1.4　有关并行的两个重要定律\t13\n1.4.1　Amdahl定律\t13\n1.4.2　Gustafson定律\t16\n1.4.3　Amdahl定律和Gustafson定律是否相互矛盾\t16\n1.5　回到Java：JMM\t17\n1.5.1　原子性（Atomicity）\t18\n1.5.2　可见性（Visibility）\t20\n1.5.3　有序性（Ordering）\t22\n1.5.4　哪些指令不能重排：Happen-Before规则\t27\n1.6　参考文献\t27\n第2章　Java并行程序基础\t29\n2.1　有关线程你必须知道的事\t29\n2.2　初始线程：线程的基本操作\t32\n2.2.1　新建线程\t32\n2.2.2　终止线程\t34\n2.2.3　线程中断\t38\n2.2.4　等待（wait）和通知（notify）\t41\n2.2.5　挂起（suspend）和继续执行（resume）线程\t44\n2.2.6　等待线程结束（join）和谦让（yield）\t48\n2.3　volatile与Java内存模型（JMM）\t50\n2.4　分门别类的管理：线程组\t52\n2.5　驻守后台：守护线程（Daemon）\t54\n2.6　先干重要的事：线程优先级\t55\n2.7　线程安全的概念与synchronized\t57\n2.8　程序中的幽灵：隐蔽的错误\t61\n2.8.1　无提示的错误案例\t61\n2.8.2　并发下的ArrayList\t62\n2.8.3　并发下诡异的HashMap\t63\n2.8.4　初学者常见问题：错误的加锁\t66\n2.9　参考文献\t68\n第3章　JDK并发包\t70\n3.1　多线程的团队协作：同步控制\t70\n3.1.1　synchronized的功能扩展：重入锁\t71\n3.1.2　重入锁的好搭档：Condition条件\t80\n3.1.3　允许多个线程同时访问：信号量（Semaphore）\t83\n3.1.4　ReadWriteLock读写锁\t85\n3.1.5　倒计时器：CountDownLatch\t87\n3.1.6　循环栅栏：CyclicBarrier\t89\n3.1.7　线程阻塞工具类：LockSupport\t92\n3.2　线程复用：线程池\t95\n3.2.1　什么是线程池\t96\n3.2.2　不要重复发明轮子：JDK对线程池的支持\t97\n3.2.3　刨根究底：核心线程池的内部实现\t102\n3.2.4　超负载了怎么办：拒绝策略\t106\n3.2.5　自定义线程创建：ThreadFactory\t109\n3.2.6　我的应用我做主：扩展线程池\t110\n3.2.7　合理的选择：优化线程池线程数量\t112\n3.2.8　堆栈去哪里了：在线程池中寻找堆栈\t113\n3.2.9　分而治之：Fork/Join框架\t117\n3.3　不要重复发明轮子：JDK的并发容器\t121\n3.3.1　超好用的工具类：并发集合简介\t121\n3.3.2　线程安全的HashMap\t122\n3.3.3　有关List的线程安全\t123\n3.3.4　高效读写的队列：深度剖析ConcurrentLinkedQueue\t123\n3.3.5　高效读取：不变模式下的CopyOnWriteArrayList\t129\n3.3.6　数据共享通道：BlockingQueue\t130\n3.3.7　随机数据结构：跳表（SkipList）\t134\n3.4　参考资料\t136\n第4章　锁的优化及注意事项\t138\n4.1　有助于提高“锁”性能的几点建议\t139\n4.1.1　减小锁持有时间\t139\n4.1.2　减小锁粒度\t140\n4.1.3　读写分离锁来替换独占锁\t142\n4.1.4　锁分离\t142\n4.1.5　锁粗化\t144\n4.2　Java虚拟机对锁优化所做的努力\t146\n4.2.1　锁偏向\t146\n4.2.2　轻量级锁\t146\n4.2.3　自旋锁\t146\n4.2.4　锁消除\t146\n4.3　人手一支笔：ThreadLocal\t147\n4.3.1　ThreadLocal的简单使用\t148\n4.3.2　ThreadLocal的实现原理\t149\n4.3.3　对性能有何帮助\t155\n4.4　无锁\t157\n4.4.1　与众不同的并发策略：比较交换（CAS）\t158\n4.4.2　无锁的线程安全整数：AtomicInteger\t159\n4.4.3　Java中的指针：Unsafe类\t161\n4.4.4　无锁的对象引用：AtomicReference\t162\n4.4.5　带有时间戳的对象引用：AtomicStampedReference\t165\n4.4.6　数组也能无锁：AtomicIntegerArray\t168\n4.4.7　让普通变量也享受原子操作：AtomicIntegerFieldUpdater\t169\n4.4.8　挑战无锁算法：无锁的Vector实现\t171\n4.4.9　让线程之间互相帮助：细看SynchronousQueue的实现\t176\n4.5　有关死锁的问题\t179\n4.6　参考文献\t183\n第5章　并行模式与算法\t184\n5.1　探讨单例模式\t184\n5.2　不变模式\t187\n5.3　生产者-消费者模式\t190\n5.4　高性能的生产者-消费者：无锁的实现\t194\n5.4.1　无锁的缓存框架：Disruptor\t195\n5.4.2　用Disruptor实现生产者-消费者案例\t196\n5.4.3　提高消费者的响应时间：选择合适的策略\t199\n5.4.4　CPU Cache的优化：解决伪共享问题\t200\n5.5　Future模式\t204\n5.5.1　Future模式的主要角色\t206\n5.5.2　Future模式的简单实现\t207\n5.5.3　JDK中的Future模式\t210\n5.6　并行流水线\t212\n5.7　并行搜索\t216\n5.8　并行排序\t218\n5.8.1　分离数据相关性：奇偶交换排序\t218\n5.8.2　改进的插入排序：希尔排序\t221\n5.9　并行算法：矩阵乘法\t226\n5.10　准备好了再通知我：网络NIO\t230\n5.10.1　基于Socket的服务端的多线程模式\t230\n5.10.2　使用NIO进行网络编程\t235\n5.10.3　使用NIO来实现客户端\t243\n5.11　读完了再通知我：AIO\t245\n5.11.1　AIO EchoServer的实现\t245\n5.11.2　AIO Echo客户端实现\t248\n5.12　参考文献\t249\n第6章　Java 8与并发\t251\n6.1　Java 8的函数式编程简介\t251\n6.1.1　函数作为一等公民\t252\n6.1.2　无副作用\t252\n6.1.3　申明式的（Declarative）\t253\n6.1.4　不变的对象\t254\n6.1.5　易于并行\t254\n6.1.6　更少的代码\t254\n6.2　函数式编程基础\t255\n6.2.1　FunctionalInterface注释\t255\n6.2.2　接口默认方法\t256\n6.2.3　lambda表达式\t259\n6.2.4　方法引用\t260\n6.3　一步一步走入函数式编程\t263\n6.4　并行流与并行排序\t267\n6.4.1　使用并行流过滤数据\t267\n6.4.2　从集合得到并行流\t268\n6.4.3　并行排序\t268\n6.5　增强的Future：CompletableFuture\t269\n6.5.1　完成了就通知我\t269\n6.5.2　异步执行任务\t270\n6.5.3　流式调用\t272\n6.5.4　CompletableFuture中的异常处理\t272\n6.5.5　组合多个CompletableFuture\t273\n6.6　读写锁的改进：StampedLock\t274\n6.6.1　StampedLock使用示例\t275\n6.6.2　StampedLock的小陷阱\t276\n6.6.3　有关StampedLock的实现思想\t278\n6.7　原子类的增强\t281\n6.7.1　更快的原子类：LongAdder\t281\n6.7.2　LongAdder的功能增强版：LongAccumulator\t287\n6.8　参考文献\t288\n第7章　使用Akka构建高并发程序\t289\n7.1　新并发模型：Actor\t290\n7.2　Akka之Hello World\t290\n7.3　有关消息投递的一些说明\t293\n7.4　Actor的生命周期\t295\n7.5　监督策略\t298\n7.6　选择Actor\t303\n7.7　消息收件箱（Inbox）\t303\n7.8　消息路由\t305\n7.9　Actor的内置状态转换\t308\n7.10　询问模式：Actor中的Future\t311\n7.11　多个Actor同时修改数据：Agent\t313\n7.12　像数据库一样操作内存数据：软件事务内存\t316\n7.13　一个有趣的例子：并发粒子群的实现\t319\n7.13.1　什么是粒子群算法\t320\n7.13.2　粒子群算法的计算过程\t320\n7.13.3　粒子群算法能做什么\t322\n7.13.4　使用Akka实现粒子群\t323\n7.14　参考文献\t330\n第8章　并行程序调试\t331\n8.1　准备实验样本\t331\n8.2　正式起航\t332\n8.3　挂起整个虚拟机\t334\n8.4　调试进入ArrayList内部\t336",
    "pages": "339",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29405037.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29405037.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29405037.jpg"
    },
    "alt": "https://book.douban.com/subject/26663605/",
    "id": "26663605",
    "publisher": "电子工业出版社",
    "isbn10": "7121273047",
    "isbn13": "9787121273049",
    "title": "实战Java高并发程序设计",
    "url": "https://api.douban.com/v2/book/26663605",
    "alt_title": "",
    "author_intro": "葛一鸣，51CTO特约讲师，国家认证系统分析师，获得OracleOCP认证。长期从事Java软件开发工作，对Java程序设计、JVM有深入的研究，对设计模式、人工智能、神经网络、数据挖掘等技术有浓厚兴趣，著有《自己动手写神经网路》电子书和《实战Java虚拟机》一书。\n郭超，就职于杭州市道路运输管理局信息中心，主要从事大型交通管理系统的分布式管理和并发模型设计，对Java的研究比较深入，专注于分布式应用和并发应用。",
    "summary": "在过去单核CPU时代，单任务在一个时间点只能执行单一程序，随着多核CPU的发展，并行程序开发就显得尤为重要。\n《实战Java高并发程序设计》主要介绍基于Java的并行程序设计基础、思路、方法和实战。第一，立足于并发程序基础，详细介绍Java中进行并行程序设计的基本方法。第二，进一步详细介绍JDK中对并行程序的强大支持，帮助读者快速、稳健地进行并行程序开发。第三，详细讨论有关“锁”的优化和提高并行程序性能级别的方法和思路。第四，介绍并行的基本设计模式及Java 8对并行程序的支持和改进。第五，介绍高并发框架Akka的使用方法。最后，详细介绍并行程序的调试方法。\n《实战Java高并发程序设计》内容丰富，实例典型，实用性强，适合有一定Java基础的技术开发人员阅读。",
    "price": "CNY 69.00"
  },
  "9787111421900": {
    "rating": { "max": 10, "numRaters": 1181, "average": "8.9", "min": 0 },
    "subtitle": "JVM高级特性与最佳实践",
    "author": ["周志明"],
    "pubdate": "2013-9-1",
    "tags": [
      { "count": 1017, "name": "JVM", "title": "JVM" },
      { "count": 889, "name": "Java", "title": "Java" },
      { "count": 655, "name": "虚拟机", "title": "虚拟机" },
      { "count": 279, "name": "java", "title": "java" },
      { "count": 278, "name": "计算机", "title": "计算机" },
      { "count": 221, "name": "编程", "title": "编程" },
      { "count": 122, "name": "软件开发", "title": "软件开发" },
      { "count": 94, "name": "程序设计", "title": "程序设计" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27458236.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "前言\n第一部分走近Java\n第1章走近Java2\n1.1概述2\n1.2Java技术体系3\n1.3Java发展史5\n1.4Java虚拟机发展史9\n1.4.1SunClassicExactVM9\n1.4.2SunHotSpotVM11\n1.4.3SunMobile—EmbeddedVMMeta—CircularVM12\n1.4.4BEAJRockitIBMJ9VM13\n1.4.5AzulVMBEALiquidVM14\n1.4.6ApacheHarmonyGoogleAndroidDalvikVM14\n1.4.7MicrosoftJVM及其他15\n1.5展望Java技术的未来16\n1.5.1模块化17\n1.5.2混合语言17\n1.5.3多核并行19\n1.5.4进一步丰富语法20\n1.5.564位虚拟机21\n1.6实战：自己编译JDK22\n1.6.1获取JDK源码22\n1.6.2系统需求24\n1.6.3构建编译环境25\n1.6.4进行编译26\n1.6.5在IDE工具中进行源码调试31\n1.7本章小结35\n第二部分自动内存管理机制\n第2章Java内存区域与内存溢出异常38\n2.1概述38\n2.2运行时数据区域38\n2.2.1程序计数器39\n2.2.2Java虚拟机栈39\n2.2.3本地方法栈40\n2.2.4Java堆41\n2.2.5方法区41\n2.2.6运行时常量池42\n2.2.7直接内存43\n2.3HotSpot虚拟机对象探秘43\n2.3.1对象的创建44\n2.3.2对象的内存布局47\n2.3.3对象的访问定位48\n2.4实战：OutOfMemoryError异常50\n2.4.1Java堆溢出51\n2.4.2虚拟机栈和本地方法栈溢出53\n2.4.3方法区和运行时常量池溢出56\n2.4.4本机直接内存溢出59\n2.5本章小结60\n第3章垃圾收集器与内存分配策略61\n3.1概述61\n3.2对象已死吗62\n3.2.1引用计数算法62\n3.2.2可达性分析算法64\n3.2.3再谈引用65\n3.2.4生存还是死亡66\n3.2.5回收方法区68\n3.3垃圾收集算法69\n3.3.1标记—清除算法69\n3.3.2复制算法70\n3.3.3标记—整理算法71\n3.3.4分代收集算法72\n3.4HotSpot的算法实现72\n3.4.1枚举根节点72\n3.4.2安全点73\n3.4.3安全区域74\n3.5垃圾收集器75\n3.5.1Serial收集器76\n3.5.2ParNew收集器77\n3.5.3ParallelScavenge收集器79\n3.5.4SerialOld收集器80\n3.5.5ParallelOld收集器80\n3.5.6CMS收集器81\n3.5.7G1收集器84\n3.5.8理解GC日志89\n3.5.9垃圾收集器参数总结90\n3.6内存分配与回收策略91\n3.6.1对象优先在Eden分配91\n3.6.2大对象直接进入老年代93\n3.6.3长期存活的对象将进入老年代95\n3.6.4动态对象年龄判定97\n3.6.5空间分配担保98\n3.7本章小结100\n第4章虚拟机性能监控与故障处理工具101\n4.1概述101\n4.2JDK的命令行工具101\n4.2.1jps：虚拟机进程状况工具104\n4.2.2jstat：虚拟机统计信息监视工具105\n4.2.3jinfo：Java配置信息工具106\n4.2.4jmap：Java内存映像工具107\n4.2.5jhat：虚拟机堆转储快照分析工具108\n4.2.6jstack：Java堆栈跟踪工具109\n4.2.7HSDIS：JIT生成代码反汇编111\n4.3JDK的可视化工具114\n4.3.1JConsole：Java监视与管理控制台115\n4.3.2VisualVM：多合一故障处理工具122\n4.4本章小结131\n第5章调优案例分析与实战132\n5.1概述132\n5.2案例分析132\n5.2.1高性能硬件上的程序部署策略132\n5.2.2集群间同步导致的内存溢出135\n5.2.3堆外内存导致的溢出错误136\n5.2.4外部命令导致系统缓慢137\n5.2.5服务器JVM进程崩溃138\n5.2.6不恰当数据结构导致内存占用过大139\n5.2.7由Windows虚拟内存导致的长时间停顿141\n5.3实战：Eclipse运行速度调优142\n5.3.1调优前的程序运行状态142\n5.3.2升级JDK1.6的性能变化及兼容问题145\n5.3.3编译时间和类加载时间的优化150\n5.3.4调整内存设置控制垃圾收集频率153\n5.3.5选择收集器降低延迟157\n5.4本章小结160\n第三部分虚拟机执行子系统\n第6章类文件结构162\n6.1概述162\n6.2无关性的基石162\n6.3Class类文件的结构164\n6.3.1魔数与Class文件的版本166\n6.3.2常量池167\n6.3.3访问标志173\n6.3.4类索引、父类索引与接口索引集合174\n6.3.5字段表集合175\n6.3.6方法表集合178\n6.3.7属性表集合180\n6.4字节码指令简介196\n6.4.1字节码与数据类型197\n6.4.2加载和存储指令199\n6.4.3运算指令200\n6.4.4类型转换指令202\n6.4.5对象创建与访问指令203\n6.4.6操作数栈管理指令203\n6.4.7控制转移指令204\n6.4.8方法调用和返回指令204\n6.4.9异常处理指令205\n6.4.10同步指令205\n6.5公有设计和私有实现206\n6.6Class文件结构的发展207\n6.7本章小结208\n第7章虚拟机类加载机制209\n7.1概述209\n7.2类加载的时机210\n7.3类加载的过程214\n7.3.1加载214\n7.3.2验证216\n7.3.3准备219\n7.3.4解析220\n7.3.5初始化225\n7.4类加载器227\n7.4.1类与类加载器228\n7.4.2双亲委派模型229\n7.4.3破坏双亲委派模型233\n7.5本章小结235\n第8章虚拟机字节码执行引擎236\n8.1概述236\n8.2运行时栈帧结构236\n8.2.1局部变量表238\n8.2.2操作数栈242\n8.2.3动态连接243\n8.2.4方法返回地址243\n8.2.5附加信息244\n8.3方法调用244\n8.3.1解析244\n8.3.2分派246\n8.3.3动态类型语言支持258\n8.4基于栈的字节码解释执行引擎269\n8.4.1解释执行269\n8.4.2基于栈的指令集与基于寄存器的指令集270\n8.4.3基于栈的解释器执行过程272\n8.5本章小结275\n第9章类加载及执行子系统的案例与实战276\n9.1概述276\n9.2案例分析276\n9.2.1Tomcat：正统的类加载器架构276\n9.2.2OSGi：灵活的类加载器架构279\n9.2.3字节码生成技术与动态代理的实现282\n9.2.4Retrotranslator：跨越JDK版本286\n9.3实战：自己动手实现远程执行功能289\n9.3.1目标290\n9.3.2思路290\n9.3.3实现291\n9.3.4验证298\n9.4本章小结299\n第四部分程序编译与代码优化\n第10章早期（编译期）优化302\n10.1概述302\n10.2Javac编译器303\n10.2.1Javac的源码与调试303\n10.2.2解析与填充符号表305\n10.2.3注解处理器307\n10.2.4语义分析与字节码生成307\n10.3Java语法糖的味道311\n10.3.1泛型与类型擦除311\n10.3.2自动装箱、拆箱与遍历循环315\n10.3.3条件编译317\n10.4实战：插入式注解处理器318\n10.4.1实战目标318\n10.4.2代码实现319\n10.4.3运行与测试326\n10.4.4其他应用案例327\n10.5本章小结328\n第11章晚期（运行期）优化329\n11.1概述329\n11.2HotSpot虚拟机内的即时编译器329\n11.2.1解释器与编译器330\n11.2.2编译对象与触发条件332\n11.2.3编译过程337\n11.2.4查看及分析即时编译结果339\n11.3编译优化技术345\n11.3.1优化技术概览346\n11.3.2公共子表达式消除350\n11.3.3数组边界检查消除351\n11.3.4方法内联352\n11.3.5逃逸分析354\n11.4Java与C/C++的编译器对比356\n11.5本章小结358\n第五部分高效并发\n第12章Java内存模型与线程360\n12.1概述360\n12.2硬件的效率与一致性361\n12.3Java内存模型362\n12.3.1主内存与工作内存363\n12.3.2内存间交互操作364\n12.3.3对于volatile型变量的特殊规则366\n12.3.4对于long和double型变量的特殊规则372\n12.3.5原子性、可见性与有序性373\n12.3.6先行发生原则375\n12.4Java与线程378\n12.4.1线程的实现378\n12.4.2Java线程调度381\n12.4.3状态转换383\n12.5本章小结384\n第13章线程安全与锁优化385\n13.1概述385\n13.2线程安全385\n13.2.1Java语言中的线程安全386\n13.2.2线程安全的实现方法390\n13.3锁优化397\n13.3.1自旋锁与自适应自旋398\n13.3.2锁消除398\n13.3.3锁粗化400\n13.3.4轻量级锁400\n13.3.5偏向锁402\n13.4本章小结403\n附录\n附录A编译Windows版的OpenJDK406\n附录B虚拟机字节码指令表414\n附录CHotSpot虚拟机主要参数表420\n附录D对象查询语言（OQL）简介424\n附录EJDK历史版本轨迹430",
    "ebook_url": "https://read.douban.com/ebook/15233695/",
    "pages": "433",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27458236.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27458236.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27458236.jpg"
    },
    "alt": "https://book.douban.com/subject/24722612/",
    "id": "24722612",
    "publisher": "机械工业出版社",
    "isbn10": "7111421906",
    "isbn13": "9787111421900",
    "title": "深入理解Java虚拟机（第2版）",
    "url": "https://api.douban.com/v2/book/24722612",
    "alt_title": "",
    "author_intro": "周志明，资深Java技术专家，对JavaEE企业级应用开发、OSGi、Java虚拟机和工作流等都有深入的研究，并在大量的实践中积累了丰富的经验。尤其精通Java虚拟机，撰写了大量与JVM相关的经典文章，被各大技术社区争相转载，是ITeye等技术社区公认的Java虚拟机方面的领袖人物之一。除本书外，还著有经典著作《深入理解OSGi：Equinox原理、应用与最佳实践》，广获读者好评。现任远光软件股份有限公司开发部总经理兼架构师，先后参与过国家电网、南方电网等多个国家级大型ERP项目的平台架构工作，对软件系统架构也有深刻的认识和体会。",
    "summary": "《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》内容简介：第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个Java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很大的改进：根据最新的JDK 1.7对全书内容进行了全面的升级和补充；增加了大量处理各种常见JVM问题的技巧和最佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。\n《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。\n第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解书中后面内容有重要帮助。\n第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。\n第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。\n第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；\n第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。",
    "ebook_price": "25.00",
    "series": { "id": "43708", "title": "华章原创精品" },
    "price": "79.00元"
  },
  "9787121022982": {
    "rating": { "max": 10, "numRaters": 3595, "average": "9.3", "min": 0 },
    "subtitle": "",
    "author": ["[美] 史蒂夫·迈克康奈尔"],
    "pubdate": "2006-3",
    "tags": [
      { "count": 3211, "name": "编程", "title": "编程" },
      { "count": 2922, "name": "代码大全", "title": "代码大全" },
      { "count": 1666, "name": "软件开发", "title": "软件开发" },
      { "count": 1521, "name": "计算机", "title": "计算机" },
      { "count": 1463, "name": "软件工程", "title": "软件工程" },
      { "count": 1210, "name": "程序设计", "title": "程序设计" },
      { "count": 840, "name": "programming", "title": "programming" },
      { "count": 801, "name": "代码", "title": "代码" }
    ],
    "origin_title": "Code Complete",
    "image": "https://img1.doubanio.com/view/subject/m/public/s1495029.jpg",
    "binding": "平装",
    "translator": ["金戈", "汤凌", "陈硕", "张菲 译", "裘宗燕 审校"],
    "catalog": "第 1 章    欢迎进入软件构建的世界　　3\n第 2 章    用隐喻来更充分地理解软件开发　　9\n第 3 章    三思而后行：前期准备　　23\n第 4 章    关键的“构建”决策　　61\n第 5 章    软件构建中的设计　　73\n第 6 章    可以工作的类　　125\n第 7 章    高质量的子程序　　161\n第 8 章    防御式编程　　187\n第 9 章    伪代码编程过程　　215\n第 10 章    使用变量的一般事项　　237\n第 11 章    变量名的力量　　259\n第 12 章    基本数据类型　　291\n第 13 章    不常见的数据类型　　319\n第 14 章    组织直线型代码　　347\n第 15 章    使用条件语句　　355\n第 16 章    控制循环　　367\n第 17 章    不常见的控制结构　　391\n第 18 章    表驱动法　　411\n第 19 章    一般控制问题　　431\n第 20 章    软件质量概述　　463\n第 21 章    协同构建　　479\n第 22 章    开发者测试　　499\n第 23 章    调试　　535\n第 24 章    重构　　563\n第 25 章    代码调整策略　　587\n第 26 章    代码调整技术　　609\n第 27 章    程序规模对构建的影响　　649\n第 28 章    管理构建　　661\n第 29 章    集成　　689\n第 30 章    编程工具　　709\n第 31 章    布局与风格　　729\n第 32 章    自说明代码　　777\n第 33 章    个人性格　　819\n第 34 章    软件工艺的话题　　837\n第 35 章    何处有更多信息　　855\n参考文献  　　863\n索引  883",
    "pages": "944",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s1495029.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s1495029.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s1495029.jpg"
    },
    "alt": "https://book.douban.com/subject/1477390/",
    "id": "1477390",
    "publisher": "电子工业出版社",
    "isbn10": "7121022982",
    "isbn13": "9787121022982",
    "title": "代码大全（第2版）",
    "url": "https://api.douban.com/v2/book/1477390",
    "alt_title": "Code Complete",
    "author_intro": "史蒂夫·迈克康奈尔（Steve McConnell）被公认为软件开发社区中的首要作者和发言人之一。他是Construx Software公司的首席软件工程师。他所编著的图书包括曾被《软件开发》杂志授予优异产品震撼大奖的《代码大全》和《快速软件开发》，以及《软件项目生存指南》和《专业软件开发》等等。",
    "summary": "第2版的《代码大全》是著名IT畅销书作者史蒂夫·迈克康奈尔11年前的经典著作的全新演绎：第2版不是第一版的简单修订增补，而是完全进行了重写；增加了很多与时俱进的内容。这也是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。",
    "series": { "id": "6628", "title": "传世经典书丛" },
    "price": "128.00元"
  },
  "9787115470669": {
    "rating": { "max": 10, "numRaters": 128, "average": "7.8", "min": 0 },
    "subtitle": "",
    "author": ["张鑫旭"],
    "pubdate": "2017-12",
    "tags": [
      { "count": 113, "name": "CSS", "title": "CSS" },
      { "count": 86, "name": "前端", "title": "前端" },
      { "count": 25, "name": "前端开发", "title": "前端开发" },
      { "count": 17, "name": "css", "title": "css" },
      { "count": 17, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 15, "name": "编程", "title": "编程" },
      { "count": 9, "name": "计算机", "title": "计算机" },
      { "count": 9, "name": "入门好书", "title": "入门好书" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29651678.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第 1章　概述 1\n1．1 CSS世界的“世界观” 1\n1．2 世界都是创造出来的 3\n1．3 CSS完胜SVG的武器—流 4\n1．3．1 何为“流” 5\n1．3．2　流是如何影响整个CSS世界的 6\n1．3．3 什么是流体布局 6\n1．4 CSS世界的开启从IE8开始 6\n1．5 table自己的世界 7\n1．6 CSS新世界—CSS3 7\n第 2章　需提前了解的术语和概念 8\n2．1 务必了解的CSS世界的专业术语 8\n2．2 了解CSS世界中的“未定义行为” 11\n第3章　流、元素与基本尺寸 13\n3．1 块级元素 13\n3．1．1 为什么list-item元素会出现项目符号 15\n3．1．2 display：inline-table的盒子是怎样组成的 16\n3．1．3 width/height作用在哪个盒子上 16\n3．2 width/height作用的具体细节 16\n3．2．1 深藏不露的width：auto 17\n3．2．2 width值作用的细节 24\n3．2．3 CSS流体布局下的宽度分离原则 27\n3．2．4 改变width/height作用细节的box-sizing 29\n3．2．5 相对简单而单纯的height：auto 33\n3．2．6 关于height：100% 33\n3．3 CSS min-width/max-width和min-height/max-height二三事 37\n3．3．1 为流体而生的min-width/max-width 38\n3．3．2 与众不同的初始值 38\n3．3．3 超越!important 39\n3．3．4 任意高度元素的展开收起动画技术 40\n3．4 内联元素 42\n3．4．1 哪些元素是内联元素 42\n3．4．2 内联世界深入的基础—内联盒模型 42\n3．4．3 幽灵空白节点 44\n第4章　盒尺寸四大家族 45\n4．1 深入理解content 45\n4．1．1 content与替换元素 45\n4．1．2 content内容生成技术 57\n4．2 温和的padding属性 73\n4．2．1 padding与元素的尺寸 73\n4．2．2 padding的百分比值 77\n4．2．3 标签元素内置的padding 79\n4．2．4 padding与图形绘制 80\n4．3 激进的margin属性 81\n4．3．1 margin与元素尺寸以及相关布局 82\n4．3．2 margin的百分比值 87\n4．3．3 正确看待CSS世界里的margin合并 87\n4．3．4 深入理解CSS中的margin：auto 94\n4．3．5 margin无效情形解析 97\n4．4 border属性 100\n4．4．1 为什么border-width不支持百分比值 100\n4．4．2 了解各种border-style类型 101\n4．4．3 border-color和color 105\n4．4．4 border与透明边框技巧 106\n4．4．5 border与图形构建 108\n4．4．6 border等高布局技术 109\n第5章　内联元素与流 111\n5．1 字母x—CSS世界中隐匿的举足轻重的角色 111\n5．1．1 字母x与CSS世界的基线 111\n5．1．2 字母x与CSS中的x-height 112\n5．1．3 字母x与CSS中的ex 113\n5．2 内联元素的基石line-height 114\n5．2．1 内联元素的高度之本—line-height 114\n5．2．2 为什么line-height可以让内联元素“垂直居中” 119\n5．2．3 深入line-height的各类属性值 121\n5．2．4 内联元素line-height的“大值特性” 124\n5．3 line-height的好朋友vertical-align 126\n5．3．1 vertical-align家族基本认识 127\n5．3．2 vertical-align作用的前提 129\n5．3．3 vertical-align和line-height之间的关系 131\n5．3．4 深入理解vertical-align线性类属性值 135\n5．3．5 深入理解vertical-align文本类属性值 141\n5．3．6 简单了解vertical-align上标下标类属性值 142\n5．3．7 无处不在的vertical-align 143\n5．3．8 基于vertical-align属性的水平垂直居中弹框 144\n第6章　流的破坏与保护 147\n6．1 魔鬼属性float 147\n6．1．1 float的本质与特性 147\n6．1．2 float的作用机制 151\n6．1．3 float更深入的作用机制 154\n6．1．4 float与流体布局 155\n6．2 float的天然克星clear 157\n6．2．1 什么是clear属性 157\n6．2．2 成事不足败事有余的clear 158\n6．3 CSS世界的结界—BFC 160\n6．3．1 BFC的定义 160\n6．3．2 BFC与流体布局 160\n6．4 结界overflow 164\n6．4．1 overflow剪裁界线border box 165\n6．4．2 了解overflow-x和overflow-y 166\n6．4．3 overflow与滚动条 166\n6．4．4 依赖overflow的样式表现 169\n6．4．5 overflow与锚点定位 170\n6．5 float的兄弟position：absolute 177\n6．5．1 absolute的包含块 178\n6．5．2 具有相对特性的无依赖absolute定位 184\n6．5．3 absolute与text-align 191\n6．6 absolute与overflow 193\n6．7 absolute与clip 195\n6．7．1 重新认识的clip属性 196\n6．7．2 深入了解clip的渲染 198\n6．8 absolute的流体特性 199\n6．8．1 当absolute遇到left/top/right/bottom属性 199\n6．8．2 absolute的流体特性 200\n6．8．3 absolute的margin：auto居中 202\n6．9 position：relative才是大哥 202\n6．9．1 relative对absolute的限制 203\n6．9．2 relative与定位 203\n6．9．3 relative的zui小化影响原则 206\n6．10 强悍的position：fixed固定定位 207\n6．10．1 position：fixed不一样的“包含块” 207\n6．10．2 position：fixed的absolute模拟 208\n6．10．3 position：fixed与背景锁定 209\n第7章　CSS世界的层叠规则 211\n7．1 z-index只是CSS层叠规则中的一叶小舟 211\n7．2 理解CSS世界的层叠上下文和层叠水平 212\n7．2．1 什么是层叠上下文 212\n7．2．2 什么是层叠水平 212\n7．3 理解元素的层叠顺序 212\n7．4 务必牢记的层叠准则 214\n7．5 深入了解层叠上下文 214\n7．5．1 层叠上下文的特性 214\n7．5．2 层叠上下文的创建 214\n7．5．3 层叠上下文与层叠顺序 217\n7．6 z-index负值深入理解 219\n7．7 z-index“不犯二”准则 223\n第8章　强大的文本处理能力 225\n8．1 line-height的另外一个朋友font-size 225\n8．1．1 font-size和vertical-align的隐秘故事 225\n8．1．2 理解font-size与ex、em和rem的关系 227\n8．1．3 理解font-size的关键字属性值 229\n8．1．4 font-size：0与文本的隐藏 231\n8．2 字体属性家族的大家长font-family 232\n8．2．1 了解衬线字体和无衬线字体 233\n8．2．2 等宽字体的实践价值 234\n8．2．3 中文字体和英文名称 236\n8．2．4 一些补充说明 237\n8．3 字体家族其他成员 238\n8．3．1 貌似粗犷、实则精细无比的font-weight 238\n8．3．2 具有近似姐妹花属性值的font-style 241\n8．3．3 不适合国情的font-variant 242\n8．4 font属性 242\n8．4．1 作为缩写的font属性 242\n8．4．2 使用关键字值的font属性 243\n8．4．3 font关键字属性值的应用价值 246\n8．5 真正了解@font face规则 247\n8．5．1 @font face的本质是变量 247\n8．5．2 @font face与字体图标技术 255\n8．6 文本的控制 258\n8．6．1 text-indent与内联元素缩进 258\n8．6．2 letter-spacing与字符间距 261\n8．6．3 word-spacing与单词间距 263\n8．6．4 了解word-break和word-wrap的区别 264\n8．6．5 white-space与换行和空格的控制 265\n8．6．6 text-align与元素对齐 267\n8．6．7 如何解决text-decoration下划线和文本重叠的问题 271\n8．6．8 一本万利的text-transform字符大小写 273\n8．7 了解：first-letter/：first-line伪元素 274\n8．7．1 深入：first-letter伪元素及其实例 274\n8．7．2 故事相对较少的：first-line伪元素 277\n第9章　元素的装饰与美化 280\n9．1 CSS世界的color很单调 280\n9．1．1 少得可怜的颜色关键字 280\n9．1．2 不支持的transparent关键字 282\n9．1．3 不支持的currentColor变量 282\n9．1．4 不支持的rgba颜色和hsla颜色 282\n9．1．5 支持却鸡肋的系统颜色 283\n9．2 CSS世界的background很单调 285\n9．2．1 隐藏元素的background-image到底加不加载 285\n9．2．2 与众不同的background-position百分比计算方式 286\n9．2．3 background-repeat与渲染性能 287\n9．2．4 外强中干的background-attachment：fixed 288\n9．2．5 background-color背景色永远是很低的 289\n9．2．6 利用多背景的属性hack小技巧 290\n9．2．7 渐变背景和rgba背景色的兼容处理 290\n第 10章　元素的显示与隐藏 292\n10．1 display与元素的显隐 294\n10．2 visibility与元素的显隐 296\n10．2．1 不仅仅是保留空间这么简单 296\n10．2．2 了解visibility：collapse 301\n第 11章　用户界面样式 302\n11．1 和border形似的outline属性 302\n11．1．1 万万不可在全局设置outline：0 none 302\n11．1．2 真正的不占据空间的outline及其应用 304\n11．2 光标属性cursor 307\n11．2．1 琳琅满目的cursor属性值 307\n11．2．2 自定义光标 314\n第 12章　流向的改变 315\n12．1 改变水平流向的direction 315\n12．1．1 direction简介 315\n12．1．2 direction的黄金搭档unicode-bidi 318\n12．2 改变CSS世界纵横规则的writing-mode 320\n12．2．1 writing-mode原本的作用 321\n12．2．2 writing-mode不经意改变了哪些规则 324\n12．2．3 writing-mode和direction的关系 328",
    "pages": "328",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29651678.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29651678.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29651678.jpg"
    },
    "alt": "https://book.douban.com/subject/27615777/",
    "id": "27615777",
    "publisher": "人民邮电出版社",
    "isbn10": "7115470669",
    "isbn13": "9787115470669",
    "title": "CSS世界",
    "url": "https://api.douban.com/v2/book/27615777",
    "alt_title": "",
    "author_intro": "张鑫旭，前端开发工程师，国内知名前端博客“鑫空间-鑫生活”博主，目前就职于阅文集团用户体验设计部（YUX），担任技术经理。2007年开始接触前端，10年来一直工作在前端开发一线，在HTML/CSS等与交互体验关系密切的领域花了大量的时间学习和研究，有比较多的心得体会。",
    "summary": "本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰等方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。作者还为本书开发了专门的配套网站，进行实例展示、问题答疑。\n作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。",
    "price": "CNY 69.00"
  },
  "9787115416940": {
    "rating": { "max": 10, "numRaters": 258, "average": "9.4", "min": 0 },
    "subtitle": "",
    "author": ["[希] Lea Verou"],
    "pubdate": "2016-4",
    "tags": [
      { "count": 391, "name": "CSS", "title": "CSS" },
      { "count": 199, "name": "前端开发", "title": "前端开发" },
      { "count": 127, "name": "前端", "title": "前端" },
      { "count": 70, "name": "网页设计", "title": "网页设计" },
      { "count": 57, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 52, "name": "CSS秘笈", "title": "CSS秘笈" },
      { "count": 50, "name": "编程", "title": "编程" },
      { "count": 40, "name": "计算机", "title": "计算机" }
    ],
    "origin_title": "CSS Secrets: Better Solutions to Everyday Web Design Problems",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28659699.jpg",
    "binding": "平装",
    "translator": ["CSS魔法"],
    "catalog": "译者序\n序\n前言\n第1章 引言\n第2章 背景与边框\n第3章 形状\n第4章 视觉效果\n第5章 字体排印\n第6章 用户体验\n第7章 结构与布局\n第8章 过渡与动画\n按规范分类",
    "pages": "260",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28659699.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28659699.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28659699.jpg"
    },
    "alt": "https://book.douban.com/subject/26745943/",
    "id": "26745943",
    "publisher": "人民邮电出版社",
    "isbn10": "711541694X",
    "isbn13": "9787115416940",
    "title": "CSS揭秘",
    "url": "https://api.douban.com/v2/book/26745943",
    "alt_title": "CSS Secrets: Better Solutions to Everyday Web Design Problems",
    "author_intro": "Lea Verou\nW3C CSS工作组特邀专家，设计CSS语言的委员之一，此前曾在W3C担任开发者代言人。目前，她在麻省理工学院从事人机交互领域的研究。她还是一位博客作家，并经常在国际性的技术会议上担任讲师；她创建的多个开源项目广受开发者欢迎。\nCSS魔法\n原名张鹏，国内知名的CSS技术专家，百姓网前端架构师。拥有近十年的网站开发经验，在移动前端领域积累颇深，自称“披着工程师外衣的设计师”。他是CMUI、Action、GHX等开源项目的作者，曾为GitHub、Gulp、Stylus等网站和项目翻译过大量文档；其生动活泼、循序渐进的博客写作风格深受读者喜爱；在CSS Conf等技术会议上所作的演讲广受好评。",
    "summary": "本书是一本注重实践的教程，作者为我们揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、 视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。本书将带领读者循序渐进地探寻更优雅的解决方案，攻克每天都会遇到的各种网页样式难题。\n本书的读者对象为前端工程师、网页开发人员。",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "99.00元"
  },
  "9787121238369": {
    "rating": { "max": 10, "numRaters": 178, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["阮一峰"],
    "pubdate": "2014-8",
    "tags": [
      { "count": 97, "name": "JavaScript", "title": "JavaScript" },
      { "count": 66, "name": "ECMAScript6", "title": "ECMAScript6" },
      { "count": 49, "name": "前端", "title": "前端" },
      { "count": 18, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 17, "name": "编程", "title": "编程" },
      { "count": 15, "name": "Javascript", "title": "Javascript" },
      { "count": 12, "name": "计算机", "title": "计算机" },
      { "count": 9, "name": "Web", "title": "Web" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28315395.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第一章ECMAScript6简介............................  1\nECMAScript和JavaScript的关系    3\nECMAScript的历史    4\n部署进度    5Traceur编译器    7\nECMAScript7    11\n第二章let和const命令..............................13\nlet命令    15\n块级作用域    17\nconst命令    19\n第三章 变量的解构赋值..............................21\n数组的解构赋值    23\n对象的解构赋值    25\n用途    27\n第四章 字符串的扩展 ................................31\ncodePointAt方法    33\nString.fromCodePoint方法    34\n字符的Unicode表示法    35\n正则表达式的u修饰符    36\ncontains(),startsWith(),endsWith()    36\nrepeat()    37\n正则表达式的y修饰符    38\n模板字符串    39\n第五章 数值的扩展 ..................................41\n二进制和八进制数值表示法    43\nNumber.isFinite(),Number.isNaN()    43\nNumber.parseInt(),Number.parseFloat()    44\nNumber.isInteger()和安全整数    44\nMath对象的扩展    45\nMath.trunc()    45\n数学方法    45\n第六章 数组的扩展 ..................................47\nArray.from()    49\nArray.of()    50\n数组实例的fnd()和fndIndex()    50\n数组实例的fll()    51\n数组实例的entries()，keys()和values()    52\n数组推导    53\nArray.observe()，Array.unobserve()    55\n第七章 对象的扩展 ..................................57\nObject.is()    59\nObject.assign()    59\n__proto__属性，Object.setPrototypeOf()，\nObject.getPrototypeOf()    60\n__proto__属性    60\nObject.setPrototypeOf()    61\nObject.getPrototypeOf()    61\n增强的对象写法    62\n属性名表达式    63Symbol    64\nProxy    66Object.observe()，Object.unobserve()    68\n第八章 函数的扩展 ..................................71\n函数参数的默认值    73rest参数    74\n扩展运算符    75箭头函数    77\n第九章 Set和Map数据结构..........................81Set    83Map    86\n基本用法    86\n属性和方法    88\n遍历    89WeakMap    91\n第十章Iterator和for...of循环.......................93\nIterator（遍历器）    95for...of循环    97\n第十一章Generator函数..............................103\n含义    105\nnext方法的参数    108\n异步操作的应用    109\nfor...of循环    112\nyield*语句    112\n第十二章Promise对象 ...............................115\n基本用法    117\n链式操作    120\ncatch方法：捕捉错误    121\nPromise.all方法    121\nPromise.resolve方法    122\nasync函数    123\n第13章  Class和Module.............................125\nClass    127\nModule的基本用法    129\nexport和import    129\n模块的整体加载    130\nexportdefault语句    131\n模块的继承    132\n参考链接.............................................135\n索引.................................................143",
    "pages": "145",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28315395.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28315395.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28315395.jpg"
    },
    "alt": "https://book.douban.com/subject/25966265/",
    "id": "25966265",
    "publisher": "电子工业出版社",
    "isbn10": "7121238365",
    "isbn13": "9787121238369",
    "title": "ECMAScript6入门",
    "url": "https://api.douban.com/v2/book/25966265",
    "alt_title": "",
    "author_intro": "阮一峰：著名技术博客作者，JavaScript专家。专注于网站开发技术，超过十年。畅销书《黑客与画家》《软件随想录》的译者。",
    "summary": "《ECMAScript6入门》全面介绍了ECMAScript6新引入的语法特性，覆盖了ECMAScript6与ECMAScript5的所有不同之处，对涉及的语法知识给予了详细介绍，并给出了大量简洁易懂的示例代码。\n《ECMAScript6入门》为中级难度，适合已有一定JavaScript语言基础的读者，用来了解这门语言的最新发展；也可当作参考手册，查寻新增的语法点。",
    "price": "49.00元"
  },
  "9787115350657": {
    "rating": { "max": 10, "numRaters": 84, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["[美] Elizabeth Castro", "[美] Bruce Hyslop"],
    "pubdate": "2014-5",
    "tags": [
      { "count": 75, "name": "HTML5", "title": "HTML5" },
      { "count": 64, "name": "CSS3", "title": "CSS3" },
      { "count": 51, "name": "前端", "title": "前端" },
      { "count": 36, "name": "前端开发", "title": "前端开发" },
      { "count": 23, "name": "计算机", "title": "计算机" },
      { "count": 23, "name": "HTML", "title": "HTML" },
      { "count": 22, "name": "web", "title": "web" },
      { "count": 9, "name": "计算机网络", "title": "计算机网络" }
    ],
    "origin_title": "HTML and CSS:visual quickstart guide",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27328058.jpg",
    "binding": "平装",
    "translator": ["望以文"],
    "catalog": "第1章　网页的构造块　　1\n1.1　HTML思想　　1\n1.2　基本的HTML页面　　2\n1.3　标签：元素、属性、值及其他　　4\n1.4　网页的文本内容　　7\n1.5　链接、图像和其他非文本内容　　8\n1.6　文件名和文件夹名　　9\n1.7　URL　　10\n1.8　HTML：有含义的标记　　13\n1.9　浏览器对网页的默认显示效果　　16\n1.10　要点回顾　　17\n第2章　处理网页文件　　19\n2.1　规划网站　　19\n2.2　创建新的网页　　20\n2.3　保存网页　　21\n2.4　指定默认页面或主页　　24\n2.5　编辑网页　　24\n2.6　组织文件　　25\n2.7　在浏览器中查看网页　　26\n2.8　借鉴他人灵感　　28\n第3章　基本HTML结构　　30\n3.1　开始编写网页　　30\n3.2　创建页面标题　　33\n3.3　创建分级标题　　34\n3.4　普通页面构成　　36\n3.5　创建页眉　　37\n3.6　标记导航　　39\n3.7　标记页面的主要区域　　41\n3.8　创建文章　　42\n3.9　定义区块　　45\n3.10　指定附注栏　　46\n3.11　创建页脚　　50\n3.12　创建通用容器　　53\n3.13　使用ARIA改善可访问性　　56\n3.14　为元素指定类别或ID名称　　59\n3.15　为元素添加title属性　　61\n3.16　添加注释　　62\n第4章　文本　　63\n4.1　添加段落　　63\n4.2　指定细则　　64\n4.3　标记重要和强调的文本　　65\n4.4　创建图　　67\n4.5　指明引用或参考　　69\n4.6　引述文本　　70\n4.7　指定时间　　72\n4.8　解释缩写词　　75\n4.9　定义术语　　76\n4.10　创建上标和下标　　77\n4.11　添加作者联系信息　　79\n4.12　标注编辑和不再准确的文本　　80\n4.13　标记代码　　83\n4.14　使用预格式化的文本　　84\n4.15　突出显示文本　　85\n4.16　创建换行　　87\n4.17　创建span　　88\n4.18　其他元素　　89\n第5章　图像　　95\n5.1　关于Web图像　　95\n5.2　获取图像　　99\n5.3　选择图像编辑器　　100\n5.4　保存图像　　100\n5.5　在页面中插入图像　　103\n5.6　提供替代文本　　105\n5.7　指定图像尺寸　　106\n5.8　在浏览器中改变图像的尺寸　　108\n5.9　在图像编辑器中改变图像的尺寸　　110\n5.10　为网站添加图标　　111\n第6章　链接　　113\n6.1　创建指向另一个网页的链接　　113\n6.2　创建锚并链接到锚　　118\n6.3　创建其他类型的链接　　120\n第7章　CSS 构造块　　123\n7.1　构造样式规则　　123\n7.2　为样式规则添加注释　　124\n7.3　理解继承　　126\n7.4　层叠：当规则发生冲突时　　129\n7.5　属性的值　　132\n第8章　操作样式表　　139\n8.1　创建外部样式表　　139\n8.2　链接到外部样式表　　140\n8.3　创建嵌入样式表　　142\n8.4　应用内联样式　　143\n8.5　样式的层叠和顺序　　145\n8.6　使用与媒体相关的样式表　　147\n8.7　借鉴他人的灵感　　148\n第9章　定义选择器　　150\n9.1　构造选择器　　150\n9.2　按名称选择元素　　152\n9.3　按类或ID 选择元素　　153\n9.4　按上下文选择元素　　156\n9.5　选择第一个或最后一个子元素　　159\n9.6　选择元素的第一个字母或者第一行　　161\n9.7　按状态选择链接元素　　163\n9.8　按属性选择元素　　164\n9.9　指定元素组　　168\n9.10　组合使用选择器　　169\n第10章　为文本添加样式　　171\n10.1　本章之前与本章之后　　171\n10.2　选择字体系列　　173\n10.3　指定替代字体　　174\n10.4　创建斜体　　176\n10.5　应用粗体格式　　177\n10.6　设置字体大小　　179\n10.7　设置行高　　184\n10.8　同时设置所有字体值　　185\n10.9　设置颜色　　187\n10.10　设置背景　　188\n10.11　控制间距　　195\n10.12　添加缩进　　195\n10.13　对齐文本　　196\n10.14　修改文本的大小写　　197\n10.15　使用小型大写字母　　198\n10.16　装饰文本　　199\n10.17　设置空白属性　　201\n第11章　用CSS 进行布局　　202\n11.1　开始布局的注意事项　　203\n11.2　构建页面　　204\n11.3　在旧版浏览器中为HTML5元素添加样式　　206\n11.4　对默认样式进行重置或标准化　　208\n11.5　盒模型　　209\n11.6　控制元素的显示类型和可见性　　211\n11.7　设置元素的高度和宽度　　214\n11.8　在元素周围添加内边距　　217\n11.9　设置边框　　219\n11.10　设置元素周围的外边距　　222\n11.11　使元素浮动　　224\n11.12　控制元素浮动的位置　　226\n11.13　对元素进行相对定位　　230\n11.14　对元素进行绝对定位　　231\n11.15　在栈中定位元素　　232\n11.16　处理溢出　　233\n11.17　垂直对齐元素　　234\n11.18　修改鼠标指针　　235\n第12章　构建响应式网站　　237\n12.1　响应式Web 设计：概述　　237\n12.2　创建可伸缩图像　　239\n12.3　创建弹性布局网格　　241\n12.4　理解和实现媒体查询　　245\n12.5　组合使用　　251\n12.6　兼容旧版IE　　257\n第13章　使用Web 字体　　259\n13.1　什么是Web 字体　　259\n13.2　在哪里能找到Web 字体　　261\n13.3　下载第一个Web 字体　　263\n13.4　理解@font-face 规则　　265\n13.5　使用Web 字体设置文本样式　　266\n13.6　为Web 字体应用斜体和粗体　　269\n13.7　使用Google Fonts 的Web字体　　275\n第14章　使用CSS3 进行增强　　278\n14.1　浏览器兼容性、渐进增强和polyfill　　278\n14.2　理解厂商前缀　　280\n14.3　为元素创建圆角　　281\n14.4　为文本添加阴影　　284\n14.5　为其他元素添加阴影　　285\n14.6　应用多重背景　　288\n14.7　使用渐变背景　　290\n14.8　为元素设置不透明度　　295\n14.9　生成内容的效果　　297\n14.10　使用sprite 拼合图像　　299\n第15章　列表　　301\n15.1　创建有序列表和无序列表　　301\n15.2　选择标记　　304\n15.3　使用定制的标记　　305\n15.4　选择列表的起始编号　　308\n15.5　控制标记的位置　　309\n15.6　同时设置所有的列表样式属性　　310\n15.7　设置嵌套列表的样式　　311\n15.8　创建描述列表　　314\n第16章　表单　　318\n16.1　HTML5 对表单的改进　　318\n16.2　创建表单　　320\n16.3　处理表单　　323\n16.4　对表单元素进行组织　　324\n16.5　创建文本框　　327\n16.6　为表单组件添加说明标签　　330\n16.7　创建密码框　　332\n16.8　创建电子邮件框、搜索框、电话框和URL 框　　332\n16.9　创建单选按钮　　336\n16.10　创建复选框　　337\n16.11　创建文本区域　　338\n16.12　创建选择框　　339\n16.13　让访问者上传文件　　341\n16.14　创建隐藏字段　　342\n16.15　创建提交按钮　　343\n16.16　禁用表单元素　　345\n16.17　根据状态为表单设置样式　　346\n第17章　视频、音频和其他多媒体　　349\n17.1　第三方插件和步入原生　　349\n17.2　视频文件格式　　350\n17.3　在网页中添加单个视频　　351\n17.4　为视频添加控件和自动播放　　352\n17.5　为视频指定循环播放和海报图像　　354\n17.6　阻止视频预加载　　355\n17.7　使用多种来源的视频和备用文本　　356\n17.8　提供可访问性　　358\n17.9　音频文件格式　　358\n17.10　在网页中添加带控件的单个音频文件　　359\n17.11　自动播放、循环和预加载音频　　360\n17.12　提供带备用内容的多个视频源　　361\n17.13　添加具有备用Flash 的视频和音频　　362\n17.14　高级多媒体　　366\n17.15　更多资源　　366\n第18章　表格　　368\n18.1　结构化表格　　368\n18.2　让单元格跨越多列或多行　　371\n第19章　添加JavaScript　　373\n19.1　加载外部脚本　　374\n19.2　添加嵌入脚本　　378\n19.3　JavaScript 事件　　378\n第20章　测试和调试网页　　380\n20.1　验证代码　　380\n20.2　测试页面　　382\n20.3　尝试一些调试技巧　　385\n20.4　检查常见错误：一般问题　　386\n20.5　检查常见错误：HTML　　387\n20.6　检查常见错误：CSS　　388\n20.7　如果图像不显示　　390\n第21章　发布网站　　392\n21.1　获得域名　　392\n21.2　为网站寻找主机　　393\n21.3　将文件传送至服务器　　394\n附录A　HTML 参考　　398\n附录B　CSS 引用　　408",
    "ebook_url": "https://read.douban.com/ebook/12189016/",
    "pages": "417",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27328058.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27328058.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27328058.jpg"
    },
    "alt": "https://book.douban.com/subject/25878992/",
    "id": "25878992",
    "publisher": "人民邮电出版社",
    "isbn10": "7115350655",
    "isbn13": "9787115350657",
    "title": "HTML5与CSS3基础教程（第8版）",
    "url": "https://api.douban.com/v2/book/25878992",
    "alt_title": "HTML and CSS:visual quickstart guide",
    "author_intro": "作者简介：\nElizabeth Castro\n享誉世界的计算机畅销书作家，电子出版先行者，2010年就出版了epub电子书制作教程EPUB Straight to the Point。Castro 擅长使用详实的步骤和精美的实例教大家快速实现具体效果，她的HTML与CSS系列教程自出版以来广受读者欢迎，成为学习前端开发的首选参考图书。有关Castro的更多信息，可访问其个人主页ElizabethCastro.com。\nBruce Hyslop\n自1997年就开始从事网页开发，重点关注使用HTML、CSS和JavaScript进行网页开发和网站易用性的维护，并倡导最佳实践。Hyslop在加州大学洛杉矶分校进修部教授CSS课程，还著有The HTML Pocket Guide、The Web Design Pocket Guide Boxed Set。\n译者简介：\n望以文\n毕业于中国人民大学，曾任百度前端工程师，现为网信金融产品经理。《HTML5与CSS3基础教程（第7版）》译者。热爱产品设计，维护微信公众号projojo，定期向读者推荐新鲜有趣的互联网产品。微博@weakow。",
    "summary": "本书是风靡全球的HTML和CSS入门教程的最新版，至第6版累积销量已超过100万册，被翻译为十多种语言，长期雄踞亚马逊书店计算机图书排行榜榜首。\n第8版秉承作者直观透彻、循序渐进、基础知识与案例实践紧密结合的讲授特色，采用独特的双栏图文并排方式，手把手指导读者从零开始轻松入门。相较第7版，全书2/3以上的内容进行了更新，全面反映了HTML5和CSS3的最新特色，细致阐述了响应式Web设计与移动开发等热点问题。书中主要内容包括：如何创建HTML5页面，如何使用HTML5元素，如何用CSS3为网页添加样式，如何向页面添加JavaScript代码，如何测试做好的页面并将其上传到万维网。另外，本书强调渐进增强这种网站设计方法的重要性，并将其贯穿在全书的具体实践中。\n作者专为本书设计了内容丰富的配套网站htmlcssvqs.com，提供海量精彩示例、HTML与CSS元素及属性列表以及其他附加材料，方便读者随时参考与引用。",
    "ebook_price": "29.99",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "69.00元"
  },
  "9787115388889": {
    "rating": { "max": 10, "numRaters": 299, "average": "9.1", "min": 0 },
    "subtitle": "",
    "author": ["曾探"],
    "pubdate": "2015-5",
    "tags": [
      { "count": 449, "name": "JavaScript", "title": "JavaScript" },
      { "count": 295, "name": "设计模式", "title": "设计模式" },
      { "count": 190, "name": "前端开发", "title": "前端开发" },
      { "count": 97, "name": "前端", "title": "前端" },
      { "count": 83, "name": "Web前端", "title": "Web前端" },
      { "count": 71, "name": "编程", "title": "编程" },
      { "count": 67, "name": "javascript", "title": "javascript" },
      { "count": 62, "name": "计算机", "title": "计算机" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28065006.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第一部分　基础知识\n第1章　面向对象的JavaScript\n1.1 动态类型语言和鸭子类型　　2\n1.2 多态　　4\n1.3 封装　　12\n1.4 原型模式和基于原型继承的JavaScript对象系统　　14\n第2章　this、call和apply\n2.1 this　　24\n2.2 call和apply　　29\n第3章　闭包和高阶函数\n3.1 闭包 35\n3.2 高阶函数　　44\n3.3 小结　　58\n第二部分 设计模式\n第4章　单例模式\n4.1 实现单例模式　　60\n4.2 透明的单例模式　　61\n4.3 用代理实现单例模式　　62\n4.4 JavaScript中的单例模式　　63\n4.5 惰性单例　　65\n4.6 通用的惰性单例　　68\n4.7 小结　　70\n第5章　策略模式\n5.1 使用策略模式计算奖金　　72\n5.2 JavaScript 版本的策略模式　　75\n5.3 多态在策略模式中的体现　　76\n5.4 使用策略模式实现缓动动画　　76\n5.5 更广义的“算法”　　80\n5.6 表单校验　　80\n5.7 策略模式的优缺点　　86\n5.8 一等函数对象与策略模式　　86\n5.9 小结　　87\n第6章　代理模式\n6.1 第一个例子——小明追MM的故事　　88\n6.2 保护代理和虚拟代理　　91\n6.3 虚拟代理实现图片预加载　　91\n6.4 代理的意义　　93\n6.5 代理和本体接口的一致性　　94\n6.6 虚拟代理合并HTTP 请求　　95\n6.7 虚拟代理在惰性加载中的应用　　97\n6.8 缓存代理　　99\n6.9 用高阶函数动态创建代理　　100\n6.10 其他代理模式　　101\n6.11 小结　　102\n第7章　迭代器模式\n7.1 jQuery 中的迭代器　　103\n7.2 实现自己的迭代器　　104\n7.3 内部迭代器和外部迭代器　　104\n7.4 迭代类数组对象和字面量对象　　106\n7.5 倒序迭代器　　106\n7.6 中止迭代器　　107\n7.7 迭代器模式的应用举例　　107\n7.8 小结　　109\n第8章　发布—订阅模式\n8.1 现实中的发布—订阅模式　　110\n8.2 发布—订阅模式的作用　　110\n8.3 DOM 事件　　111\n8.4 自定义事件　　112\n8.5 发布—订阅模式的通用实现　　113\n8.6 取消订阅的事件　　115\n8.7 真实的例子——网站登录　　115\n8.8 全局的发布—订阅对象　　117\n8.9 模块间通信　　119\n8.10 必须先订阅再发布吗　　120\n8.11 全局事件的命名冲突　　121\n8.12 JavaScript实现发布—订阅模式的便利性　　124\n8.13 小结　　124\n第9章　命令模式\n9.1 命令模式的用途　　125\n9.2 命令模式的例子——菜单程序　　126\n9.3 JavaScript中的命令模式　　128\n9.4 撤销命令　　130\n9.5 撤消和重做　　132\n9.6 命令队列　　134\n9.7 宏命令　　134\n9.8 智能命令与傻瓜命令　　135\n9.9 小结　　136\n第10章　组合模式\n10.1 回顾宏命令　　138\n10.2 组合模式的用途　　139\n10.3 请求在树中传递的过程　　139\n10.4 更强大的宏命令　　140\n10.5 抽象类在组合模式中的作用　　143\n10.6 透明性带来的安全问题　　144\n10.7 组合模式的例子——扫描文件夹　　145\n10.8 一些值得注意的地方　　147\n10.9 引用父对象　　148\n10.10 何时使用组合模式　　150\n10.11 小结　　150\n第11章　模板方法模式\n11.1 模板方法模式的定义和组成　　151\n11.2 第一个例子——Coffee or Tea　　151\n11.3 抽象类　　156\n11.4 模板方法模式的使用场景　　159\n11.5 钩子方法　　160\n11.6 好莱坞原则　　162\n11.7 真的需要“继承”吗　　162\n11.8 小结　　164\n第12章　享元模式\n12.1 初识享元模式　　165\n12.2 内部状态与外部状态　　166\n12.3 享元模式的通用结构　　167\n12.4 文件上传的例子　　167\n12.5 享元模式的适用性　　173\n12.6 再谈内部状态和外部状态　　173\n12.7 对象池　　175\n12.8 小结　　178\n第13章　职责链模式\n13.1 现实中的职责链模式　　179\n13.2 实际开发中的职责链模式　　180\n13.3 用职责链模式重构代码　　181\n13.4 灵活可拆分的职责链节点　　183\n13.5 异步的职责链　　184\n13.6 职责链模式的优缺点　　185\n13.7 用AOP 实现职责链　　186\n13.8 用职责链模式获取文件上传对象　　187\n13.9 小结　　188\n第14章　中介者模式\n14.1 现实中的中介者　　190\n14.2 中介者模式的例子——泡泡堂游戏　　191\n14.3 中介者模式的例子——购买商品　　199\n14.4 小结　　207\n第15章　装饰者模式\n15.1 模拟传统面向对象语言的装饰者模式　　210\n15.2 装饰者也是包装器　　211\n15.3 回到JavaScript 的装饰者　　212\n15.4 装饰函数　　212\n15.5 用AOP 装饰函数　　214\n15.6 AOP 的应用实例　　216\n15.7 装饰者模式和代理模式　　222\n15.8 小结　　223\n第16章　状态模式\n16.1 初识状态模式　　224\n16.2 状态模式的定义　　230\n16.3 状态模式的通用结构　　230\n16.4 缺少抽象类的变通方式　　　231\n16.5 另一个状态模式示例——文件上传　　232\n16.6 状态模式的优缺点　　241\n16.7 状态模式中的性能优化点　　241\n16.8 状态模式和策略模式的关系　　241\n16.9 JavaScript版本的状态机　　242\n16.10 表驱动的有限状态机　　244\n16.11 实际项目中的其他状态机　　245\n16.12 小结　　245\n第17章　适配器模式\n17.1 现实中的适配器　　246\n17.2 适配器模式的应用　　247\n17.3 小结　　250\n第三部分 设计原则和编程技巧\n第18章　单一职责原则\n18.1 设计模式中的SRP原则　　252\n18.2 何时应该分离职责　　256\n18.3 违反SRP原则　　256\n18.4 SRP 原则的优缺点　　257\n第19章　最少知识原则\n19.1 减少对象之间的联系　　258\n19.2 设计模式中的LKP原则　　259\n19.3 封装在LKP 原则中的体现　　261\n第20章　开放-封闭原则\n20.1 扩展window.onload函数　　263\n20.2 开放和封闭　　264\n20.3 用对象的多态性消除条件分支　　265\n20.4 找出变化的地方　　266\n20.5 设计模式中的开放—封闭原则　　268\n20.6 开放—封闭原则的相对性　　270\n20.7 接受第一次愚弄　　270\n第21章　接口和面向接口编程\n21.1 回到Java的抽象类　　271\n21.2 interface　　276\n21.3 JavaScript 语言是否需要抽象类和interface　　275\n21.4 用鸭子类型进行接口检查　　277\n21.5 用TypeScript 编写基于interface的命令模式　　278\n第22章　代码重构\n22.1 提炼函数　　282\n22.2 合并重复的条件片段　　283\n22.3 把条件分支语句提炼成函数　　284\n22.4 合理使用循环　　285\n22.5 提前让函数退出代替嵌套条件分支　　285\n22.6 传递对象参数代替过长的参数列表　　286\n22.7 尽量减少参数数量　　287\n22.8 少用三目运算符　　288\n22.9 合理使用链式调用　　288\n22.10 分解大型类　　289\n22.11 用return退出多重循环　　290\n参考文献　　293",
    "pages": "294",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28065006.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28065006.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28065006.jpg"
    },
    "alt": "https://book.douban.com/subject/26382780/",
    "id": "26382780",
    "publisher": "人民邮电出版社",
    "isbn10": "7115388881",
    "isbn13": "9787115388889",
    "title": "JavaScript设计模式与开发实践",
    "url": "https://api.douban.com/v2/book/26382780",
    "alt_title": "",
    "author_intro": "曾探\n2007年毕业于吉林大学软件学院。就职于国内知名前端团队腾讯AlloyTeam，高级工程师。\n曾参与Web QQ、QQ群、Q+开发者网站、微云、QQ兴趣部落等大型前端项目的开发。有过Java、Python和JavaScript的开发经验，业余作品有HTML5版街头霸王等。\n平时喜欢电影和音乐，业务时间也是一名健身教练。",
    "summary": "本书在尊重《设计模式》原意的同时，针对JavaScript语言特性全面介绍了更适合JavaScript程序员的了16个常用的设计模式，讲解了JavaScript面向对象和函数式编程方面的基础知识，介绍了面向对象的设计原则及其在设计模式中的体现，还分享了面向对象编程技巧和日常开发中的代码重构。本书将教会你如何把经典的设计模式应用到JavaScript语言中，编写出优美高效、结构化和可维护的代码。",
    "series": { "id": "13000", "title": "图灵原创" },
    "price": "59.00元"
  },
  "9787115275790": {
    "rating": { "max": 10, "numRaters": 1956, "average": "9.3", "min": 0 },
    "subtitle": "",
    "author": ["[美] Nicholas C. Zakas"],
    "pubdate": "2012-3-29",
    "tags": [
      { "count": 2336, "name": "JavaScript", "title": "JavaScript" },
      { "count": 1084, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 683, "name": "前端开发", "title": "前端开发" },
      { "count": 518, "name": "前端", "title": "前端" },
      { "count": 508, "name": "javascript", "title": "javascript" },
      { "count": 458, "name": "编程", "title": "编程" },
      { "count": 415, "name": "计算机", "title": "计算机" },
      { "count": 410, "name": "Web开发", "title": "Web开发" }
    ],
    "origin_title": "Professional JavaScript for Web",
    "image": "https://img3.doubanio.com/view/subject/m/public/s8958650.jpg",
    "binding": "平装",
    "translator": ["李松峰", "曹力"],
    "catalog": "目　　录\n第1章　JavaScript简介　　1\n1.1　JavaScript简史　　1\n1.2　JavaScript实现　　2\n1.2.1　ECMAScript　　3\n1.2.2　文档对象模型（DOM）　　5\n1.2.3　浏览器对象模型（BOM）　　8\n1.3　JavaScript版本　　8\n1.4　小结　　9\n第2章　在HTML中使用JavaScript　　10\n2.1　<script>元素　　10\n2.1.1　标签的位置　　12\n2.1.2　延迟脚本　　13\n2.1.3　异步脚本　　13\n2.1.4　在XHTML中的用法　　14\n2.1.5　不推荐使用的语法　　16\n2.2　嵌入代码与外部文件　　16\n2.3　文档模式　　16\n2.4　<noscript>元素　　18\n2.5　小结　　18\n第3章　基本概念　　19\n3.1　语法　　19\n3.1.1　区分大小写　　19\n3.1.2　标识符　　19\n3.1.3　注释　　20\n3.1.4　严格模式　　20\n3.1.5　语句　　20\n3.2　关键字和保留字　　21\n3.3　变量　　22\n3.4　数据类型　　23\n3.4.1　typeof操作符　　23\n3.4.2　Undefined类型　　24\n3.4.3　Null类型　　25\n3.4.4　Boolean类型　　26\n3.4.5　Number类型　　27\n3.4.6　String类型　　32\n3.4.7　Object类型　　35\n3.5　操作符　　36\n3.5.1　一元操作符　　36\n3.5.2　位操作符　　39\n3.5.3　布尔操作符　　44\n3.5.4　乘性操作符　　47\n3.5.5　加性操作符　　48\n3.5.6　关系操作符　　50\n3.5.7　相等操作符　　51\n3.5.8　条件操作符　　53\n3.5.9　赋值操作符　　53\n3.5.10　逗号操作符　　54\n3.6　语句　　54\n3.6.1　if语句　　54\n3.6.2　do-while语句　　55\n3.6.3　while语句　　55\n3.6.4　for语句　　56\n3.6.5　for-in语句　　57\n3.6.6　label语句　　58\n3.6.7　break和continue语句　　58\n3.6.8　with语句　　60\n3.6.9　switch语句　　60\n3.7　函数　　62\n3.7.1　理解参数　　64\n3.7.2　没有重载　　66\n3.8　小结　　67\n第4章　变量、作用域和内存问题　　68\n4.1　基本类型和引用类型的值　　68\n4.1.1　动态的属性　　68\n4.1.2　复制变量值　　69\n4.1.3　传递参数　　70\n4.1.4　检测类型　　72\n4.2　执行环境及作用域　　73\n4.2.1　延长作用域链　　75\n4.2.2　没有块级作用域　　76\n4.3　垃圾收集　　78\n4.3.1　标记清除　　78\n4.3.2　引用计数　　79\n4.3.3　性能问题　　80\n4.3.4　管理内存　　81\n4.4　小结　　81\n第5章　引用类型　　83\n5.1　Object类型　　83\n5.2　Array类型　　86\n5.2.1　检测数组　　88\n5.2.2　转换方法　　89\n5.2.3　栈方法　　90\n5.2.4　队列方法　　91\n5.2.5　重排序方法　　92\n5.2.6　操作方法　　94\n5.2.7　位置方法　　95\n5.2.8　迭代方法　　96\n5.2.9　缩小方法　　97\n5.3　Date类型　　98\n5.3.1　继承的方法　　100\n5.3.2　日期格式化方法　　101\n5.3.3　日期/时间组件方法　　102\n5.4　RegExp类型　　103\n5.4.1　RegExp实例属性　　105\n5.4.2　RegExp实例方法　　106\n5.4.3　RegExp构造函数属性　　107\n5.4.4　模式的局限性　　109\n5.5　Function类型　　110\n5.5.1　没有重载（深入理解）　　111\n5.5.2　函数声明与函数表达式　　111\n5.5.3　作为值的函数　　112\n5.5.4　函数内部属性　　113\n5.5.5　函数属性和方法　　116\n5.6　基本包装类型　　118\n5.6.1　Boolean类型　　120\n5.6.2　Number类型　　120\n5.6.3　String类型　　122\n5.7　单体内置对象　　130\n5.7.1　Global对象　　131\n5.7.2　Math对象　　134\n5.8　小结　　137\n第6章　面向对象的程序设计　　138\n6.1　理解对象　　138\n6.1.1　属性类型　　139\n6.1.2　定义多个属性　　142\n6.1.3　读取属性的特性　　143\n6.2　创建对象　　144\n6.2.1　工厂模式　　144\n6.2.2　构造函数模式　　144\n6.2.3　原型模式　　147\n6.2.4　组合使用构造函数模式和原型模式　　159\n6.2.5　动态原型模式　　159\n6.2.6　寄生构造函数模式　　160\n6.2.7　稳妥构造函数模式　　161\n6.3　继承　　162\n6.3.1　原型链　　162\n6.3.2　借用构造函数　　167\n6.3.3　组合继承　　168\n6.3.4　原型式继承　　169\n6.3.5　寄生式继承　　171\n6.3.6　寄生组合式继承　　172\n6.4　小结　　174\n第7章　函数表达式　　175\n7.1　递归　　177\n7.2　闭包　　178\n7.2.1　闭包与变量　　181\n7.2.2　关于this对象　　182\n7.2.3　内存泄漏　　183\n7.3　模仿块级作用域　　184\n7.4　私有变量　　186\n7.4.1　静态私有变量　　188\n7.4.2　模块模式　　189\n7.4.3　增强的模块模式　　191\n7.5　小结　　192\n第8章　BOM　　193\n8.1　window对象　　193\n8.1.1　全局作用域　　193\n8.1.2　窗口关系及框架　　194\n8.1.3　窗口位置　　197\n8.1.4　窗口大小　　198\n8.1.5　导航和打开窗口　　199\n8.1.6　间歇调用和超时调用　　203\n8.1.7　系统对话框　　205\n8.2　location对象　　207\n8.2.1　查询字符串参数　　207\n8.2.2　位置操作　　208\n8.3　navigator对象　　210\n8.3.1　检测插件　　211\n8.3.2　注册处理程序　　213\n8.4　screen对象　　214\n8.5　history对象　　215\n8.6　小结　　216\n第9章　客户端检测　　217\n9.1　能力检测　　217\n9.1.1　更可靠的能力检测　　218\n9.1.2　能力检测，不是浏览器检测　　220\n9.2　怪癖检测　　220\n9.3　用户代理检测　　221\n9.3.1　用户代理字符串的历史　　222\n9.3.2　用户代理字符串检测技术　　228\n9.3.3　完整的代码　　242\n9.3.4　使用方法　　245\n9.4　小结　　246\n第10章　DOM　　247\n10.1　节点层次　　247\n10.1.1　Node类型　　248\n10.1.2　Document类型　　253\n10.1.3　Element类型　　261\n10.1.4　Text类型　　270\n10.1.5　Comment类型　　273\n10.1.6　CDATASection类型　　274\n10.1.7　DocumentType类型　　274\n10.1.8　DocumentFragment类型　　275\n10.1.9　Attr类型　　276\n10.2　DOM操作技术　　277\n10.2.1　动态脚本　　277\n10.2.2　动态样式　　279\n10.2.3　操作表格　　281\n10.2.4　使用NodeList　　283\n10.3　小结　　284\n第11章　DOM扩展　　286\n11.1　选择符API　　286\n11.1.1　querySelector()方法　　286\n11.1.2　querySelectorAll()\n方法　　287\n11.1.3　matchesSelector()\n方法　　288\n11.2　元素遍历　　288\n11.3　HTML5　　289\n11.3.1　与类相关的扩充　　289\n11.3.2　焦点管理　　291\n11.3.3　HTMLDocument的变化　　292\n11.3.4　字符集属性　　293\n11.3.5　自定义数据属性　　293\n11.3.6　插入标记　　294\n11.3.7　scrollIntoView()方法　　298\n11.4　专有扩展　　298\n11.4.1　文档模式　　298\n11.4.2　children属性　　299\n11.4.3　contains()方法　　300\n11.4.4　插入文本　　301\n11.4.5　滚动　　303\n11.5　小结　　304\n第12章　DOM2和DOM3　　305\n12.1　DOM变化　　305\n12.1.1　针对XML命名空间的变化　　306\n12.1.2　其他方面的变化　　309\n12.2　样式　　312\n12.2.1　访问元素的样式　　313\n12.2.2　操作样式表　　317\n12.2.3　元素大小　　320\n12.3　遍历　　326\n12.3.1　NodeIterator　　328\n12.3.2　TreeWalker　　330\n12.4　范围　　332\n12.4.1　DOM中的范围　　332\n12.4.2　IE8及更早版本中的范围　　340\n12.5　小结　　343\n第13章　事件　　345\n13.1　事件流　　345\n13.1.1　事件冒泡　　346\n13.1.2　事件捕获　　346\n13.1.3　DOM事件流　　347\n13.2　事件处理程序　　348\n13.2.1　HTML事件处理程序　　348\n13.2.2　DOM0级事件处理程序　　350\n13.2.3　DOM2级事件处理程序　　351\n13.2.4　IE事件处理程序　　352\n13.2.5　跨浏览器的事件处理程序　　353\n13.3　事件对象　　355\n13.3.1　DOM中的事件对象　　355\n13.3.2　IE中的事件对象　　358\n13.3.3　跨浏览器的事件对象　　360\n13.4　事件类型　　362\n13.4.1　UI事件　　362\n13.4.2　焦点事件　　367\n13.4.3　鼠标与滚轮事件　　368\n13.4.4　键盘与文本事件　　379\n13.4.5　复合事件　　384\n13.4.6　变动事件　　385\n13.4.7　HTML5事件　　388\n13.4.8　设备事件　　395\n13.4.9　触摸与手势事件　　399\n13.5　内存和性能　　402\n13.5.1　事件委托　　402\n13.5.2　移除事件处理程序　　404\n13.6　模拟事件　　405\n13.6.1　DOM中的事件模拟　　405\n13.6.2　IE中的事件模拟　　410\n13.7　小结　　411\n第14章　表单脚本　　412\n14.1　表单的基础知识　　412\n14.1.1　提交表单　　413\n14.1.2　重置表单　　414\n14.1.3　表单字段　　414\n14.2　文本框脚本　　419\n14.2.1　选择文本　　420\n14.2.2　过滤输入　　423\n14.2.3　自动切换焦点　　426\n14.2.4　HTML5约束验证API　　427\n14.3　选择框脚本　　431\n14.3.1　选择选项　　432\n14.3.2　添加选项　　434\n14.3.3　移除选项　　435\n14.3.4　移动和重排选项　　435\n14.4　表单序列化　　436\n14.5　富文本编辑　　438\n14.5.1　使用contenteditable\n属性　　438\n14.5.2　操作富文本　　439\n14.5.3　富文本选区　　441\n14.5.4　表单与富文本　　443\n14.6　小结　　443\n第15章　使用Canvas绘图　　445\n15.1　基本用法　　445\n15.2　2D上下文　　446\n15.2.1　填充和描边　　446\n15.2.2　绘制矩形　　447\n15.2.3　绘制路径　　449\n15.2.4　绘制文本　　451\n15.2.5　变换　　453\n15.2.6　绘制图像　　456\n15.2.7　阴影　　457\n15.2.8　渐变　　458\n15.2.9　模式　　460\n15.2.10　使用图像数据　　460\n15.2.11　合成　　462\n15.3　WebGL　　463\n15.3.1　类型化数组　　463\n15.3.2　WebGL上下文　　468\n15.3.3　支持　　478\n15.4　小结　　478\n第16章　HTML5脚本编程　　480\n16.1　跨文档消息传递　　480\n16.2　原生拖放　　481\n16.2.1　拖放事件　　482\n16.2.2　自定义放置目标　　482\n16.2.3　dataTransfer对象　　483\n16.2.4　dropEffect与effectAllowed　　484\n16.2.5　可拖动　　485\n16.2.6　其他成员　　485\n16.3　媒体元素　　486\n16.3.1　属性　　487\n16.3.2　事件　　488\n16.3.3　自定义媒体播放器　　488\n16.3.4　检测编解码器的支持情况　　489\n16.3.5　Audio类型　　490\n16.4　历史状态管理　　491\n16.5　小结　　492\n第17章　错误处理与调试　　493\n17.1　浏览器报告的错误　　493\n17.1.1　IE　　493\n17.1.2　Firefox　　494\n17.1.3　Safari　　496\n17.1.4　Opera　　497\n17.1.5　Chrome　　498\n17.2　错误处理　　499\n17.2.1　try-catch语句　　500\n17.2.2　抛出错误　　503\n17.2.3　错误（error）事件　　505\n17.2.4　处理错误的策略　　506\n17.2.5　常见的错误类型　　507\n17.2.6　区分致命错误和非致命\n错误　　510\n17.2.7　把错误记录到服务器　　511\n17.3　调试技术　　512\n17.3.1　将消息记录到控制台　　512\n17.3.2　将消息记录到当前页面　　515\n17.3.3　抛出错误　　515\n17.4　常见的IE错误　　516\n17.4.1　操作终止　　516\n17.4.2　无效字符　　518\n17.4.3　未找到成员　　518\n17.4.4　未知运行时错误　　519\n17.4.5　语法错误　　519\n17.4.6　系统无法找到指定资源　　519\n17.5　小结　　520\n第18章　JavaScript与XML　　521\n18.1　浏览器对XML DOM的支持　　521\n18.1.1　DOM2级核心　　521\n18.1.2　DOMParser类型　　522\n18.1.3　XMLSerializer类型　　523\n18.1.4　IE8及之前版本中的XML　　523\n18.1.5　跨浏览器处理XML　　527\n18.2　浏览器对XPath的支持　　529\n18.2.1　DOM3级XPath　　529\n18.2.2　IE中的XPath　　534\n18.2.3　跨浏览器使用XPath　　535\n18.3　浏览器对XSLT的支持　　537\n18.3.1　IE中的XSLT　　537\n18.3.2　XSLTProcessor类型　　541\n18.3.3　跨浏览器使用XSLT　　543\n18.4　小结　　544\n第19章　E4X　　546\n19.1　E4X的类型　　546\n19.1.1　XML类型　　546\n19.1.2　XMLList类型　　547\n19.1.3　Namespace类型　　548\n19.1.4　QName类型　　549\n19.2　一般用法　　550\n19.2.1　访问特性　　551\n19.2.2　其他节点类型　　552\n19.2.3　查询　　553\n19.2.4　构建和操作XML　　555\n19.2.5　解析和序列化　　557\n19.2.6　命名空间　　558\n19.3　其他变化　　559\n19.4　全面启用E4X　　560\n19.5　小结　　561\n第20章　JSON　　562\n20.1　语法　　562\n20.1.1　简单值　　562\n20.1.2　对象　　563\n20.1.3　数组　　564\n20.2　解析与序列化　　565\n20.2.1　JSON对象　　565\n20.2.2　序列化选项　　566\n20.2.3　解析选项　　569\n20.3　小结　　570\n第21章　Ajax与Comet　　571\n21.1　XMLHttpRequest对象　　571\n21.1.1　XHR的用法　　573\n21.1.2　HTTP头部信息　　575\n21.1.3　GET请求　　576\n21.1.4　POST请求　　577\n21.2　XMLHttpRequest 2级　　578\n21.2.1　FormData　　578\n21.2.2　超时设定　　579\n21.2.3　overrideMimeType()\n方法　　580\n21.3　进度事件　　580\n21.3.1　load事件　　580\n21.3.2　progress事件　　581\n21.4　跨源资源共享　　582\n21.4.1　IE对CORS的实现　　582\n21.4.2　其他浏览器对CORS的\n实现　　584\n21.4.3　Preflighted Reqeusts　　584\n21.4.4　带凭据的请求　　585\n21.4.5　跨浏览器的CORS　　585\n21.5　其他跨域技术　　586\n21.5.1　图像Ping　　586\n21.5.2　JSONP　　587\n21.5.3　Comet　　588\n21.5.4　服务器发送事件　　590\n21.5.5　Web Sockets　　591\n21.5.6　SSE与Web Sockets　　593\n21.6　安全　　593\n21.7　小结　　594\n第22章　高级技巧　　596\n22.1　高级函数　　596\n22.1.1　安全的类型检测　　596\n22.1.2　作用域安全的构造函数　　597\n22.1.3　惰性载入函数　　600\n22.1.4　函数绑定　　602\n22.1.5　函数柯里化　　604\n22.2　防篡改对象　　606\n22.2.1　不可扩展对象　　606\n22.2.2　密封的对象　　607\n22.2.3　冻结的对象　　608\n22.3　高级定时器　　609\n22.3.1　重复的定时器　　610\n22.3.2　Yielding Processes　　612\n22.3.3　函数节流　　614\n22.4　自定义事件　　616\n22.5　拖放　　618\n22.5.1　修缮拖动功能　　620\n22.5.2　添加自定义事件　　622\n22.6　小结　　624\n第23章　离线应用与客户端存储　　626\n23.1　离线检测　　626\n23.2　应用缓存　　627\n23.3　数据存储　　628\n23.3.1　Cookie　　629\n23.3.2　IE用户数据　　637\n23.3.3　Web存储机制　　638\n23.3.4　IndexedDB　　643\n23.4　小结　　654\n第24章　最佳实践　　656\n24.1　可维护性　　656\n24.1.1　什么是可维护的代码　　656\n24.1.2　代码约定　　657\n24.1.3　松散耦合　　659\n24.1.4　编程实践　　662\n24.2　性能　　666\n24.2.1　注意作用域　　666\n24.2.2　选择正确方法　　667\n24.2.3　最小化语句数　　672\n24.2.4　优化DOM交互　　673\n24.3　部署　　676\n24.3.1　构建过程　　676\n24.3.2　验证　　677\n24.3.3　压缩　　679\n24.4　小结　　681\n第25章　新兴的API　　682\n25.1　requestAnimationFrame()　　682\n25.1.1　早期动画循环　　682\n25.1.2　循环间隔的问题　　683\n25.1.3　mozRequestAnimation-Frame　　683\n25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685\n25.2　Page Visibility API　　686\n25.3　Geolocation API　　687\n25.4　File API　　689\n25.4.1　FileReader类型　　690\n25.4.2　读取部分内容　　692\n25.4.3　对象URL　　693\n25.4.4　读取拖放的文件　　694\n25.4.5　使用XHR上传文件　　695\n25.5　Web计时　　696\n25.6　Web Workers　　697\n25.6.1　使用Worker　　697\n25.6.2　Worker全局作用域　　698\n25.6.3　包含其他脚本　　699\n25.6.4　Web Workers的未来　　700\n25.7　小结　　700\n附录A　ECMAScript Harmony　　701\n附录B　严格模式　　717\n附录C　JavaScript库　　723\n附录D　JavaScript工具　　727\n",
    "pages": "748",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s8958650.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s8958650.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s8958650.jpg"
    },
    "alt": "https://book.douban.com/subject/10546125/",
    "id": "10546125",
    "publisher": "人民邮电出版社",
    "isbn10": "7115275793",
    "isbn13": "9787115275790",
    "title": "JavaScript高级程序设计（第3版）",
    "url": "https://api.douban.com/v2/book/10546125",
    "alt_title": "Professional JavaScript for Web",
    "author_intro": "作者简介：\nNicholas C. Zakas（尼古拉斯•泽卡斯）世界顶级Web技术专家，现为雅虎公司界面呈现架构师，负责My Yahoo!和雅虎首页等大访问量站点的设计。尼古拉斯拥有丰富的Web开发和界面设计经验，曾经参与许多世界级大公司的Web解决方案开发。他还是High Performance JavaScript一书的作者，并与他人合作撰写了Professional Ajax和Even Faster Web Sites。尼古拉斯拥有梅里马克学院计算机科学学士学位和埃迪柯特学院的MBA学位。他的个人网站是www.nczonline.net，他的Twitter别名是@slicknet。",
    "summary": "本书是JavaScript 超级畅销书的最新版。ECMAScript 5 和HTML5 在标准之争中双双胜出，使大量专有实现和客户端扩展正式进入规范，同时也为JavaScript 增添了很多适应未来发展的新特性。本书这一版除增加5 章全新内容外，其他章节也有较大幅度的增补和修订，新内容篇幅约占三分之一。全书从JavaScript 语言实现的各个组成部分——语言核心、DOM、BOM、事件模型讲起，深入浅出地探讨了面向对象编程、Ajax 与Comet 服务器端通信，HTML5 表单、媒体、Canvas（包括WebGL）及Web Workers、地理定位、跨文档传递消息、客户端存储（包括IndexedDB）等新API，还介绍了离线应用和与维护、性能、部署相关的最佳开发实践。本书附录展望了未来的API 和ECMAScript Harmony 规范。\n本书适合有一定编程经验的Web 应用开发人员阅读，也可作为高校及社会实用技术培训相关专业课程的教材。",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "99.00元"
  },
  "9787115352460": {
    "rating": { "max": 10, "numRaters": 134, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": [
      "[美] Mike Cantelon",
      "[美] TJ Holowaychuk",
      "[美] Nathan Rajlich"
    ],
    "pubdate": "2014-5",
    "tags": [
      { "count": 137, "name": "Node.js", "title": "Node.js" },
      { "count": 72, "name": "JavaScript", "title": "JavaScript" },
      { "count": 54, "name": "nodejs", "title": "nodejs" },
      { "count": 42, "name": "web开发", "title": "web开发" },
      { "count": 42, "name": "node.js", "title": "node.js" },
      { "count": 38, "name": "前端开发", "title": "前端开发" },
      { "count": 34, "name": "编程", "title": "编程" },
      { "count": 22, "name": "node", "title": "node" }
    ],
    "origin_title": "Node.js in Action",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27264241.jpg",
    "binding": "平装",
    "translator": ["吴海星"],
    "catalog": "第一部分　Node基础\n第1章　欢迎进入Node.js世界　　2\n1.1　构建于JavaScript之上　　3\n1.2　异步和事件触发：浏览器　　4\n1.3　异步和事件触发：服务器　　5\n1.4　DIRT程序　　6\n1.5　默认DIRT　　8\n1.5.1　简单的异步程序　　9\n1.5.2　Hello World HTTP服务器　　10\n1.5.3　流数据　　10\n1.6　小结　　11\n第2章　构建有多个房间的聊天室程序　　12\n2.1　程序概览　　12\n2.2　程序需求及初始设置　　15\n2.2.1　提供HTTP和WebSocket服务　　15\n2.2.2　创建程序的文件结构　　16\n2.2.3　指明依赖项　　16\n2.2.4　安装依赖项　　17\n2.3　提供HTML、CSS和客户端JavaScript的服务　　18\n2.3.1　创建静态文件服务器　　19\n2.3.2　添加HTML和CSS文件　　21\n2.4　用Socket.IO处理与聊天相关的消息　　23\n2.4.1　设置Socket.IO服务器　　24\n2.4.2　处理程序场景及事件　　25\n2.5　在程序的用户界面上使用客户端JavaScript　　29\n2.5.1　将消息和昵称/房间变更请求传给服务器　　29\n2.5.2　在用户界面中显示消息及可用房间　　30\n2.6　小结　　34\n第3章　Node编程基础　　35\n3.1　Node功能的组织及重用　　36\n3.1.1　创建模块　　37\n3.1.2　用module.exports微调模块的创建　　39\n3.1.3　用node_modules重用模块　　40\n3.1.4　注意事项　　41\n3.2　异步编程技术　　42\n3.2.1　用回调处理一次性事件　　43\n3.2.2　用事件发射器处理重复性事件　　46\n3.2.3　异步开发的难题　　53\n3.3　异步逻辑的顺序化　　54\n3.3.1　什么时候使用串行流程控制　　55\n3.3.2　实现串行化流程控制　　56\n3.3.3　实现并行化流程控制　　58\n3.3.4　利用社区里的工具　　60\n3.4　小结　　61\n第二部分　用Node开发Web程序\n第4章　构建Node Web程序　　64\n4.1　HTTP服务器的基础知识　　64\n4.1.1　Node如何向开发者呈现HTTP请求　　65\n4.1.2　一个用“Hello World”做响应的HTTP服务器　　67\n4.1.3　读取请求头及设定响应头　　67\n4.1.4　设定HTTP响应的状态码　　67\n4.2　构建RESTful Web服务　　68\n4.2.1　用POST请求创建资源　　69\n4.2.2　用GET请求获取资源　　71\n4.2.3　用DELETE请求移除资源　　72\n4.3　提供静态文件服务　　73\n4.3.1　创建一个静态文件服务器　　73\n4.3.2　处理服务器错误　　77\n4.3.3　用fs.stat()实现先发制人的错误处理　　77\n4.4　从表单中接受用户输入　　78\n4.4.1　处理提交的表单域　　78\n4.4.2　用formidable处理上传的文件　　81\n4.4.3　计算上传进度　　84\n4.5　用HTTPS加强程序的安全性　　85\n4.6　小结　　86\n第5章　存储Node程序中的数据　　87\n5.1　无服务器的数据存储　　88\n5.1.1　内存存储　　88\n5.1.2　基于文件的存储　　88\n5.2　关系型数据库管理系统　　91\n5.2.1　MySQL　　91\n5.2.2　PostgreSQL　　99\n5.3　NoSQL数据库　　100\n5.3.1　Redis　　101\n5.3.2　MongoDB　　105\n5.3.3　Mongoose　　107\n5.4　小结　　109\n第6章　Connect　　110\n6.1　搭建一个Connect程序　　111\n6.2　Connect的工作机制　　112\n6.2.1　做日志的中间件　　112\n6.2.2　响应“hello world”的中间件　　113\n6.3　为什么中间件的顺序很重要　　114\n6.3.1　中间件什么时候不调用next()　　114\n6.3.2　用中间件的顺序执行认证　　115\n6.4　挂载中间件和服务器　　115\n6.4.1　认证中间件　　116\n6.4.2　显示管理面板的中间件　　117\n6.5　创建可配置中间件　　118\n6.5.1　创建可配置的logger中间件组件　　119\n6.5.2　构建路由中间件组件　　120\n6.5.3　构建一个重写URL的中间件组件　　122\n6.6　使用错误处理中间件　　123\n6.6.1　Connect的默认错误处理器　　124\n6.6.2　自行处理程序错误　　124\n6.6.3　使用多个错误处理中间件组件　　125\n6.7　小结　　129\n第7章　Connect自带的中间件　　130\n7.1　解析cookie、请求主体和查询字符串的中间件　　131\n7.1.1　cookieParser()：解析HTTP cookie　　131\n7.1.2　bodyParser()：解析请求主体　　134\n7.1.3　limit()：请求主体的限制　　135\n7.1.4　query()：查询字符串解析　　137\n7.2　实现Web程序核心功能的中间件　　138\n7.2.1　logger()：记录请求　　138\n7.2.2　favicon()：提供favicon　　140\n7.2.3　methodOverride()：伪造HTTP方法　　141\n7.2.4　vhost()：虚拟主机　　143\n7.2.5　session()：会话管理　　144\n7.3　处理Web程序安全的中间件　　148\n7.3.1　basicAuth()：HTTP基本认证　　148\n7.3.2　csrf()：跨站请求伪造防护　　150\n7.3.3　errorHandler()：开发错误处理　　150\n7.4　提供静态文件服务的中间件　　152\n7.4.1　static()：静态文件服务　　152\n7.4.2　compress()：压缩静态文件　　154\n7.4.3　directory()：目录列表　　156\n7.5　小结　　157\n第8章　Express　　158\n8.1　生成程序骨架　　160\n8.1.1　安装Express的可执行程序　　161\n8.1.2　生成程序　　162\n8.1.3　探索程序　　162\n8.2　配置Express和你的程序　　164\n8.3　渲染视图　　166\n8.3.1　视图系统配置　　167\n8.3.2　视图查找　　169\n8.3.3　把数据输出到视图中　　171\n8.4　处理表单和文件上传　　175\n8.4.1　实现照片模型　　175\n8.4.2　创建照片上传表单　　176\n8.4.3　显示上传照片列表　　178\n8.5　创建资源下载　　179\n8.5.1　创建照片下载路由　　179\n8.5.2　实现照片下载路由　　180\n8.6　小结　　182\n第9章　Express进阶　　183\n9.1　认证用户　　184\n9.1.1　保存和加载用户　　184\n9.1.2　注册新用户　　189\n9.1.3　已注册用户登录　　194\n9.1.4　用户加载中间件　　197\n9.2　先进的路由技术　　199\n9.2.1　校验用户内容提交　　199\n9.2.2　特定路由中间件　　202\n9.2.3　实现分页　　205\n9.3　创建一个公开的REST API　　208\n9.3.1　设计API　　208\n9.3.2　添加基本的认证　　209\n9.3.3　实现路由　　209\n9.3.4　启用内容协商　　212\n9.4　错误处理　　214\n9.4.1　处理404错误　　215\n9.4.2　处理错误　　217\n9.5　小结　　220\n第10章　测试Node程序　　221\n10.1　单元测试　　222\n10.1.1　assert模块　　222\n10.1.2　Nodeunit　　225\n10.1.3　Mocha　　227\n10.1.4　Vows　　232\n10.1.5　should.js　　234\n10.2　验收测试　　235\n10.2.1　Tobi　　236\n10.2.2　Soda　　237\n10.3　小结　　239\n第11章　Web程序模板　　240\n11.1　用模板保持代码的整洁性　　240\n11.2　嵌入JavaScript的模板　　244\n11.2.1　创建模板　　245\n11.2.2　用EJS过滤器处理模板数据　　246\n11.2.3　将EJS集成到你的程序中　　249\n11.2.4　在客户端程序中使用EJS　　250\n11.3　使用Mustache模板语言与Hogan　　251\n11.3.1　创建模板　　251\n11.3.2　Mustache标签　　252\n11.3.3　微调Hogan　　254\n11.4　用Jade做模板　　255\n11.4.1　Jade基础知识　　256\n11.4.2　Jade模板中的逻辑　　258\n11.4.3　组织Jade模板　　260\n11.5　小结　　264\n第三部分　在Node中更进一步\n第12章　部署Node程序并维持正常运行时间　　266\n12.1　安置Node程序　　266\n12.1.1　专用的和虚拟私有服务器　　267\n12.1.2　云主机　　268\n12.2　部署的基础知识　　269\n12.2.1　从Git存储库部署　　270\n12.2.2　让Node保持运行　　270\n12.3　让正常运行时间和性能达到最优　　271\n12.3.1　用Upstart维护正常运行时间　　272\n12.3.2　集群API：利用多核的优势　　273\n12.3.3　静态文件及代理　　275\n12.4　小结　　277\n第13章　超越Web服务器　　278\n13.1　Socket.IO　　278\n13.1.1　创建一个最小的Socket.IO程序　　279\n13.1.2　用Socket.IO触发页面和CSS的重新加载　　281\n13.1.3　Socket.IO的其他用法　　283\n13.2　深入TCP/IP网络　　284\n13.2.1　处理缓冲区和二进制数据　　284\n13.2.2　创建TCP服务器　　286\n13.2.3　创建TCP客户端　　289\n13.3　跟操作系统交互的工具　　290\n13.3.1　单例的全局process对象　　291\n13.3.2　使用文件系统模块　　293\n13.3.3　繁衍外部进程　　296\n13.4　开发命令行工具　　301\n13.4.1　解析命令行参数　　301\n13.4.2　处理stdin和stdout　　302\n13.4.3　添加彩色的输出　　304\n13.5　小结　　306\n第14章　Node生态系统　　307\n14.1　给Node开发人员的在线资源　　308\n14.1.1　Node和模块的参考资料　　308\n14.1.2　Google群组　　309\n14.1.3　IRC　　309\n14.1.4　GitHub问题列表　　310\n14.2　GitHub　　310\n14.2.1　GitHub入门　　311\n14.2.2　添加一个项目到GitHub中　　312\n14.2.3　用GitHub协作　　314\n14.3　为npm库做贡献　　316\n14.3.1　准备包　　317\n14.3.2　编写包规范　　317\n14.3.3　测试和发布包　　318\n14.4　小结　　320\n附录A　安装Node和社区附加组件　　321\n附录B　调试Node　　329\n附录C　Express的扩展及配置　　336",
    "ebook_url": "https://read.douban.com/ebook/14300777/",
    "pages": "356",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27264241.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27264241.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27264241.jpg"
    },
    "alt": "https://book.douban.com/subject/25870705/",
    "id": "25870705",
    "publisher": "人民邮电出版社",
    "isbn10": "7115352461",
    "isbn13": "9787115352460",
    "title": "Node.js实战",
    "url": "https://api.douban.com/v2/book/25870705",
    "alt_title": "Node.js in Action",
    "author_intro": "作者简介：\nMike Cantelon\nNode.js核心框架贡献者、Node社区活跃分子、资深培训师和演讲人。\nMarc Harter\nNode.js核心框架贡献者。\nT.J. Holowaychuk\n参与开发了很多Node.js模块，包括流行的Express框架。\nNathan Rajlich\n大名鼎鼎的TooTallNate，Node.js核心代码提交者。\n译者简介：\n吴海星\n2001年毕业于南京理工大学。编程数载代码不过几十万，翻译几年码字不过几百万。项目不过十几个，带队不到五十人。年过而立，惴惴不安，愈加发奋，孜孜求学，愿凭绵薄之力，贡献于IT社区。",
    "summary": "服务器端JavaScript？没错。Node.js是一个JavaScript服务器，支持可伸缩的高性能Web应用。借助异步I/O，这个服务器可以同时做很多事情，能满足聊天、游戏和实时统计等应用的需求。并且既然是JavaScript，那你就可以全栈使用一种语言。\n本书向读者展示了如何构建产品级应用，对关键概念的介绍清晰明了，贴近实际的例子，涵盖从安装到部署的各个环节，是一部讲解与实践并重的优秀著作。通过学习本书，读者将深入异步编程、数据存储、输出模板、读写文件系统，掌握创建TCP/IP服务器和命令行工具等非HTTP程序的技术。本书同样非常适合熟悉Rails、Django或PHP开发的读者阅读学习。\n本书主要内容：\nNode.js及其扩展的安装配置；\n全面理解异步编程和事件循环；\n学会开发微博、聊天和游戏等热门应用。",
    "ebook_price": "29.99",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "69.00元"
  },
  "9787115447739": {
    "rating": { "max": 10, "numRaters": 11, "average": "7.5", "min": 0 },
    "subtitle": "",
    "author": ["[保] Stoyan Stefanov"],
    "pubdate": "2017-3",
    "tags": [
      { "count": 8, "name": "React", "title": "React" },
      { "count": 4, "name": "JavaScript", "title": "JavaScript" },
      { "count": 2, "name": "编程", "title": "编程" },
      { "count": 2, "name": "web前端", "title": "web前端" },
      { "count": 1, "name": "计算机", "title": "计算机" },
      { "count": 1, "name": "前端开发", "title": "前端开发" },
      { "count": 1, "name": "前端", "title": "前端" },
      { "count": 1, "name": "front-end", "title": "front-end" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29346834.jpg",
    "binding": "平装",
    "translator": ["张俊达"],
    "catalog": "译者序　　xiii\n前言　　xv\n第1章　Hello World　　1\n1.1　设置　　1\n1.2　Hello React World　　2\n1.3　刚才发生了什么　　4\n1.4　React.DOM.*　　4\n1.5　特殊DOM属性　　7\n1.6　React DevTools浏览器扩展　　8\n1.7　下一步：自定义组件　　9\n第2章　组件的生命周期　　10\n2.1　基础　　10\n2.2 　属性　　12\n2.3　propTypes　　13\n2.4　state　　16\n2.5　带状态的文本框组件　　16\n2.6　关于DOM事件的说明　　19\n2.6.1　传统的事件处理　　20\n2.6.2　React的事件处理　　21\n2.7　props与state　　21\n2.8　在初始化state时使用props：一种反模式　　22\n2.9　从外部访问组件　　22\n2.10　中途改变属性　　24\n2.11　生命周期方法　　25\n2.12　生命周期示例：输出日志记录　　26\n2.13　生命周期示例：使用mixin　　28\n2.14　生命周期示例：使用子组件　　30\n2.15　性能优化：避免组件更新　　32\n2.16　PureRenderMixin　　34\n第3章　Excel：一个出色的表格组件　　37\n3.1　构造数据　　37\n3.2　表头循环　　38\n3.3　消除控制台的警告信息　　40\n3.4　添加<td>内容　　41\n3.5　排序　　44\n3.6　排序的视觉提示　　46\n3.7　编辑数据　　47\n3.7.1　可编辑单元格　　48\n3.7.2　输入字段的单元格　　50\n3.7.3　保存　　50\n3.7.4　结论与虚拟DOM Diff算法　　51\n3.8　搜索　　52\n3.8.1　状态与界面　　54\n3.8.2　筛选内容　　55\n3.8.3　如何改进搜索功能　　57\n3.9　即时回放　　58\n3.9.1　如何改进回放功能　　59\n3.9.2　有另一种实现方法吗　　59\n3.10　下载表格数据　　59\n第4章　JSX　　62\n4.1　Hello JSX　　62\n4.2　转译JSX　　63\n4.3　Babel　　64\n4.4　客户端　　64\n4.5　关于JSX转换　　66\n4.6　在JSX中使用JavaScript　　68\n4.7　在JSX中使用空格　　69\n4.8　在JSX中使用注释　　70\n4.9　HTML实体　　71\n4.10　展开属性　　73\n4.11　在JSX中返回多个节点　　75\n4.12　JSX和HTML的区别　　77\n4.12.1　class和for属性不能用了吗　　77\n4.12.2　style属性值是一个对象　　77\n4.12.3　闭合标签　　78\n4.12.4　用驼峰法命名属性　　78\n4.13　JSX 和表单　　78\n4.13.1　onChange处理器　　78\n4.13.2　value和defaultValue的区别　　79\n4.13.3　<textarea>的值　　79\n4.13.4　<select>的值　　80\n4.14　使用JSX实现Excel组件　　82\n第5章　为应用开发做准备　　83\n5.1　一个模板应用　　83\n5.1.1　文件和目录　　84\n5.1.2　index.html　　85\n5.1.3　CSS　　86\n5.1.4　JavaScript　　86\n5.1.5　更现代化的JavaScript　　86\n5.2　安装必备工具　　89\n5.2.1　Node.js　　90\n5.2.2　Browserify　　90\n5.2.3　Babel　　90\n5.2.4　React相关　　91\n5.3　开始构建　　91\n5.3.1　转译JavaScript　　91\n5.3.2　打包JavaScript　　92\n5.3.3　打包CSS　　92\n5.3.4　大功告成　　92\n5.3.5　Windows版本　　93\n5.3.6　在开发过程中构建　　93\n5.4　发布　　94\n5.5　更进一步　　95\n第6章　构建应用　　96\n6.1　Whinepad v. 0.0.1　　96\n6.1.1 　基本设置　　97\n6.1.2 　开始编写代码　　97\n6.2　组件　　99\n6.2.1　设置　　99\n6.2.2　组件发现工具　　100\n6.2.3　<Button>组件　　101\n6.2.4　Button.css　　102\n6.2.5　Button.js　　103\n6.2.6　表单　　106\n6.2.7　<Suggest>　　106\n6.2.8　<Rating>组件　　109\n6.2.9　<FormInput>“工厂组件”　　112\n6.2.10　<Form>　　115\n6.2.11　<Actions>　　117\n6.2.12　对话框　　119\n6.3　应用配置　　121\n6.4　<Excel>：改进的新版本　　123\n6.5　<Whinepad>　　131\n6.6　总结　　134\n第7章　lint、Flow、测试与复验　　136\n7.1　package.json　　136\n7.1.1　配置Babel　　137\n7.1.2　脚本　　137\n7.2　ESLint138\n7.2.1　安装　　138\n7.2.2　运行　　138\n7.2.3　规则列表　　140\n7.3　Flow　　140\n7.3.1　安装　　141\n7.3.2　运行　　141\n7.3.3　注册类型检查　　141\n7.3.4　修复<Button>　　142\n7.3.5　app.js　　144\n7.3.6　关于props和state类型检查的更多内容145\n7.3.7　导出/导入类型　　147\n7.3.8　类型转换　　148\n7.3.9　invariant　　148\n7.4　测试　　150\n7.4.1　安装　　150\n7.4.2　首个测试　　151\n7.4.3　首个React测试　　152\n7.4.4　测试<Button>组件　　153\n7.4.5　测试<Actions>组件　　157\n7.4.6　更多模拟交互　　159\n7.4.7　测试完整的交互　　160\n7.4.8　代码覆盖率　　163\n第8章　Flux　　165\n8.1　理念　　166\n8.2　回顾Whinepad　　166\n8.3　Store　　167\n8.3.1　Store事件　　169\n8.3.2　在<Whinepad>中使用Store　　170\n8.3.3　在<Excel>中使用Store　　173\n8.3.4　在<Form>中使用Store　　174\n8.3.5　界定　　174\n8.4　Action　　175\n8.4.1　CRUD Action　　175\n8.4.2　搜索与排序　　176\n8.4.3　在<Whinepad>中使用Action　　178\n8.4.4　在<Excel>中使用Action　　179\n8.5　Flux回顾181\n8.6　immutable　　182\n8.6.1　immutable存储数据　　183\n8.6.2　immutable数据操作　　184\n关于作者　　187\n关于封面　　187\n",
    "pages": "208",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29346834.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29346834.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29346834.jpg"
    },
    "alt": "https://book.douban.com/subject/26975465/",
    "id": "26975465",
    "publisher": "人民邮电出版社",
    "isbn10": "711544773X",
    "isbn13": "9787115447739",
    "title": "React快速上手开发",
    "url": "https://api.douban.com/v2/book/26975465",
    "alt_title": "",
    "author_intro": "作者简介：\nStoyan Stefanov\nFacebook开发工程师，图像优化工具smush.it的作者，性能优化工具YSlow2.0的架构师。曾多次在Velocity等技术大会上发表过演讲。另著有《JavaScript模式》和《JavaScript面向对象编程指南》，还为《高性能网站建设进阶指南》和《高性能JavaScript》贡献过内容。个人站点是http://phpied.com。\n译者简介：\n张俊达\n毕业于华南理工大学，前端开发工程师，现任职于迅雷，主要负责移动Web开发工作。关注前端领域的新技术，乐于分享。",
    "summary": "本书旨在帮你掌握Facebook的开源技术React，迅速建立富Web应用，构建组件并将其组织成可维护的大型应用程序。\n解开Web应用开发之谜，从了解React基本原理开始。\n* 设置React并编写第一个Hello World应用\n* 创建并使用自定义React组件以及通用DOM组件\n* 构建一个可以编辑、排序、搜索和导出内容的数据表格组件\n* 使用JSX语法扩展作为调用函数的替代选择\n* 设置一个帮你集中注意力于React上的简单构建过程\n* 构建一个可以将数据存储在客户端的完整自定义应用\n* 在应用规模增长时使用ESLint、Flow和Jest等工具检查并测试代码\n* 使用Flux管理组件间的通信",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "49.00元"
  },
  "9787111488323": {
    "rating": { "max": 10, "numRaters": 49, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["Jos Dirksen"],
    "pubdate": "2015-3",
    "tags": [
      { "count": 69, "name": "three.js", "title": "three.js" },
      { "count": 44, "name": "webgl", "title": "webgl" },
      { "count": 31, "name": "3d", "title": "3d" },
      { "count": 30, "name": "JavaScript", "title": "JavaScript" },
      { "count": 25, "name": "前端", "title": "前端" },
      { "count": 23, "name": "web3D", "title": "web3D" },
      { "count": 18, "name": "js", "title": "js" },
      { "count": 15, "name": "three", "title": "three" }
    ],
    "origin_title": "Learning Three.js:The JavaScript 3D Library for WebGL",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28031805.jpg",
    "binding": "平装",
    "translator": ["李鹏程"],
    "catalog": "前　言\n致　谢\n第1章用Three.js创建你的第一个三维场景1\n1.1　使用Three.js的前提条件3\n1.2　获取源代码4\n1.2.1　用Git克隆代码仓库4\n1.2.2　下载并解压压缩包5\n1.2.3　测试示例6\n1.3　创建HTML页面框架7\n1.4　渲染并展示三维对象9\n1.5　添加材质、灯光和阴影13\n1.6　用动画扩展你的首个场景15\n1.6.1　引入requestAnimation-Frame()方法15\n1.6.2　转动方块17\n1.6.3　弹跳球17\n1.7　使用dat.GUI库简化试验18\n1.8　使用ASCII效果19\n1.9　总结20\n第2章使用构建Three.js场景的基本组件22\n2.1　创建场景22\n2.1.1　场景的基本功能23\n2.1.2　在场景中添加雾化效果27\n2.1.3　使用材质覆盖属性28\n2.2　使用几何和网格对象29\n2.2.1　几何对象的属性和函数29\n2.2.2　网格对象的函数和属性33\n2.3　选择合适的相机37\n2.3.1　正投影相机和透视相机37\n2.3.2　让相机在指定点上聚焦41\n2.4　总结41\n第3章使用Three.js里的各种光源43\n3.1　探索Three.js库提供的光源43\n3.2　学习基础光源44\n3.2.1　AmbientLight—影响整个场景的光源44\n3.2.2　PointLight—照射所有方向的光源47\n3.2.3　SpotLight—具有锥形效果的光源49\n3.2.4　DirectinalLight—模拟远处类似太阳的光源53\n3.2.5　使用特殊光源生成高级光照效果54\n3.3　总结61\n第4章使用Three.js的材质62\n4.1　理解共有属性63\n4.1.1　基础属性63\n4.1.2　融合属性64\n4.1.3　高级属性64\n4.2　从简单的网格材质（基础、深度和面）开始65\n4.2.1　简单表面的MeshBasic-Material65\n4.2.2　基于深度着色的MeshDepthMaterial67\n4.2.3　联合材质68\n4.2.4　计算法向颜色的MeshNormalMaterial70\n4.2.5　为每个面指定材质的MeshFaceMaterial72\n4.3　学习高级材质73\n4.3.1　用于暗淡、不光亮表面的MeshLambertMaterial74\n4.3.2　用于光亮表面的MeshPhongMaterial75\n4.3.3　用ShaderMaterial创建自己的着色器76\n4.4　线段几何体的材质81\n4.4.1　LineBasicMaterial81\n4.4.2　LineDashedMaterial83\n4.5　总结84\n第5章学习使用几何体85\n5.1　Three.js提供的基础几何体86\n5.1.1　二维几何体86\n5.1.2　三维几何体92\n5.2　总结100\n第6章使用高级几何体和二元操作102\n6.1　ConvexGeometry102\n6.2　LatheGeometry104\n6.3　通过拉伸创建几何体105\n6.3.1　ExtrudeGeometry106\n6.3.2　TubeGeometry107\n6.3.3　从SVG拉伸109\n6.3.4　ParametricGeometry110\n6.4　创建三维文本112\n6.4.1　渲染文本113\n6.4.2　添加自定义字体114\n6.5　使用二元操作组合网格115\n6.5.1　subtract函数117\n6.5.2　intersect函数120\n6.5.3　union函数121\n6.6　总结121\n第7章粒子和粒子系统123\n7.1　理解粒子123\n7.2　粒子、粒子系统和BasicParticleMaterial125\n7.3　使用HTML5画布格式化粒子128\n7.3.1　在CanvasRenderer类里使用HTML5画布128\n7.3.2　在WebGLRenderer中使用HTML5画布129\n7.4　使用纹理格式化粒子131\n7.5　从高级几何体中创建粒子系统139\n7.6　总结141\n第8章创建、加载高级网格和几何体143\n8.1　几何体组合和合并143\n8.1.1　对象组合143\n8.1.2　将多个网格合并成一个网格145\n8.2　从外部资源中加载几何体147\n8.3　以Three.js的JSON格式保存和加载147\n8.3.1　保存和加载几何体147\n8.3.2　保存和加载场景149\n8.4　使用Blender151\n8.4.1　在Blender中安装Three.js导出器152\n8.4.2　在Blender里加载和导出模型153\n8.5　导入三维格式文件155\n8.5.1　OBJ和MTL格式156\n8.5.2　加载Collada模型159\n8.5.3　加载STL、CTM和VTK模型160\n8.5.4　展示蛋白质数据银行中的蛋白质161\n8.5.5　从PLY模型中创建粒子系统163\n8.6　总结164\n第9章创建动画和移动相机166\n9.1　基础动画166\n9.1.1简单动画167\n9.1.2　选择对象168\n9.1.3　用Tween.js做动画170\n9.2　使用相机172\n9.2.1　轨迹球控件172\n9.2.2　飞行控件174\n9.2.3　翻滚控件175\n9.2.4　第一人称控件175\n9.2.5　轨道控件177\n9.2.6　路径控件178\n9.3　变形动画和骨骼动画180\n9.3.1　用变形目标制作动画181\n9.3.2用骨骼和蒙皮制作动画184\n9.4使用外部模型创建动画186\n9.4.1　用Blender创建骨骼动画186\n9.4.2从Collada模型中加载动画190\n9.4.3从雷神之锤模型中加载动画191\n9.5总结192\n第10章加载和使用纹理194\n10.1在材质中使用纹理194\n10.1.1加载纹理并应用到网格194\n10.1.2使用凹凸贴图创建皱纹197\n10.1.3使用法向贴图创建更加细致的凹凸和皱纹198\n10.1.4使用光照贴图创建假阴影199\n10.1.5用环境贴图创建虚假的反光效果201\n10.1.6高光贴图204\n10.2纹理的高级用途205\n10.2.1定制UV映射205\n10.2.2重复映射207\n10.2.3在画布上绘制图案并作为纹理209\n10.3总结213\n第11章定制着色器和渲染后期处理215\n11.1设置后期处理215\n11.1.1创建EffectComposer对象216\n11.2后期处理通道218\n11.2.1简单后期处理通道218\n11.2.2　使用掩膜的高级效果组合器223\n11.2.3　用ShaderPass定制效果226\n11.3　创建自定义的后期处理着色器231\n11.3.1　定制灰度图着色器232\n11.3.2　定制位着色器235\n11.4　总结237\n第12章用Physijs在场景中添加物理效果238\n12.1　创建可用Physijs的基本Three.js场景238\n12.2　材质属性243\n12.3　基础图形244\n12.4　使用约束限制对象移动248\n12.4.1　用PointConstraint限制两点间的移动249\n12.4.2　用HingeConstraint创建类似门的约束250\n12.4.3　用SliderConstraint将移动限制到一个轴252\n12.4.4　用ConeTwistConstraint创建类似球销的约束254\n12.4.5　用DOFConstraint实现细节的控制255\n12.5　总结259",
    "ebook_url": "https://read.douban.com/ebook/29672278/",
    "pages": "",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28031805.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28031805.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28031805.jpg"
    },
    "alt": "https://book.douban.com/subject/26349497/",
    "id": "26349497",
    "publisher": "机械工业出版社",
    "isbn10": "7111488326",
    "isbn13": "9787111488323",
    "title": "Three.js开发指南",
    "url": "https://api.douban.com/v2/book/26349497",
    "alt_title": "Learning Three.js:The JavaScript 3D Library for WebGL",
    "author_intro": "",
    "summary": "首部全面讲解Three.js开发的实用指南，循序渐进讲解Three.js的各种功能，通过大量交互示例，深入探索使用开源的Three.js库创建绚丽三维图形的实用方法和技巧。\n在过去的两年里，浏览器变得更加强大了，而且能够作为平台来运行复杂的应用和图形。但大部分的图形都是二维的。现在大部分的浏览器已经实现了WebGL，它们不仅可以创建二维图形和应用，还可以充分利用GPU，创建漂亮的、高性能的三维应用。\n直接使用WebGL编程非常复杂。你需要了解WebGL的内部细节，学习复杂的着色器语法，才能用好WebGL。Three.js库提供了一套基于WebGL的、非常易用的JavaScript API，这样你不必学习WebGL的细节就可以创建漂亮的三维图形。\nThree.js库提供了大量功能和API，你可以通过它们直接在浏览器中创建三维场景。本书提供了大量的交互式示例和代码，从中你可以学习到Three.js提供的所有API。\n本书内容\n第1章讲述使用Three.js库的基本步骤。到这章结束的时候，你就可以创建出第一个Three.js场景。你可以直接在浏览器中创建三维场景，并制作动画。\n第2章将会讲解Three.js库使用过程中你所需要理解的基础组件。你将会学习使用光源、网格、几何体、材质和相机。通过这章你会对Three.js库提供的各种光源及场景中使用的相机有一个大体的了解。\n第3章进一步讲解场景中的各种光源。该章会展示几个例子，并解释如何使用各种光源，该章所介绍的光源包括：SpotLight、DirectionLight、AmbientLight、PointLight、HemisphereLight，以及AreaLight。另外，该章还展示如何在光源中应用LensFlare效果。\n第4章讨论Three.js库中可以用于网格的各种材质。这一章将会展示所有可以在材质中设置的属性，每种属性都有其特定的用途。并且这章还提供交互式的例子，通过它们你可以试验Three.js库中各种可用的材质。\n第5章开始探讨Three.js库中的各种几何体。在这一章里你会学习如何创建、设置Three.js里的几何体，而且你还可以通过交互式的示例来试验，该章介绍的几何体包括：平面、圆、自定义形状、方块、球体、圆柱体、圆环、环面纽结和多面体。\n第6章继续第5章未讲完的内容，展示如何设置、使用Three.js库中的高级几何体，例如凸面体和扫描体。该章将会介绍如何从二维几何体中拉出三维几何体，以及如何使用二元运算将几何体组合起来。\n第7章讲解如何使用Three.js库中的粒子系统。你将会学习如何从零开始创建粒子系统，以及如何基于已有的几何体创建粒子系统。你还会学习如何使用精灵和粒子材质来改变粒子的外观。\n第8章展示如何从外部源导入网格和几何体。你将会学习如何使用Three.js库的JSON格式来存储几何体和场景。这一章还解释了如何从OBJ、DAE、STL、CTM和PLY格式的文件中加载模型。\n第9章探讨各种动画效果，使场景活动起来。你将会学习如何结合Tween.js库使用Three.js，以及基于变形和骨骼的动画效果。\n第10章进一步展开讨论第4章引入的材质。这一章会深入讲解材质的细节。该章介绍了各种可用的材质，以及应用到网格上时如何控制材质。另外，在这一章你还会看到如何将HTML5视频的输出和HTML5画布中的元素作为纹理。\n第11章探讨如何使用Three.js库来对已经渲染过的场景进行后期处理。通过后期处理，你可以对已经渲染过的场景应用某些特效，如模糊、移轴、陈旧。另外，你还会学习如何创建自定义的后期处理效果，以及创建自定义顶点和片段着色器。\n第12章讲解如何在Three.js的场景中添加物理效果。有了物理效果后，你就可以检测物体之间的碰撞，使它们能够对重力产生反应，并产生摩擦。这一章将会展示如何使用JavaScript的物理库来达到上述效果。\n阅读之前的准备\n阅读本书你要准备的只是一个文本编辑器（例如Sublime文本编辑器），用来编辑示例，以及一个现代的浏览器，用来显示这些示例。有些示例需要一个本地的Web服务器，但是在第1章，你将会学习如何搭建一个非常轻量的Web服务器来使用本书中的示例。\n在我们开始之前，先对书中示例可能出现的问题简单提一下。第1章大致介绍了一下支持WebGL的浏览器，这是运行Three.js所必需的。现在的浏览器，诸如Chrome、Firefox和Internet Explorer可以很好地支持HTML5 标准。但是仍然有一些细节要注意。当浏览器有新的版本时，它们有可能会不支持WebGL的某些特性。例如，在本书完成的时候，Windows 7上的Chrome和Firefox在运行第11章的例子时会有问题。所以在尝试这些示例时，请确保升级到最新版的Chrome和Firefox。",
    "ebook_price": "25.00",
    "price": "59"
  },
  "9787121229428": {
    "rating": { "max": 10, "numRaters": 67, "average": "8.7", "min": 0 },
    "subtitle": "",
    "author": ["【美】Kouichi Matsuda,Rodger Lea（松田浩一，罗杰•李）"],
    "pubdate": "2014-6",
    "tags": [
      { "count": 58, "name": "webgl", "title": "webgl" },
      { "count": 44, "name": "WebGL", "title": "WebGL" },
      { "count": 41, "name": "3D", "title": "3D" },
      { "count": 33, "name": "前端开发", "title": "前端开发" },
      { "count": 30, "name": "JavaScript", "title": "JavaScript" },
      { "count": 18, "name": "计算机图形学", "title": "计算机图形学" },
      { "count": 17, "name": "计算机", "title": "计算机" },
      { "count": 17, "name": "图形学", "title": "图形学" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27306770.jpg",
    "binding": "平装",
    "translator": ["谢光磊"],
    "catalog": "第1 章 WebGL 概述...................... 1\nWebGL 的优势 ...........................................3\n使用文本编辑器开发三维应用 ...............3\n轻松发布三维图形程序 .................................4\n充分利用浏览器的功能 ...........................5\n学习和使用WebGL 很简单 ...................5\nWebGL 的起源 .................................................5\nWebGL 程序的结构 ...................................6\n总结 .....................................7\n第2 章 WebGL 入门.................... 9\nCanvas 是什么？ ........................................10\n使用<canvas> 标签 ................................11\nDrawRectangle.js .............................................13\n最短的WebGL 程序：清空绘图区 ....................16\nHTML 文件（HelloCanvas.html）.............................16\nJavaScript 程序（HelloCanvas.js） ............................17\n用示例程序做实验 ..............................................22\n绘制一个点（版本1） ............................................22\nHelloPoint1.html ..............................................24\nHelloPoint1.js ....................................................24\n着色器是什么？ ...........................................25\n使用着色器的WebGL 程序的结构 .................................27\n初始化着色器 ...........................................29\n顶点着色器 ......................................................31\n片元着色器 ...........................................33\n绘制操作 .............................................34\nWebGL 坐标系统 ....................................35\n用示例程序做实验 ................................37\n绘制一个点（版本2） ..............................38\n使用attribute 变量..................................38\n示例程序（HelloPoint2.js） .........................................39\n获取attribute 变量的存储位置.......................41\n向attribute 变量赋值.............................................42\ngl.vertexAttrib3f() 的同族函数 .........................44\n用示例程序做实验 ...............................45\n通过鼠标点击绘点 ...........................................46\n示例程序（ClickedPoints.js） ...........................47\n注册事件响应函数 ..................................48\n响应鼠标点击事件 ............................50\n用示例程序做实验 ..............................53\n改变点的颜色 ............................................55\n示例程序（ColoredPoints.js） ..............................56\nuniform 变量 ........................................58\n获取uniform 变量的存储地址 .....................59\n向uniform 变量赋值 .................................60\ngl.uniform4f() 的同族函数 .......................61\n总结 ............................62\n第3 章 绘制和变换三角形................ 63\n绘制多个点 ...............................................64\n示例程序（MultiPoint.js） ........................................66\n使用缓冲区对象 ....................................69\n创建缓冲区对象（gl.createBuffer()） ...................70\n绑定缓冲区（gl.bindBuffer()） .....................................71\n向缓冲区对象中写入数据（gl.bufferData()）..............72\n类型化数组 ........................................74\n将缓冲区对象分配给attribute 变量（gl.vertexAttribPointer()） ...............75\n开启attribute 变量（gl.enableVertexAttribArray()） ................77\ngl.drawArrays() 的第2 个和第3 个参数 .................78\n用示例程序做实验 ........................................79\nHello Triangle ..................................80\n示例程序（HelloTriangle.js） .........................80\n基本图形 .................................................82\n用示例程序做实验 ...........................83\nHello Rectangle（HelloQuad） ...........................84\n用示例程序做实验 ...................................85\n移动、旋转和缩放 ........................................86\n平移 ................................................87\n示例程序（TranslatedTriangle.js） ...........................88\n旋转 ...........................................................91\n示例程序（RotatedTriangle.js） ..................................93\n变换矩阵：旋转 ........................................97\n变换矩阵：平移 ...................................100\n4×4 的旋转矩阵 ..................................101\n示例程序（RotatedTriangle_Matrix.js） ...................102\n平移：相同的策略 ................................105\n变换矩阵：缩放 ...............................106\n总结 ...........................................................108\n第4 章 高级变换与动画基础.............................. 109\n平移，然后旋转 ...........................................109\n矩阵变换库：cuon-matrix.js ....................110\n示例程序（RotatedTriangle_Matrix4.js） ............... 111\n复合变换 .............................................113\n示例程序（RotatedTranslatedTriangle.js）.....................115\n用示例程序做实验 ..................................117\n动画 .....................................118\n动画基础 .........................................119\n示例程序（RotatingTriangle.js） .......................119\n反复调用绘制函数（tick()） ............................123\n按照指定的旋转角度绘制三角形（draw()） .............123\n请求再次被调用（requestAnimationFrame()） ............125\n更新旋转角（animate()）................................126\n用示例程序做实验 ............................128\n总结 .....................................................130\n第5 章 颜色与纹理.............. 131\n将非坐标数据传入顶点着色器 ................131\n示例程序（MultiAttributeSize.js） .....................133\n创建多个缓冲区对象 .........................134\ngl.vertexAttribPointer() 的步进和偏移参数 ...............135\n示例程序（MultiAttributeSize_Interleaved.js） ...................136\n修改颜色（varying 变量） .......................140\n示例程序（MultiAttributeColor.js） .........................141\n用示例程序做实验 .........................144\n彩色三角形（ColoredTriangle.js） ............................145\n几何形状的装配和光栅化 ................145\n调用片元着色器 ............................149\n用示例程序做实验 ..................................149\nvarying 变量的作用和内插过程 ..............151\n在矩形表面贴上图像 ...........................................153\n纹理坐标 ...................................................156\n将纹理图像粘贴到几何图形上 .....................156\n示例程序（TexturedQuad.js） ...............................157\n设置纹理坐标（initVertexBuffers()）......................160\n配置和加载纹理（initTextures()） ..................160\n为WebGL 配置纹理（loadTexture()） .............164\n图像Y 轴反转 .................................164\n激活纹理单元（gl.activeTexture()） ..................165\n绑定纹理对象（gl.bindTexture()） ..................166\n配置纹理对象的参数（gl.texParameteri()） .........168\n将纹理图像分配给纹理对象（gl.texImage2D()） .....171\n将纹理单元传递给片元着色器（gl.uniform1i()） .........173\n从顶点着色器向片元着色器传输纹理坐标 .......................174\n在片元着色器中获取纹理像素颜色（texture2D()） ..................174\n用示例程序做试验 ............................175\n使用多幅纹理 ...............................................177\n示例程序（MultiTexture.js） ............................178\n总结 .......................................................183\n第6 章 OpenGL ES 着色器语言（GLSL ES）.............. 185\n回顾：基本着色器代码 ...............................186\nGLSL ES 概述 .............................................186\n你好，着色器！ ...................................................187\n基础 ......................187\n执行次序 .........................................187\n注释 ..................................................187\n数据值类型（数值和布尔值） ......................188\n变量 .........................................................188\nGLSL ES 是强类型语言 ........................189\n基本类型 ....................................................189\n赋值和类型转换 .........................190\n运算符 ............................................191\n矢量和矩阵 .........................................192\n赋值和构造 ...............................193\n访问元素 .........................................195\n运算符 ............................................197\n结构体 .....................................................200\n赋值和构造 ...................................200\n访问成员 ...............................................200\n运算符 ...........................................201\n数组 ..........................................................201\n取样器（纹理） ........................................202\n运算符优先级 ..........................................203\n程序流程控制：分支和循环 .......................203\nif 语句和if-else 语句 ............................203\nfor 语句 .......................................204\ncontinue、break 和discard 语句 ................205\n函数 ..........................................205\n规范声明 ........................................207\n参数限定词 ........................................207\n内置函数 .................................................208\n全局变量和局部变量 ..............................209\n存储限定字 ...........................................209\nconst 变量 .....................................209\nAttribute 变量 ..............................210\nuniform 变量 ..................................211\nvarying 变量 ..................................211\n精度限定字 ..............................................211\n预处理指令 .............................................213\n总结 ......................................................215\n第7 章 进入三维世界................ 217\n立方体由三角形构成 .............................217\n视点和视线 ...........................................218\n视点、观察目标点和上方向 ........... 219\n示例程序（LookAtTriangles.js） ...........................221\nLookAtTriangles.js 与RotatedTriangle_Matrix4.js ..........224\n从指定视点观察旋转后的三角形 .....................225\n示例程序（LookAtRotatedTriangles.js） ...................227\n用示例程序做实验 .................................228\n利用键盘改变视点 .............................230\n示例程序（LookAtTrianglesWithKeys.js） .................230\n独缺一角 ......................................232\n可视范围（正射类型） .............................233\n可视空间 ..................................................234\n定义盒状可视空间 ................................235\n示例程序（OrthoView.html） ........................236\n示例程序（OrthoView.js） ...............................237\nJavaScript 修改HTML 元素 ..........................239\n顶点着色器的执行流程 ............................239\n修改near 和far 值 .............................241\n补上缺掉的角（LookAtTrianglesWithKeys_ViewVolume.js） ..........243\n用示例程序做实验 ................................245\n可视空间（透视投影） ....................................246\n定义透视投影可视空间 .......................247\n示例程序（perspectiveview.js） .........................249\n投影矩阵的作用 ...................................251\n共冶一炉（模型矩阵、视图矩阵和投影矩阵） .............252\n示例程序（PerspectiveView_mvp.js） ........................254\n用示例程序做实验 ................................257\n正确处理对象的前后关系 ............................258\n隐藏面消除 .....................................260\n示例程序（DepthBuffer.js）..............................262\n深度冲突 ................................................263\n立方体 ...........................................................266\n通过顶点索引绘制物体 ....................268\n示例程序（HelloCube.js） ...........................268\n向缓冲区中写入顶点的坐标、颜色与索引 ....................271\n为立方体的每个表面指定颜色 .............274\n示例程序（ColoredCube.js） ............................275\n用示例程序做实验 ............................277\n总结 ..............................................279\n第8 章 光照......... 281\n光照原理 ....................................................281\n光源类型 .......................................283\n反射类型 ............................................284\n平行光下的漫反射 ............................286\n根据光线和表面的方向计算入射角 .................287\n法线：表面的朝向 .............................288\n示例程序（LightedCube.js） ..........................291\n环境光下的漫反射 ...................................296\n示例程序（LightedCube_ambient.js） .........................298\n运动物体的光照效果 .....................................299\n魔法矩阵：逆转置矩阵 .....................301\n示例程序（LightedTranslatedRotatedCube.js） .....................302\n点光源光 ............................................304\n示例程序（PointLightedCube.js） ...............305\n更逼真：逐片元光照 ......................................308\n示例程序（PointLightedCube_perFragment.js） ........309\n总结 ............................310\n第9 章 层次模型.......... 311\n多个简单模型组成的复杂模型 .....................311\n层次结构模型 ..................................313\n单关节模型 ......................................314\n示例程序（JointMode.js） ................................315\n绘制层次模型（draw()） .....................319\n多节点模型 ..........................................321\n示例程序（MultiJointModel.js） .........................323\n绘制部件（drawBox()）............................326\n绘制部件（drawSegments()） .......................327\n着色器和着色器程序对象：initShaders() 函数的作用 .................332\n创建���色器对象（gl.createShader()） ..................333\n指定着色器对象的代码（gl.shaderSource()） ................334\n编译着色器（gl.compileShader()） ...............334\n创建程序对象（gl.createProgram()） ..............................336\n为程序对象分配着色器对象（gl.attachShader()） .............337\n连接程序对象（gl.linkProgram()） ..........................337\n告知WebGL 系统所使用的程序对象（gl.useProgram()） ................339\ninitShaders() 函数的内部流程 .....................................339\n总结 ...........................................................342\n第10 章 高级技术......................... 343\n用鼠标控制物体旋转 .......................................343\n如何实现物体旋转 ......................................344\n示例程序（RotateObject.js） .......................344\n选中物体 ........................................347\n如何实现选中物体 .........................................347\n示例程序（PickObject.js） .................................348\n选中一个表面 ......................................351\n示例程序（PickFace.js）...................................352\nHUD（平视显示器） .................................355\n如何实现HUD ...................................355\n示例程序（HUD.html） ..............................356\n示例程序（HUD.js）...................................357\n在网页上方显示三维物体 ....................359\n雾化（大气效果） ...................................359\n如何实现雾化 ....................................360\n示例程序（Fog.js） .....................................361\n使用w 分量（Fog_w.js） ...............................363\n绘制圆形的点 .................................................364\n如何实现圆形的点 ......................................364\n示例程序（RoundedPoint.js） ...............................366\nα 混合 .............................................367\n如何实现α 混合 .....................................367\n示例程序（LookAtBlendedTriangles.js） .................369\n混合函数 .....................................................369\n半透明的三维物体（BlendedCube.js）................371\n透明与不透明物体共存 .........................372\n切换着色器 ............................373\n如何实现切换着色器 .....................................374\n示例程序（ProgramObject.js） ............................375\n渲染到纹理 .......................................................379\n帧缓冲区对象和渲染缓冲区对象 ....................380\n如何实现渲染到纹理 ...............................381\n示例程序（FramebufferObject.js） ........................382\n创建帧缓冲区对象（gl.createFramebuffer()） ............385\n创建纹理对象并设置其尺寸和参数 ....................385\n创建渲染缓冲区对象（gl.createRenderbuffer()） ...........386\n绑定渲染缓冲区并设置其尺寸（gl.bindRenderbuffer()，\ngl.renderbufferStorage()） ......................................386\n将纹理对象关联到帧缓冲区对象（gl.bindFramebuffer()，\ngl.framebufferTexture2D()） ................................388\n将渲染缓冲区对象关联到帧缓冲区对象（gl.framebufferRenderbuffer()） ...389\n检查帧缓冲区的配置（gl.checkFramebufferStatus()） ..........390\n在帧缓冲区进行绘图 ........................390\n绘制阴影 ..................................................392\n如何实现阴影 ................................392\n示例程序（Shadow.js） ...........................393\n提高精度 ........................................399\n示例程序（Shadow_highp.js） .........................400\n加载三维模型 .....................................401\nOBJ 文件格式 ....................................404\nMTL 文件格式 ...............................405\n示例程序（OBJViewer.js） ........................406\n自定义类型对象 ..................................409\n示例程序（OBJViewer.js 解析数据部分） .........411\n响应上下文丢失 .....................................418\n如何响应上下文丢失 ....................419\n示例程序（RotatingTriangle_contextLost.js） ................420\n总结 .............................................................422\n附录A WebGL 中无须交换缓冲区....................... 423\n附录B GLSL ES 1.0 内置函数..................... 427\n角度和三角函数 .....................................428\n指数函数 ...............................................429\n通用函数 ...................................................430\n几何函数 ...................................................433\n矩阵函数 ....................................................434\n矢量函数 .......................................................435\n纹理查询函数 ...........................................436\n附录C 投影矩阵....................... 437\n正射投影矩阵 ........................................................437\n透视投影矩阵 ......................................437\n附录D WebGL/OpenGL ：左手还是右手坐标系？............................ 439\n示例程序(CoordinateSystem.js) .............................440\n隐藏面消除和裁剪坐标系统 ......................................443\n裁剪坐标系和可视空间 ....................................444\n什么是对的？ .................................................446\n总结 .....................................448\n附录E 逆转置矩阵................... 449\n附录F 从文件中加载着色器............ 453\n附录G 世界坐标系和本地坐标系........... 457\n本地坐标系 ......................................................458\n世界坐标系 ...........................459\n变换与坐标系 ..........................................461\n附录H WebGL 的浏览器设置.................. 463",
    "pages": "500",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27306770.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27306770.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27306770.jpg"
    },
    "alt": "https://book.douban.com/subject/25909351/",
    "id": "25909351",
    "publisher": "电子工业出版社",
    "isbn10": "7121229420",
    "isbn13": "9787121229428",
    "title": "WebGL编程指南",
    "url": "https://api.douban.com/v2/book/25909351",
    "alt_title": "",
    "author_intro": "关于作者\nKouichi Matsuda 博士是多媒体产品用户界面和用户体验设计方面的专家。他先后供职于日本电气(NEC)、索尼(Sony) 研发中心、索尼(Sony) 计算机科学实验室，曾经做过产品研发，也做过科学研究，最终回到产品研发的岗位。目前，他是用户体验和人机交互领域的首席研究员，负责多款消费类电子产品的设计。他曾经设计了社交三维虚拟世界“PAW”，也曾经参与过VRML97(ISO/IEC 14772-1:1997) 标准的开发工作，在VRML和X3D(WebGL 的前身) 社区中仍然非常活跃。他撰写过15 本计算机技术的书籍，并翻译过25 本相关书籍。他专长于用户体验、用户界面、人机交互、自然语言处理和面向娱乐的网络设备，以及接口代理系统等领域。他不仅对技术领域的新鲜事物充满热情，还热衷于温泉、夏季的海滩、红酒和漫画（为此他已经沉迷于绘制插画一段时间了）。他在东京大学工程系获得了博士学位，你可以通过WebGL.prog.guide@gmail.com 联系他。\nRodger Lea 博士是卑诗大学媒体与图像跨学科中心的兼职教授，对多媒体和分布式计算等领域很感兴趣。他和他带领的研究小组在学术和工业领域耕耘超过20 年，参与制定了VRML97 标准，开发了多媒体操作系统、可交互数字电视原型，并领导了家用多媒体网络标准的制定工作。他发表了60 多篇学术论文，著有3 本技术书籍，并拥有12 项专利。目前，他的研究集中在探索发展中的互联网，但他仍然对有关多媒体和图形学的一切抱有热情。\n关于译者\n谢光磊，毕业于南京大学，目前为中科院在读硕士，即将成为淘宝UED 的一名前端工程师。因一次偶然的机会接触WebGL 而对其萌生兴趣，并愿意持久深入地研究这项技术。个人站点为 www.xieguanglei.com。",
    "summary": "WebGL 是一项在网页上渲染三维图形的技术，也是HTML5 草案的一部分。\n《WebGL编程指南》的主要篇幅讲解了WebGL 原生API 和三维图形学的基础知识，包括渲染管线、着色器、矩阵变换、着色器编程语言（GLSL ES）等等，也讲解了使用WebGL 渲染三维场景的一般技巧，如光照、阴影、雾化等等。《WebGL编程指南》提供了丰富的示例程序供读者钻研，也提供了极具价值的附录供读者参考。\n《WebGL编程指南》适合有一定前端开发基础，希望学习WebGL，但对三维图形学缺乏了解的程序员们阅读。",
    "price": "98.00元"
  },
  "9787115349101": {
    "rating": { "max": 10, "numRaters": 258, "average": "8.8", "min": 0 },
    "subtitle": "",
    "author": ["Ilya Grigorik"],
    "pubdate": "2013-9",
    "tags": [
      { "count": 260, "name": "Web开发", "title": "Web开发" },
      { "count": 205, "name": "性能", "title": "性能" },
      { "count": 144, "name": "性能优化", "title": "性能优化" },
      { "count": 140, "name": "Web", "title": "Web" },
      { "count": 97, "name": "计算机", "title": "计算机" },
      { "count": 69, "name": "互联网", "title": "互联网" },
      { "count": 53, "name": "前端开发", "title": "前端开发" },
      { "count": 42, "name": "编程", "title": "编程" }
    ],
    "origin_title": "High Performance Browser Networking",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27249387.jpg",
    "binding": "平装",
    "translator": ["李松峰"],
    "catalog": "版权声明\nSteve Souders推荐序\n前言\n第一部分：网络技术概览\n第1章 延迟与带宽\n第2章 TCP的构成\n第3章 UDP的构成\n第4章 传输层安全（TLS）\n第二部分：无线网络性能\n第5章 无线网络概览\n第6章 Wi-Fi\n第7章 移动网络\n第8章 移动网络的优化建议\n第三部分：HTTP\n第9章 HTTP简史\n第10章 Web性能要点\n第11章 HTTP 1.x\n第12章 HTTP 2.0\n第13章 优化应用的交付\n第四部分 浏览器API与协议\n第14章 浏览器网络概述\n第15章 XMLHttpRequest\n第16章 服务器发送事件\n第17章 WebSocket\n第18章 WebRTC\n关于封面",
    "ebook_url": "https://read.douban.com/ebook/12055070/",
    "pages": "336",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27249387.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27249387.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27249387.jpg"
    },
    "alt": "https://book.douban.com/subject/25856314/",
    "id": "25856314",
    "publisher": "人民邮电出版社",
    "isbn10": "711534910X",
    "isbn13": "9787115349101",
    "title": "Web性能权威指南",
    "url": "https://api.douban.com/v2/book/25856314",
    "alt_title": "High Performance Browser Networking",
    "author_intro": "作者简介：\nIlya Grigorik\n是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。\n在专注于研究Web性能之前，Ilya创办了PostRank公司并担任CTO，这是一家社交分析公司。他的这家公司被谷歌收购后，成为了Google Analytics中社交分析报告模块的核心。除了研究Web性能和分析，Ilya还会为开源项目做做贡献、看看书，或者写一些好玩的项目，比如VimGolf、GitHub Archive等。\n译者简介：\n李松峰\n2006年起投身翻译，出版过译著30余部，包括《JavaScript高级程序设计》、《简约至上》等畅销书。2008年进入出版业，从事技术图书编辑和审稿工作。\n2007年创立知识分享网站“为之漫笔”（cn-cuckoo.com），翻译了大量国外经典技术文章。2012年下半年创立“A List Apart中文版”站点（alistapart.cn），旨在向中文读者译介这一国际顶级Web设计与开发杂志。他经常参加技术社区活动，曾在W3ctech 2012 Mobile上分享“Dive into Responsive Web Design”。2013年1月应邀在金山网络分享“响应式Web设计”，2013年3月应邀在奇虎360分享“JS的国”。",
    "summary": "本书是谷歌公司高性能团队核心成员的权威之作，堪称实战经验与规范解读完美结合的产物。本书目标是涵盖Web 开发者技术体系中应该掌握的所有网络及性能优化知识。全书以性能优化为主线，从TCP、UDP 和TLS 协议讲起，解释了如何针对这几种协议和基础设施来优化应用。然后深入探讨了无线和移动网络的工作机制。最后，揭示了HTTP 协议的底层细节，同时详细介绍了HTTP 2.0、 XHR、SSE、WebSocket、WebRTC 和DataChannel 等现代浏览器新增的具有革命性的新能力。\n本书适合所有Web 应用及站点开发人员阅读，包括但不限于前端、后端、运维、大数据分析、\nUI/UX、存储、视频、实时消息，以及性能工程师。\nIlya Grigorik 是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。",
    "ebook_price": "29.99",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "69"
  },
  "9787115385734": {
    "rating": { "max": 10, "numRaters": 574, "average": "9.4", "min": 0 },
    "subtitle": "",
    "author": ["[美] Kyle Simpson"],
    "pubdate": "2015-4",
    "tags": [
      { "count": 656, "name": "JavaScript", "title": "JavaScript" },
      { "count": 299, "name": "前端开发", "title": "前端开发" },
      { "count": 179, "name": "javascript", "title": "javascript" },
      { "count": 154, "name": "前端", "title": "前端" },
      { "count": 149, "name": "编程", "title": "编程" },
      { "count": 132, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 123, "name": "计算机", "title": "计算机" },
      { "count": 79, "name": "Web", "title": "Web" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28033372.jpg",
    "binding": "平装",
    "translator": ["赵望野", "梁杰"],
    "catalog": "前言　　VIII\n第一部分　作用域和闭包\n序　　2\n第1章　作用域是什么　　4\n1.1　编译原理　　4\n1.2　理解作用域　　6\n1.2.1　演员表　　6\n1.2.2　对话　　6\n1.2.3　编译器有话说　　7\n1.2.4　引擎和作用域的对话　　9\n1.2.5　小测验　　10\n1.3　作用域嵌套　　10\n1.4　异常　　12\n1.5　小结　　12\n第2章　词法作用域　　14\n2.1　词法阶段　　14\n2.2　欺骗词法　　17\n2.2.1　eval　　17\n2.2.2　with　　18\n2.2.3　性能　　20\n2.3　小结　　21\n第3章　函数作用域和块作用域　　22\n3.1　函数中的作用域　　22\n3.2　隐藏内部实现　　23\n3.3　函数作用域　　26\n3.3.1　匿名和具名　　27\n3.3.2　立即执行函数表达式　　28\n3.4　块作用域　　30\n3.4.1　with　　31\n3.4.2　try/catch　　31\n3.4.3　let　　32\n3.4.4　const　　35\n3.5　小结　　36\n第4章　提升　　37\n4.1　先有鸡还是先有蛋　　37\n4.2　编译器再度来袭　　38\n4.3　函数优先　　40\n4.4　小结　　41\n第5章　作用域闭包　　43\n5.1　启示　　43\n5.2　实质问题　　44\n5.3　现在我懂了　　47\n5.4　循环和闭包　　48\n5.5　模块　　51\n5.5.1　现代的模块机制　　54\n5.5.2　未来的模块机制　　56\n5.6　小结　　57\n附录A　动态作用域　　58\n附录B　块作用域的替代方案　　60\n附录C　this词法　　64\n附录D　致谢　　67\n第二部分　this和对象原型\n序　　72\n第1章　关于this　　74\n1.1　为什么要用this　　74\n1.2　误解　　76\n1.2.1　指向自身　　76\n1.2.2　它的作用域　　79\n1.3　this到底是什么　　80\n1.4　小结　　80\n第2章　this全面解析　　82\n2.1　调用位置　　82\n2.2　绑定规则　　83\n2.2.1　默认绑定　　83\n2.2.2　隐式绑定　　85\n2.2.3　显式绑定　　87\n2.2.4　new绑定　　90\n2.3　优先级　　91\n2.4　绑定例外　　95\n2.4.1　被忽略的this　　96\n2.4.2　间接引用　　97\n2.4.3　软绑定　　98\n2.5　this词法　　99\n2.6　小结　　101\n第3章　对象　　102\n3.1　语法　　102\n3.2　类型　　103\n3.3　内容　　105\n3.3.1　可计算属性名　　106\n3.3.2　属性与方法　　107\n3.3.3　数组　　108\n3.3.4　复制对象　　109\n3.3.5　属性描述符　　111\n3.3.6　不变性　　114\n3.3.7　[[Get]]　　115\n3.3.8　[[Put]]　　116\n3.3.9　Getter和Setter　　117\n3.3.10　存在性　　119\n3.4　遍历　　121\n3.5　小结　　124\n第4章　混合对象“类”　　126\n4.1　类理论　　126\n4.1.1　“类”设计模式　　127\n4.1.2　JavaScript中的“类”　　128\n4.2　类的机制　　128\n4.2.1　建造　　128\n4.2.2　构造函数　　130\n4.3　类的继承　　130\n4.3.1　多态　　132\n4.3.2　多重继承　　134\n4.4　混入　　134\n4.4.1　显式混入　　135\n4.4.2　隐式混入　　139\n4.5　小结　　140\n第5章　原型　　142\n5.1　[[Prototype]]　　142\n5.1.1　Object.prototype　　144\n5.1.2　属性设置和屏蔽　　144\n5.2　“类”　　146\n5.2.1　“类”函数　　146\n5.2.2　“构造函数”　　149\n5.2.3　技术　　151\n5.3　（原型）继承　　153\n5.4　对象关联　　159\n5.4.1　创建关联　　159\n5.4.2　关联关系是备用　　161\n5.5　小结　　162\n第6章　行为委托　　164\n6.1　面向委托的设计　　165\n6.1.1　类理论　　165\n6.1.2　委托理论　　166\n6.1.3　比较思维模型　　170\n6.2　类与对象　　173\n6.2.1　控件“类”　　174\n6.2.2　委托控件对象　　176\n6.3　更简洁的设计　　178\n6.4　更好的语法　　182\n6.5　内省　　185\n6.6　小结　　187\n附录A　ES6中的Class　　189",
    "ebook_url": "https://read.douban.com/ebook/12051836/",
    "pages": "195",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28033372.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28033372.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28033372.jpg"
    },
    "alt": "https://book.douban.com/subject/26351021/",
    "id": "26351021",
    "publisher": "人民邮电出版社",
    "isbn10": "7115385734",
    "isbn13": "9787115385734",
    "title": "你不知道的JavaScript（上卷）",
    "url": "https://api.douban.com/v2/book/26351021",
    "alt_title": "",
    "author_intro": "作者简介：\nKyle Simpson\n推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。\n译者简介：\n赵望野\n前端工程师，前端基础技术组leader，曾经负责豌豆荚2.0的前端架构设计和主要开发工作，目前负责Front-end Technical Infrastructure的建设。新浪微博@赵望野。负责本书第一部分“作用域和闭包”的翻译。\n梁杰\n北京航空航天大学计算机科学与技术专业大四学生。热爱JavaScript、Python，热爱开源，喜欢做各种各样有趣的事情。负责本书第二部分“this和对象原型”的翻译。",
    "summary": "JavaScript语言有很多复杂的概念，但却用简单的方式体现出来（比如回调函数），因此，JavaScript开发者无需理解语言内部的原理，就能编写出功能全面的程序；就像收音机一样，你无需理解里面的管子和线圈都是做什么用的，只要会操作收音机上的按键，就可以收听你喜欢的节目。然而，JavaScript的这些复杂精妙的概念才是语言的精髓，即使是经验丰富的JavaScript开发者，如果没有认真学习也无法真正理解语言本身的特性。正是因为绝大多数人不求甚解，一遇到出乎意料的行为就认为是语言本身有缺陷，进而把相关的特性加入黑名单，久而久之就排除了这门语言的多样性，人为地使它变得不完整、不安全。\n“你不知道的JavaScript”系列就是要让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。掌握了这些知识之后，无论什么技术、框架和流行词语，你都能轻松理解。",
    "ebook_price": "24.99",
    "series": { "id": "40642", "title": "你不知道的JavaScript" },
    "price": "49.00元"
  },
  "9787115431165": {
    "rating": { "max": 10, "numRaters": 188, "average": "8.9", "min": 0 },
    "subtitle": "",
    "author": ["[美] Kyle Simpson"],
    "pubdate": "2016-8",
    "tags": [
      { "count": 181, "name": "JavaScript", "title": "JavaScript" },
      { "count": 84, "name": "前端开发", "title": "前端开发" },
      { "count": 58, "name": "javascript", "title": "javascript" },
      { "count": 49, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 46, "name": "前端", "title": "前端" },
      { "count": 36, "name": "编程", "title": "编程" },
      { "count": 28, "name": "计算机", "title": "计算机" },
      { "count": 16, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28969600.jpg",
    "binding": "平装",
    "translator": ["单业", "姜南"],
    "catalog": "前言 XI\n第一部分　类型和语法\n序　　2\n第1章 　类型　　3\n1.1　类型　　4\n1.2　内置类型　　4\n1.3　值和类型　　6\n1.3.1　undefined 和undeclared　　6\n1.3.2　typeof Undeclared　　7\n1.4　小结　　10\n第2章　值　　11\n2.1　数组　　11\n2.2　字符串　　13\n2.3　数字　　15\n2.3.1　数字的语法　　16\n2.3.2　较小的数值　　18\n2.3.3　整数的安全范围　　19\n2.3.4　整数检测　　20\n2.3.5　32 位有符号整数　　20\n2.4　特殊数值　　21\n2.4.1　不是值的值　　21\n2.4.2　undefined　　21\n2.4.3　特殊的数字　　23\n2.4.4　特殊等式　　27\n2.5　值和引用　　28\n2.6　小结　　31\n第3章　原生函数　　33\n3.1　内部属性[[Class]]　　34\n3.2　封装对象包装　　35\n3.3　拆封　　36\n3.4　原生函数作为构造函数　　37\n3.4.1　Array(..)　　37\n3.4.2　Object(..)、Function(..) 和RegExp(..)　　40\n3.4.3　Date(..) 和Error(..)　　41\n3.4.4　Symbol(..)　　42\n3.4.5　原生原型　　43\n3.5　小结　　45\n第4章　强制类型转换　　46\n4.1　值类型转换　　46\n4.2　抽象值操作　　47\n4.2.1　ToString　　48\n4.2.2　ToNumber　　52\n4.2.3　ToBoolean　　53\n4.3　显式强制类型转换　　56\n4.3.1　字符串和数字之间的显式转换　　57\n4.3.2　显式解析数字字符串　　62\n4.3.3　显式转换为布尔值　　65\n4.4　隐式强制类型转换　　67\n4.4.1　隐式地简化　　67\n4.4.2　字符串和数字之间的隐式强制类型转换　　68\n4.4.3　布尔值到数字的隐式强制类型转换　　71\n4.4.4　隐式强制类型转换为布尔值　　72\n4.4.5　|| 和&&　　73\n4.4.6　符号的强制类型转换　　76\n4.5　宽松相等和严格相等　　77\n4.5.1　相等比较操作的性能　　77\n4.5.2　抽象相等\n4.6　抽象关系比较　　89\n4.7　小结　　91\n第5章　语法　　92\n5.1　语句和表达式　　92\n5.1.1　语句的结果值　　93\n5.1.2　表达式的副作用　　95\n5.1.3　上下文规则　　99\n5.2　运算符优先级　　104\n5.2.1　短路　　107\n5.2.2　更强的绑定　　107\n5.2.3　关联　　108\n5.2.4　释疑　　110\n5.3　自动分号　　111\n5.4　错误　　113\n5.5　函数参数　　115\n5.6　try..finally　　117\n5.7　switch　　120\n5.8　小结　　122\n附录A　混合环境JavaScript　　123\n第二部分　异步和性能\n序　　136\n第1章　异步：现在与将来　　138\n1.1　分块的程序　　139\n1.2　事件循环　　141\n1.3　并行线程　　143\n1.4　并发　　148\n1.4.1　非交互　　150\n1.4.2　交互　　150\n1.4.3　协作　　154\n1.5　任务　　156\n1.6　语句顺序　　157\n1.7　小结　　159\n第2章　回调　　161\n2.1　continuation　　162\n2.2　顺序的大脑　　163\n2.2.1　执行与计划　　164\n2.2.2　嵌套回调与链式回调　　165\n2.3　信任问题　　169\n2.3.1　五个回调的故事　　170\n2.3.2　不只是别人的代码　　171\n2.4　省点回调　　173\n2.5　小结　　176\n第3章　Promise　　178\n3.1　什么是Promise　　179\n3.1.1　未来值　　179\n3.1.2　完成事件　　183\n3.2　具有then 方法的鸭子类型　　188\n3.3　Promise 信任问题　　190\n3.3.1　调用过早　　190\n3.3.2　调用过晚　　191\n3.3.3　回调未调用　　192\n3.3.4　调用次数过少或过多　　193\n3.3.5　未能传递参数/ 环境值　　193\n3.3.6　吞掉错误或异常　　194\n3.3.7　是可信任的Promise 吗　　195\n3.3.8　建立信任　　197\n3.4　链式流　　198\n3.5　错误处理　　206\n3.5.1　绝望的陷阱　　208\n3.5.2　处理未捕获的情况　　209\n3.5.3　成功的坑　　211\n3.6　Promise 模式　　212\n3.6.1　Promise.all([ .. ])　　212\n3.6.2　Promise.race([ .. ])　　213\n3.6.3　all([ .. ]) 和race([ .. ]) 的变体　　216\n3.6.4　并发迭代　　217\n3.7　Promise API 概述　　219\n3.7.1　new Promise(..) 构造器　　219\n3.7.2　Promise.resolve(..) 和Promise.reject(..)　　219\n3.7.3　then(..) 和catch(..)　　220\n3.7.4　Promise.all([ .. ]) 和Promise.race([ .. ])　　221\n3.8　Promise 局限性　　222\n3.8.1　顺序错误处理　　222\n3.8.2　单一值　　223\n3.8.3　单决议　　225\n3.8.4　惯性　　227\n3.8.5　无法取消的Promise　　230\n3.8.6　Promise 性能　　231\n3.9　小结　　233\n第4章　生成器　　234\n4.1　打破完整运行　　234\n4.1.1　输入和输出　　236\n4.1.2　多个迭代器　　239\n4.2　生成器产生值　　243\n4.2.1　生产者与迭代器　　243\n4.2.2　iterable　　246\n4.2.3　生成器迭代器　　247\n4.3　异步迭代生成器　　250\n4.4　生成器+Promise　　254\n4.4.1　支持Promise 的Generator Runner　　256\n4.4.2　生成器中的Promise 并发　　258\n4.5　生成器委托　　262\n4.5.1　为什么用委托　　264\n4.5.2　消息委托　　264\n4.5.3　异步委托　　268\n4.5.4　递归委托　　268\n4.6　生成器并发　　269\n4.7　形实转换程序　　273\n4.8　ES6 之前的生成器　　279\n4.8.1　手工变换　　280\n4.8.2　自动转换　　284\n4.9　小结　　285\n第5章　程序性能　　287\n5.1　Web Worker　　288\n5.1.1　Worker 环境　　290\n5.1.2　数据传递　　291\n5.1.3　共享Worker　　291\n5.1.4　模拟Web Worker　　293\n5.2　SIMD　　293\n5.3　asm.js　　295\n5.3.1　如何使用asm.js 优化　　295\n5.3.2　asm.js 模块　　296\n5.4　小结　　298\n第6章　性能测试与调优　　299\n6.1　性能测试　　99\n6.1.1　重复　　300\n6.1.2　Benchmark.js　　301\n6.2　环境为王　　303\n6.3　jsPerf.com　　305\n6.4　写好测试　　309\n6.5　微性能　　309\n6.5.1　不是所有的引擎都类似　　312\n6.5.2　大局　　314\n6.6　尾调用优化　　316\n6.7　小结　　318\n附录A　asynquence 库　　319\n附录B　高级异步模式　　339",
    "ebook_url": "https://read.douban.com/ebook/52186338/",
    "pages": "358",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28969600.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28969600.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28969600.jpg"
    },
    "alt": "https://book.douban.com/subject/26854244/",
    "id": "26854244",
    "publisher": "人民邮电出版社",
    "isbn10": "7115431167",
    "isbn13": "9787115431165",
    "title": "你不知道的JavaScript（中卷）",
    "url": "https://api.douban.com/v2/book/26854244",
    "alt_title": "",
    "author_intro": "<作者介绍>\nKyle Simpson\n作家、培训师、讲师、开源社区的活跃成员，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。\n<译者介绍>\n单业\n计算机专业硕士，软件工程师，曾供职于多家软件公司，从事软件开发工作，现居于上海。负责本书第二部分“异步和性能”的翻译。\n姜南\n从事过国内外金融、通信、移动互联网、数字出版等领域的IT系统开发工作，擅长的技术有Java、C#、HTML5、JavaScript、iOS、Android等。长期在独立技术博客——酷壳（coolshell.cn）发表翻译文章。负责本书第一部分“类型和语法”的翻译。",
    "summary": "JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其中卷，主要介绍了类型、语法、异步和性能。",
    "ebook_price": "39.99",
    "series": { "id": "40642", "title": "你不知道的JavaScript" },
    "price": "79.00元"
  },
  "9787115471659": {
    "rating": { "max": 10, "numRaters": 58, "average": "8.0", "min": 0 },
    "subtitle": "",
    "author": ["[美] Kyle Simpson"],
    "pubdate": "2018-1-1",
    "tags": [
      { "count": 61, "name": "JavaScript", "title": "JavaScript" },
      { "count": 16, "name": "前端开发", "title": "前端开发" },
      { "count": 13, "name": "编程", "title": "编程" },
      { "count": 12, "name": "前端", "title": "前端" },
      { "count": 10, "name": "Web前端开发", "title": "Web前端开发" },
      { "count": 8, "name": "计算机", "title": "计算机" },
      { "count": 7, "name": "javascript", "title": "javascript" },
      { "count": 4, "name": "专业知识刷", "title": "专业知识刷" }
    ],
    "origin_title": "You don't know JS",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29656379.jpg",
    "binding": "平装",
    "translator": ["单业"],
    "catalog": "前言 xi\n致谢 xvii\n第 一部分 起步上路\n序 2\n第 1 章 深入编程 4\n1.1 代码 4\n1.2 表达式 5\n1.3 实践 6\n1.3.1 输出 7\n1.3.2 输入 8\n1.4 运算符 9\n1.5 值与类型 11\n1.6 代码注释 13\n1.7 变量 14\n1.8 块 16\n1.9 条件判断 17\n1.10 循环 18\n1.11 函数 20\n1.12 实践 23\n1.13 小结 25\n第 2 章 深入JavaScript 26\n2.1 值与类型 26\n2.1.1 对象 28\n2.1.2 内置类型方法 30\n2.1.3 值的比较 31\n2.2 变量 35\n2.3 条件判断 37\n2.4 严格模式 39\n2.5 作为值的函数 40\n2.5.1 立即调用函数表达式 41\n2.5.2 闭包 42\n2.6 this标识符 44\n2.7 原型 46\n2.8 旧与新 47\n2.8.1 polyfilling 47\n2.8.2 transpiling 48\n2.9 非JavaScript 49\n2.10 小结 50\n第 3 章 深入“你不知道的JavaScript”系列 51\n3.1 作用域和闭包 51\n3.2 this和对象原型 52\n3.3 类型和语法 53\n3.4 异步和性能 53\n3.5 ES6及更新版本 54\n3.6 小结 55\n第 二部分 ES6及更新版本\n序 58\n第 1 章 ES？现在与未来 59\n1.1 版本 60\n1.2 transpiling 61\n1.3 小结 63\n第 2 章 语法 64\n2.1 块作用域声明 64\n2.1.1 let声明 65\n2.1.2 const声明 68\n2.1.3 块作用域函数 70\n2.2 spread/rest 71\n2.3 默认参数值 73\n2.4 解构 77\n2.4.1 对象属性复制模式 78\n2.4.2 不只是声明 79\n2.4.3 重复赋值 81\n2.5 太多，太少，刚刚好 83\n2.5.1 默认值赋值 84\n2.5.2 嵌套解构 84\n2.5.3 解构参数 85\n2.6　对象字面量扩展 90\n2.6.1　简洁属性 90\n2.6.2　简洁方法 90\n2.6.3　计算属性名 95\n2.6.4　设定[[Prototype]] 96\n2.6.5　super对象 97\n2.7　模板字面量 98\n2.7.1　插入表达式 99\n2.7.2　标签模板字面量 100\n2.8　箭头函数 103\n2.9　for..of循环 109\n2.10　正则表达式 111\n2.10.1　Unicode标识 111\n2.10.2　定点标识 112\n2.10.3　正则表达式flags 116\n2.11　数字字面量扩展 117\n2.12　Unicode 118\n2.12.1　支持Unicode的字符串运算 119\n2.12.2　字符定位 121\n2.12.3　Unicode标识符名 123\n2.13　符号 123\n2.13.1　符号注册 125\n2.13.2　作为对象属性的符号 127\n2.14　小结 128\n第 3 章　代码组织 129\n3.1　迭代器 129\n3.1.1　接口 130\n3.1.2　next()迭代 131\n3.1.3　可选的return(..)和throw(..) 132\n3.1.4　迭代器循环 133\n3.1.5　自定义迭代器 134\n3.1.6　迭代器消耗 137\n3.2　生成器 138\n3.2.1　语法 139\n3.2.2　迭代器控制 144\n3.2.3　提前完成 147\n3.2.4　错误处理 149\n3.2.5　Transpile生成器 151\n3.2.6　生成器使用 152\n3.3　模块 153\n3.3.1　旧方法 153\n3.3.2　前进 154\n3.3.3　新方法 156\n3.3.4　模块依赖环 164\n3.3.5　模块加载 166\n3.4　类 167\n3.4.1　class 168\n3.4.2　extends和super 169\n3.4.3　new.target 174\n3.4.4　static 175\n3.5　小结 176\n第 4 章　异步流控制 177\n4.1　Promise 177\n4.1.1　构造和使用Promise 178\n4.1.2　Thenable 180\n4.1.3　Promise API 181\n4.2　生成器 + Promise 183\n4.3　小结 185\n第 5 章　集合 187\n5.1　TypedArray 187\n5.1.1　大小端（Endianness） 188\n5.1.2　多视图 189\n5.1.3　带类数组构造器 190\n5.2　Map 192\n5.2.1　Map值 194\n5.2.2　Map键 194\n5.3　WeakMap 195\n5.4　Set 196\n5.5　WeakSet 198\n5.6　小结 199\n第 6 章　新增API 200\n6.1　Array 200\n6.1.1　静态函数Array.of(..) 200\n6.1.2　静态函数Array.from(..) 201\n6.1.3　创建数组和子类型 204\n6.1.4　原型方法copyWithin(..) 205\n6.1.5　原型方法fill(..) 206\n6.1.6　原型方法find(..) 206\n6.1.7　原型方法findIndex(..) 207\n6.1.8　原型方法entries()、values()、keys() 208\n6.2　Object 209\n6.2.1　静态函数Object.is(..) 209\n6.2.2　静态函数Object.getOwnPropertySymbols(..) 210\n6.2.3　静态函数Object.setPrototypeOf(..) 210\n6.2.4　静态函数Object.assign(..) 211\n6.3　Math 212\n6.4　Number 214\n6.4.1　静态属性 214\n6.4.2　静态函数Number.isNaN(..) 214\n6.4.3　静态函数Number.isFinite(..) 215\n6.4.4　整型相关静态函数 215\n6.5　字符串 216\n6.5.1　Unicode函数 217\n6.5.2　静态函数String.raw(..) 217\n6.5.3　原型函数repeat(..) 217\n6.5.4　字符串检查函数 218\n6.6　小结 218\n第 7 章　元编程 219\n7.1　函数名称 219\n7.2　元属性 222\n7.3　公开符号 223\n7.3.1　Symbol.iterator 223\n7.3.2　Symbol.toStringTag与Symbol.hasInstance 224\n7.3.3　Symbol.species 225\n7.3.4　Symbol.toPrimitive 226\n7.3.5　正则表达式符号 226\n7.3.6　Symbol.isConcatSpreadable 227\n7.3.7　Symbol.unscopables 228\n7.4　代理 228\n7.4.1　代理局限性 231\n7.4.2　可取消代理 232\n7.4.3　使用代理 233\n7.5　Reflect API 240\n7.6　特性测试 243\n7.7　尾递归调用（Tail Call Optimization,TCO） 245\n7.7.1　尾调用重写 247\n7.7.2　非TCO优化 248\n7.7.3　元在何处 250\n7.8　小结 251\n第 8 章　ES6之后 253\n8.1　异步函数 254\n8.2　Object.observe(..) 257\n8.2.1　自定义改变事件 258\n8.2.2　结束观测 259\n8.3　幂运算符 260\n8.4　对象属性与... 260\n8.5　Array#includes 261\n8.6　SIMD 262\n8.7　WebAssembly (WASM) 262\n8.8　小结 264",
    "ebook_url": "https://read.douban.com/ebook/52186484/",
    "pages": "264",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29656379.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29656379.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29656379.jpg"
    },
    "alt": "https://book.douban.com/subject/27620408/",
    "id": "27620408",
    "publisher": "人民邮电出版社",
    "isbn10": "7115471657",
    "isbn13": "9787115471659",
    "title": "你不知道的JavaScript（下卷）",
    "url": "https://api.douban.com/v2/book/27620408",
    "alt_title": "You don't know JS",
    "author_intro": "作者:[美]凯尔?辛普森（Kyle Simpson） 译者:单业\nKyle Simpson，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。",
    "summary": "JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其下卷，主要介绍了JavaScript入门知识和对ES6及未来发展趋势的展望。",
    "ebook_price": "39.99",
    "series": { "id": "40642", "title": "你不知道的JavaScript" },
    "price": "79.00"
  },
  "9787115299222": {
    "rating": { "max": 10, "numRaters": 330, "average": "7.4", "min": 0 },
    "subtitle": "HTML5和CSS3实战",
    "author": ["Ben Frain"],
    "pubdate": "2013-1-1",
    "tags": [
      { "count": 266, "name": "响应式设计", "title": "响应式设计" },
      { "count": 191, "name": "Web开发", "title": "Web开发" },
      { "count": 156, "name": "html5", "title": "html5" },
      { "count": 140, "name": "前端开发", "title": "前端开发" },
      { "count": 112, "name": "CSS3", "title": "CSS3" },
      { "count": 80, "name": "HTML5", "title": "HTML5" },
      { "count": 45, "name": "web", "title": "web" },
      { "count": 44, "name": "css3", "title": "css3" }
    ],
    "origin_title": "Responsive Web Design with HTML5 and CSS3",
    "image": "https://img3.doubanio.com/view/subject/m/public/s24423104.jpg",
    "binding": "平装",
    "translator": ["王永强"],
    "catalog": "第1章 　HTML5、CSS3及响应式设计入门　　1\n1.1 　为什么智能手机很重要（而老版的IE不再重要）　　2\n1.2 　响应式设计一定是最佳选择吗　　3\n1.3 　响应式网页设计的定义　　3\n1.4 　为什么要在响应式设计上停滞不前　　4\n1.5 　响应式网页设计示例　　4\n1.5.1 　下载视口调试工具　　4\n1.5.2 　在线创意源泉　　11\n1.6 　为什么HTML5很优秀　　12\n1.6.1 　省时省力　　12\n1.6.2 　新增了语义化标签元素　　13\n1.7 　CSS3为响应式设计和更多创新奠定了基础　　13\n1.7.1 　底线：CSS3不破坏任何东西　　14\n1.7.2 　CSS3如何解决日常设计问题　　14\n1.8 　看呐，不用图片　　17\n1.9 　HTML5和CSS3现在就能用吗　　20\n1.10 　响应式网页设计不是灵丹妙药　　20\n1.11 　引导客户：网站不必在所有浏览器中表现一致　　21\n1.12 　小结　　22\n第2章 　媒体查询：支持不同的视口　　23\n2.1 　现在就能使用媒体查询　　23\n2.2 　为什么响应式设计需要媒体查询　　24\n2.2.1 　媒体查询语法　　24\n2.2.2 　 媒体查询能检测那些特性　　26\n2.2.3 　用媒体查询改造我们的设计　　27\n2.2.4 　加载媒体查询的最佳方法　　27\n2.3 　我们的第一个响应式设计　　27\n2.3.1 　我们的设计是固定宽度的，不要惊讶　　28\n2.3.2 　响应式设计中要保证图片尽可能精简　　32\n2.3.3 　小视口下的内容剪切　　33\n2.4 　阻止移动浏览器自动调整页面大小　　34\n2.5 　针对不同视口宽度修正设计　　37\n2.6 　响应式设计中内容始终优先　　38\n2.7 　媒体查询只是必要条件之一　　42\n2.8 　小结　　42\n第3章 　拥抱流式布局　　43\n3.1 　固定布局经不起未来考验　　43\n3.2 　为什么响应式设计需要百分比布局　　44\n3.3 　将网页从固定布局修改为百分比布局　　44\n3.3.1 　需要牢记的公式　　45\n3.3.2 　设置百分比元素的上下文　　47\n3.3.3 　必须时刻牢记上下文　　52\n3.4 　用em替换px　　54\n3.5 　弹性图片　　56\n3.5.1 　让图片随视口缩放　　56\n3.5.2 　为特定图片指定特定规则　　58\n3.5.3 　给弹性图片设置阈值　　59\n3.5.4 　超级全能的max-width属性　　61\n3.6 　为不同的屏幕尺寸提供不同的图片　　61\n3.7 　流动网格布局和媒体查询的默契配合　　66\n3.8 　CSS网格系统　　66\n3.9 　小结　　72\n第4章 　响应式设计中的HTML5　　73\n4.1 　HTML5的哪些部分现在就能用　　73\n4.1.1 　大多数网站可以用HTML5编写　　74\n4.1.2 　腻子脚本和Modernizr　　74\n4.2 　如何编写HTML5网页　　75\n4.2.1 　HTML5的精简之道　　76\n4.2.2 　HTML5标签的合理写法　　76\n4.2.3 　伟大的<a>标签万岁　　77\n4.2.4 　HTML的废弃零件　　77\n4.3 　HTML5的全新语义化元素　　78\n4.3.1 　<section>　　78\n4.3.2 　<nav>　　79\n4.3.3 　<article>　　79\n4.3.4 　<aside>　　79\n4.3.5 　<hgroup>　　79\n4.3.6 　<header>　　81\n4.3.7 　<footer>　　81\n4.3.8 　<address>　　81\n4.4 　HTML5结构元素的实际用法　　81\n4.5 　HTML5的文本级语义元素　　87\n4.5.1 　<b>　　88\n4.5.2 　<em>　　88\n4.5.3 　<i>　　88\n4.5.4 　在页面中应用文本层语义元素　　88\n4.6 　遵循WAI-ARIA实现无障碍站点　　90\n4.7 　在HTML5中嵌入媒体　　93\n4.8 　用HTML5的方法为页面添加视频或音频　　93\n4.8.1 　提供备用的媒体源文件　　95\n4.8.2 　针对老版本浏览器的备用方案　　95\n4.8.3 　和标签的用法基本一致　　96\n4.9 　响应式视频　　96\n4.10 　离线Web应用　　99\n4.10.1 　离线Web应用概述　　99\n4.10.2 　让网页可离线使用　　99\n4.10.3 　理解manifest文件　　100\n4.10.4 　页面被自动加载到离线缓存　　101\n4.10.5 　版本注释的用途　　101\n4.10.6 　离线访问网站　　101\n4.10.7 　离线Web应用的故障诊断　　102\n4.11 　小结　　103\n第5章 　CSS3：选择器、字体和颜色模式　　104\n5.1 　CSS3给前端开发人员带来了什么　　104\n5.1.1 　Internet Explorer 6到8对CSS3的支持　　105\n5.1.2 　使用CSS3设计和开发页面　　105\n5.2 　CSS规则解析　　105\n5.3 　私有前缀及其用法　　106\n5.4 　快速而有效的CSS技巧　　108\n5.4.1 　CSS3多栏布局　　108\n5.4.2 　文字换行　　110\n5.5 　CSS3的新增选择器及其用法　　111\n5.5.1 　CSS3属性选择器　　111\n5.5.2 　CSS3结构伪类　　113\n5.5.3 　对伪元素的修正　　122\n5.6 　自定义网页字体　　123\n5.6.1 　@font-face规则　　124\n5.6.2 　使用@font-face嵌入网页字体　　124\n5.7 　帮帮我，标题模糊怎么办　　127\n5.8 　新的CSS3颜色格式和透明度　　129\n5.8.1 　RGB颜色　　130\n5.8.2 　HSL颜色　　131\n5.8.3 　针对IE6、IE7和IE8提供备用颜色值　　132\n5.8.4 　透明通道　　132\n5.9 　小结　　134\n第6章 　用CSS3创造令人惊艳的美　　135\n6.1 　文字阴影　　136\n6.1.1 　HEX、HSL或RGB颜色都可以　　136\n6.1.2 　px、em或rem都行　　136\n6.1.3 　取消文字阴影　　138\n6.1.4 　制作浮雕文字阴影效果　　139\n6.1.5 　多重文字阴影　　140\n6.2 　盒阴影　　140\n6.2.1 　内阴影　　141\n6.2.2 　多重阴影　　142\n6.3 　背景渐变　　143\n6.3.1 　线性背景渐变　　144\n6.3.2 　径向背景渐变　　147\n6.3.3 　重复渐变　　149\n6.4 　背景渐变图案　　151\n6.5 　CSS3的响应性　　153\n6.6 　组合使用CSS3属性　　155\n6.7 　多重背景图片　　159\n6.7.1 　背景图片大小　　161\n6.7.2 　背景图片位置　　161\n6.7.3 　背景属性的缩写语法　　161\n6.8 　更多CSS特性　　162\n6.9 　可缩放图标：响应式设计中的完美选择　　162\n6.10 　小结　　163\n第7章 　CSS3过渡、变形和动画　　164\n7.1 　什么是CSS3过渡以及如何使用它　　164\n7.1.1 　过渡相关的属性　　166\n7.1.2 　响应式网站中的有趣过渡　　168\n7.2 　CSS3的2D变形　　169\n7.3 　尝试CSS3的3D变形　　174\n7.3.1 　分析3D变形效果　　176\n7.3.2 　3D变形尚未成熟　　178\n7.4 　CSS3动画效果　　179\n7.5 　小结　　185\n第8章 　用HTML5和CSS3征服表单　　186\n8.1 　HTML5表单　　186\n8.1.1 　理解HTML5表单中的元素　　188\n8.1.2 　placeholder　　189\n8.1.3 　required　　189\n8.1.4 　autofocus　　190\n8.1.5 　autocomplete　　191\n8.1.6 　list（及对应的datalist元素）　　191\n8.1.7 　HTML5的新输入类型　　192\n8.1.8 　日期和时间输入类型　　198\n8.2 　如何给不支持新特性的浏览器打补丁　　203\n8.3 　使用CSS3美化HTML5表单　　204\n8.4 　小结　　210\n第9章 　解决跨浏览器问题　　211\n9.1 　渐进增强与优雅降级　　215\n9.2 　该不该修复老版本IE　　216\n9.2.1 　统计数据（再看看世界的变化）　　216\n9.2.2 　个人选择　　216\n9.3 　前端的瑞士军刀：Modernizr　　217\n9.3.1 　使用Modernizr辅助修正样式问题　　219\n9.3.2 　使用Modernizr让老版本IE支持HTML5元素　　221\n9.3.3 　给IE6、7、8追加min/max媒体查询功能　　222\n9.3.4 　使用Modernizr按需加载资源　　223\n9.4 　必要时将导航链接转换为下拉菜单　　225\n9.5 　高分辨率设备（未来趋势）　　228\n9.6 　小结　　231\n",
    "pages": "231",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s24423104.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s24423104.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s24423104.jpg"
    },
    "alt": "https://book.douban.com/subject/20390374/",
    "id": "20390374",
    "publisher": "人民邮电出版社",
    "isbn10": "7115299226",
    "isbn13": "9787115299222",
    "title": "响应式Web设计",
    "url": "https://api.douban.com/v2/book/20390374",
    "alt_title": "Responsive Web Design with HTML5 and CSS3",
    "author_intro": "Ben Frain是一名具有十多年经验的网页设计师和前端工程师，直接与世界各地的客户和设计机构并肩工作。同时他还是一名技术记者，定期为一些关注Mac平台、前沿科技、网页设计和航空技术的刊物撰稿。\n在此之前，他曾是一名怀才不遇的（而且谦虚谨慎的）电视演员，毕业于索尔福德大学的媒体与表演专业。他写了四部（自认为）同样被低估的剧本，而且始终心怀能卖出一部的信念（尽管不像最初那么强烈了）。\n工作之余，在身体（和妻子）允许的情况下，他喜欢玩室内足球。 他的个人网站是www.benfrain.com，Twitter地址是twitter.com/benfrain。",
    "summary": "随着iPad mini的发布，又一个新的屏幕尺寸诞生了。用不着全面统计，你就会发现移动互联网时代众多的屏幕规格，从智能手机的3、4、5英寸，到平板电脑的7、8、9、10英寸，再到笔记本和台式机的13至30英寸，绝非目前单一的固定或流式布局所能应付。于是，响应式设计应运而生，而且它也将成为移动互联网时代前端设计与开发人员的一门必修课。\n本书堪称学习响应式Web设计的难得佳作。它不仅全面、细致、图文并茂地介绍了响应式设计相关的技术，比如媒体查询、流式布局、弹性媒体和弹性字体等，还把近几年来Web设计领域公认的最佳设计理念有机地融入到了实例当中，比如移动先行（Mobile First）、渐进增强、平稳退化、无障碍设计等。更加难得的是，本书以设计跨屏幕的网页（响应式设计）为出发点，以点带面，把如今Web设计领域两大标准的最新版本HTML5和CSS3也纳入其中，读者在掌握先进设计方法的同时也能掌握最新的设计技术（比如使用新的HTML5结构化语义标记、嵌入媒体、响应式视频，以及CSS3的新选择器、特效、过渡、变形和动画等），从而可以免除重复学习新标准之苦，让自己一步跨入Web设计领域的最前沿。无论你想学习响应式Web设计，还是学习HTML5和CSS3的实际应用，本书都能满足你的需要，是毋庸置疑的明智之选。\n说到底，响应式Web设计并非一门独立的技术，而只是现有技术的一个组合应用。只要有一点HTML和CSS基础的读者都能顺利地掌握它。对于中、高级的前端设计和开发人员，翻阅本书也有助于理清自己的知识脉络，对这个新的设计理念获得更全面、深入的理解和把握。\n习惯移动阅读的读者，可访问图灵社区，购买本书电子版：http://www.ituring.com.cn/book/1055",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "49.00元"
  },
  "9787115437303": {
    "rating": { "max": 10, "numRaters": 134, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["陈屹"],
    "pubdate": "2016-11-1",
    "tags": [
      { "count": 161, "name": "React", "title": "React" },
      { "count": 74, "name": "Web前端", "title": "Web前端" },
      { "count": 66, "name": "JavaScript", "title": "JavaScript" },
      { "count": 39, "name": "前端", "title": "前端" },
      { "count": 38, "name": "前端开发", "title": "前端开发" },
      { "count": 24, "name": "编程", "title": "编程" },
      { "count": 23, "name": "Web开发", "title": "Web开发" },
      { "count": 22, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29162154.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章 初入React世界1\n1.1 React简介1\n1.1.1 专注视图层1\n1.1.2 Virtual DOM1\n1.1.3 函数式编程2\n1.2 JSX语法3\n1.2.1 JSX的由来3\n1.2.2 JSX基本语法7\n1.3 React组件11\n1.3.1 组件的演变11\n1.3.2 React组件的构建18\n1.4 React数据流21\n1.4.1 state21\n1.4.2 props23\n1.5 React生命周期29\n1.5.1 挂载或卸载过程29\n1.5.2 数据更新过程30\n1.5.3 整体流程33\n1.6 React与DOM34\n1.6.1 ReactDOM35\n1.6.2 ReactDOM的不稳定方法36\n1.6.3 refs38\n1.6.4 React之外的DOM操作40\n1.7 组件化实例：Tabs组件41\n1.8 小结47\n第2章 漫淡React48\n2.1 事件系统48\n2.1.1 合成事件的绑定方式48\n2.1.2 合成事件的实现机制49\n2.1.3 在React中使用原生事件51\n2.1.4 合成事件与原生事件混用51\n2.1.5 对比React合成事件与JavaScript原生事件54\n2.2 表单55\n2.2.1 应用表单组件55\n2.2.2 受控组件60\n2.2.3 非受控组件61\n2.2.4 对比受控组件和非受控组件62\n2.2.5 表单组件的几个重要属性63\n2.3 样式处理64\n2.3.1 基本样式设置64\n2.3.2 CSS Modules66\n2.4 组件间通信74\n2.4.1 父组件向子组件通信74\n2.4.2 子组件向父组件通信75\n2.4.3 跨级组件通信77\n2.4.4 没有嵌套关系的组件通信79\n2.5 组件间抽象81\n2.5.1 mixin81\n2.5.2 高阶组件86\n2.5.3 组合式组件开发实践93\n2.6 组件性能优化97\n2.6.1 纯函数97\n2.6.2 PureRender100\n2.6.3 Immutable103\n2.6.4 key109\n2.6.5 react—addons—perf110\n2.7 动画111\n2.7.1 CSS动画与JavaScript动画111\n2.7.2 玩转ReactTransition113\n2.7.3 缓动函数116\n2.8 自动化测试121\n2.8.1 Jest121\n2.8.2 Enzyme124\n2.8.3 自动化测试125\n2.9 组件化实例：优化Tabs组件125\n2.10 小结133\n第3章 解读React源码134\n3.1 初探React源码134\n3.2 Virtual DOM模型137\n3.2.1 创建React元素138\n3.2.2 初始化组件入口140\n3.2.3 文本组件141\n3.2.4 DOM标签组件144\n3.2.5 自定义组件150\n3.3 生命周期的管理艺术151\n3.3.1 初探React生命周期152\n3.3.2 详解React生命周期152\n3.3.3 无状态组件163\n3.4 解密setState机制164\n3.4.1 setState异步更新164\n3.4.2 setState循环调用风险165\n3.4.3 setState调用栈166\n3.4.4 初识事务168\n3.4.5 解密setState170\n3.5 diff算法172\n3.5.1 传统diff算法172\n3.5.2 详解diff172\n3.6 ReactPatch方法181\n3.7 小结183\n第4章 认识Flux架构模式184\n4.1 React独立架构184\n4.2 MV*与Flux190\n4.2.1 MVC／MVVM190\n4.2.2 Flux的解决方案193\n4.3 Flux基本概念194\n4.4 Flux应用实例198\n4.4.1 初始化目录结构198\n4.4.2 设计store198\n4.4.3 设计actionCreator200\n4.4.4 构建controller—view202\n4.4.5 重构view203\n4.4.6 添加单元测试205\n4.5 解读Flux206\n4.5.1 Flux核心思想206\n4.5.2 Flux的不足207\n4.6 小结207\n第5章 深入Redux应用架构208\n5.1 Redux简介208\n5.1.1 Redux是什么208\n5.1.2 Redux三大原则209\n5.1.3 Redux核心API210\n5.1.4 与React绑定211\n5.1.5 增强Flux的功能212\n5.2 Reduxmiddleware212\n5.2.1 middleware的由来212\n5.2.2 理解middleware机制213\n5.3 Redux异步流217\n5.3.1 使用middleware简化异步请求217\n5.3.2 使用middleware处理复杂异步流221\n5.4 Redux与路由224\n5.4.1 React Router225\n5.4.2 React Router Redux227\n5.5 Redux与组件229\n5.5.1 容器型组件229\n5.5.2 展示型组件229\n5.5.3 Redux中的组件230\n5.6 Redux应用实例231\n5.6.1 初始化Redux项目231\n5.6.2 划分目录结构232\n5.6.3 设计路由234\n5.6.4 让应用跑起来235\n5.6.5 优化构建脚本239\n5.6.6 添加布局文件239\n5.6.7 准备首页的数据242\n5.6.8 连接Redux245\n5.6.9 引入Redux Devtools250\n5.6.10 利用middleware实现Ajax\n请求发送251\n5.6.11 请求本地的数据252\n5.6.12 页面之间的跳转253\n5.6.13 优化与改进256\n5.6.14 添加单元测试257\n5.7 小结258\n第6章 Redux高阶运用259\n6.1 高阶reducer259\n6.1.1 reducer的复用259\n6.1.2 reducer的增强261\n6.2 Redux与表单262\n6.2.1 使用redux—form—utils减少创建表单的冗余代码263\n6.2.2 使用redux—form完成表单的异步验证265\n6.2.3 使用高阶reducer为现有模块引入表单功能267\n6.3 ReduxCRUD实战268\n6.3.1 准备工作268\n6.3.2 使用Table组件完成“查”功能269\n6.3.3 使用Modal组件完成“增”与“改”274\n6.3.4 巧用Modal实现数据的删除确认277\n6.3.5 善用promise玩转Redux异步事件流278\n6.4 Redux性能优化279\n6.4.1 Reselect280\n6.4.2 Immutable Redux282\n6.4.3 Reducer性能优化282\n6.5 解读Redux284\n6.5.1 参数归一化285\n6.5.2 初始状态及getState286\n6.5.3 subscribe286\n6.5.4 dispatch287\n6.5.5 replaceReducer288\n6.6 解读react—redux288\n6.6.1 Provider288\n6.6.2 connect290\n6.6.3 代码热替换293\n6.7 小结294\n第7章 React服务端渲染295\n7.1 React与服务端模板295\n7.1.1 什么是服务端渲染295\n7.1.2 react—view296\n7.1.3 react—view源码解读296\n7.2 React服务端渲染299\n7.2.1 玩转Node.js300\n7.2.2 React—Router和Koa—Router统一303\n7.2.3 同构数据处理的探讨306\n7.3 小结307\n第8章 玩转React可视化308\n8.1 React结合Canvas和SVG308\n8.1.1 Canvas与SVG308\n8.1.2 在React中的Canvas310\n8.1.3 React中的SVG311\n8.2 React与可视化组件316\n8.2.1 包装已有的可视化库316\n8.2.2 使用D3绘制UI部分317\n8.2.3 使用React绘制UI部分319\n8.3 Recharts组件化的原理322\n8.3.1 声明式的标签323\n8.3.2 贴近原生的配置项325\n8.3.3 接口式的API326\n8.4 小结328\n附录A 开发环境329\n附录B 编码规范345\n附录C Koamiddleware349",
    "pages": "351",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29162154.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29162154.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29162154.jpg"
    },
    "alt": "https://book.douban.com/subject/26918038/",
    "id": "26918038",
    "publisher": "人民邮电出版社",
    "isbn10": "7115437300",
    "isbn13": "9787115437303",
    "title": "深入React技术栈",
    "url": "https://api.douban.com/v2/book/26918038",
    "alt_title": "",
    "author_intro": "陈屹，前端架构师，就职于阿里巴巴。热衷开源事业，长年专注于前端架构、数据可视化、Node.js等领域，知乎专栏pure render的创办人。",
    "summary": "全面讲述React技术栈的第一本原创图书，pure render专栏主创倾力打造\n覆盖React、Flux、Redux及可视化，帮助开发者在实践中深入理解技术和源码\n前端组件化主流解决方案，一本书玩转React“全家桶”\n本书讲解了非常多的内容，不仅介绍了面向普通用户的API、应用架构和周边工具，还深入介绍了底层实现。此外，本书非常重视实战，每一节都有实际的例子，细节丰富。我从这本书里学到了很多东西，强烈推荐！\n——阮一峰，蚂蚁金服技术专家，国内技术圈知名博主，《ES 6标准入门（第2版）》作者\nReact从诞生起就颠覆了诸多传统前端开发的“铁律”，这种破旧立新开启了前端开发全新的时代。它的用法和理念，代表了现在和未来几年前端技术的潮流风向。如果不想落伍，最好进行系统学习。实践出真知，从牛人的实践中收获自己的真知，恐怕是最好的捷径。这是我看到的第一本React中文原创著作，读来倍感亲切。\n——张克军，豆瓣前端专家，国内技术圈知名博主，前端布道师\n本书内容翔实，一扫“文档说明书”之风，有大量作者的实战经验。由浅入深，无论你是 React 初学者，还是进阶人士，本书都值得一读！\n——寸志，陆金所前端架构师，《前端外刊评论》发起人\n本书从几个维度去介绍 React。一是作为 View 库，它怎么实现组件化，以及它背后的实现原理。二是扩展到 Flux 应用架构及重要的衍生品 Redux，它们怎么与 React 结合做应用开发。三是对 React 与 server 的碰撞产生的一些思考。四是讲述它在可视化方面的优势与劣势。\n本书适合有一定经验的前端开发人员阅读。\n陈屹\n前端架构师，就职于阿里巴巴。热衷开源事业，长年专注于前端架构、数据可视化、Node.js等领域，知乎专栏pure render的创办人。",
    "series": { "id": "13000", "title": "图灵原创" },
    "price": "CNY 79.00"
  },
  "9787115335500": {
    "rating": { "max": 10, "numRaters": 845, "average": "8.5", "min": 0 },
    "subtitle": "",
    "author": ["朴灵"],
    "pubdate": "2013-12-1",
    "tags": [
      { "count": 825, "name": "node.js", "title": "node.js" },
      { "count": 478, "name": "JavaScript", "title": "JavaScript" },
      { "count": 280, "name": "Node.js", "title": "Node.js" },
      { "count": 231, "name": "编程", "title": "编程" },
      { "count": 190, "name": "Web", "title": "Web" },
      { "count": 153, "name": "计算机", "title": "计算机" },
      { "count": 129, "name": "nodejs", "title": "nodejs" },
      { "count": 85, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27269296.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章　Node简介　　1\n1.1 　Node的诞生历程　　1\n1.2 　Node的命名与起源　　1\n1.2.1 　为什么是JavaScript　　2\n1.2.2 　为什么叫Node　　2\n1.3 　Node给JavaScript带来的意义　　2\n1.4 　Node的特点　　4\n1.4.1 　异步I/O　　4\n1.4.2 　事件与回调函数　　6\n1.4.3 　单线程　　7\n1.4.4 　跨平台　　7\n1.5 　Node的应用场景　　8\n1.5.1 　I/O密集型　　8\n1.5.2 　是否不擅长CPU密集型业务　　8\n1.5.3 　与遗留系统和平共处　　10\n1.5.4 　分布式应用　　10\n1.6 　Node的使用者　　10\n1.7 　参考资源　　11\n第2章　模块机制　　12\n2.1 　CommonJS规范　　13\n2.1.1 　CommonJS的出发点　　13\n2.1.2 　CommonJS的模块规范　　14\n2.2 　Node的模块实现　　15\n2.2.1 　优先从缓存加载　　16\n2.2.2 　路径分析和文件定位　　16\n2.2.3 　模块编译　　18\n2.3 　核心模块　　20\n2.3.1 　JavaScript核心模块的编译过程　　21\n2.3.2 　C/C++核心模块的编译过程　　22\n2.3.3 　核心模块的引入流程　　25\n2.3.4 　编写核心模块　　25\n2.4 　C/C++扩展模块　　27\n2.4.1 　前提条件　　28\n2.4.2 　C/C++扩展模块的编写　　29\n2.4.3 　C/C++扩展模块的编译　　30\n2.4.4 　C/C++扩展模块的加载　　31\n2.5 　模块调用栈　　32\n2.6 　包与NPM　　33\n2.6.1 　包结构　　34\n2.6.2 　包描述文件与NPM　　34\n2.6.3 　NPM常用功能　　37\n2.6.4 　局域NPM　　42\n2.6.5 　NPM潜在问题　　43\n2.7 　前后端共用模块　　44\n2.7.1 　模块的侧重点　　44\n2.7.2 　AMD规范　　44\n2.7.3 　CMD规范　　45\n2.7.4 　兼容多种模块规范　　45\n2.8 　总结　　46\n2.9 　参考资源　　46\n第3章　异步I/O　　47\n3.1 　为什么要异步I/O　　47\n3.1.1 　用户体验　　48\n3.1.2 　资源分配　　49\n3.2 　异步I/O实现现状　　50\n3.2.1 　异步I/O与非阻塞I/O　　50\n3.2.2 　理想的非阻塞异步I/O　　54\n3.2.3 　现实的异步I/O　　54\n3.3 　Node的异步I/O　　56\n3.3.1 　事件循环　　56\n3.3.2 　观察者　　56\n3.3.3 　请求对象　　57\n3.3.4 　执行回调　　59\n3.3.5 　小结　　60\n3.4 　非I/O的异步API　　60\n3.4.1 　定时器　　60\n3.4.2 　process.nextTick()　　61\n3.4.3 　setImmediate()　　62\n3.5 　事件驱动与高性能服务器　　63\n3.6 　总结　　65\n3.7 　参考资源　　65\n第4章　异步编程　　66\n4.1 　函数式编程　　66\n4.1.1 　高阶函数　　66\n4.1.2 　偏函数用法　　67\n4.2 　异步编程的优势与难点　　68\n4.2.1 　优势　　69\n4.2.2 　难点　　70\n4.3 　异步编程解决方案　　74\n4.3.1 　事件发布/订阅模式　　74\n4.3.2 　Promise/Deferred模式　　82\n4.3.3 　流程控制库　　93\n4.4 　异步并发控制　　105\n4.4.1 　bagpipe的解决方案　　105\n4.4.2 　async的解决方案　　109\n4.5 　总结　　110\n4.6 　参考资源　　110\n第5章　内存控制　　111\n5.1 　V8的垃圾回收机制与内存限制　　111\n5.1.1 　Node与V8　　112\n5.1.2 　V8的内存限制　　112\n5.1.3 　V8的对象分配　　112\n5.1.4 　V8的垃圾回收机制　　113\n5.1.5 　查看垃圾回收日志　　119\n5.2 　高效使用内存　　121\n5.2.1 　作用域　　121\n5.2.2 　闭包　　123\n5.2.3 　小结　　124\n5.3 　内存指标　　124\n5.3.1 　查看内存使用情况　　124\n5.3.2 　堆外内存　　126\n5.3.3 　小结　　127\n5.4 　内存泄漏　　127\n5.4.1 　慎将内存当做缓存　　127\n5.4.2 　关注队列状态　　130\n5.5 　内存泄漏排查　　130\n5.5.1 　node-heapdump　　131\n5.5.2 　node-memwatch　　132\n5.5.3 　小结　　135\n5.6 　大内存应用　　135\n5.7 　总结　　136\n5.8 　参考资源　　136\n第6章 　理解Buffer　　137\n6.1 　Buffer结构　　137\n6.1.1 　模块结构　　137\n6.1.2 　Buffer对象　　138\n6.1.3 　Buffer内存分配　　139\n6.2 　Buffer的转换　　141\n6.2.1 　字符串转Buffer　　141\n6.2.2 　Buffer转字符串　　142\n6.2.3 　Buffer不支持的编码类型　　142\n6.3 　Buffer的拼接　　143\n6.3.1 　乱码是如何产生的　　144\n6.3.2 　setEncoding()与string_decoder()　　144\n6.3.3 　正确拼接Buffer　　145\n6.4 　Buffer与性能　　146\n6.5 　总结　　149\n6.6 　参考资源　　149\n第7章　网络编程　　150\n7.1 　构建TCP服务　　150\n7.1.1 　TCP　　150\n7.1.2 　创建TCP服务器端　　151\n7.1.3 　TCP服务的事件　　153\n7.2 　构建UDP服务　　154\n7.2.1 　创建UDP套接字　　154\n7.2.2 　创建UDP服务器端　　154\n7.2.3 　创建UDP客户端　　155\n7.2.4 　UDP套接字事件　　155\n7.3 　构建HTTP服务　　155\n7.3.1 　HTTP　　156\n7.3.2 　http模块　　157\n7.3.3 　HTTP客户端　　161\n7.4 　构建WebSocket服务　　163\n7.4.1 　WebSocket握手　　164\n7.4.2 　WebSocket数据传输　　167\n7.4.3 　小结　　169\n7.5 　网络服务与安全　　169\n7.5.1 　TLS/SSL　　170\n7.5.2 　TLS服务　　172\n7.5.3 　HTTPS服务　　173\n7.6 　总结　　175\n7.7 　参考资源　　176\n第8章　构建Web应用　　177\n8.1 　基础功能　　177\n8.1.1 　请求方法　　178\n8.1.2 　路径解析　　179\n8.1.3 　查询字符串　　180\n8.1.4 　Cookie　　181\n8.1.5 　Session　　184\n8.1.6 　缓存　　190\n8.1.7 　Basic认证　　193\n8.2 　数据上传　　195\n8.2.1 　表单数据　　195\n8.2.2 　其他格式　　196\n8.2.3 　附件上传　　197\n8.2.4 　数据上传与安全　　199\n8.3 　路由解析　　201\n8.3.1 　文件路径型　　202\n8.3.2 　MVC　　202\n8.3.3 　RESTful　　207\n8.4 　中间件　　210\n8.4.1 　异常处理　　214\n8.4.2 　中间件与性能　　215\n8.4.3 　小结　　216\n8.5 　页面渲染　　217\n8.5.1 　内容响应　　217\n8.5.2 　视图渲染　　219\n8.5.3 　模板　　220\n8.5.4 　Bigpipe　　231\n8.6 　总结　　235\n8.7 　参考资源　　235\n第9章　玩转进程　　236\n9.1 　服务模型的变迁　　236\n9.1.1 　石器时代：同步　　236\n9.1.2 　青铜时代：复制进程　　237\n9.1.3 　白银时代：多线程　　237\n9.1.4 　黄金时代：事件驱动　　237\n9.2 　多进程架构　　238\n9.2.1 　创建子进程　　239\n9.2.2 　进程间通信　　240\n9.2.3 　句柄传递　　242\n9.2.4 　小结　　247\n9.3 　集群稳定之路　　248\n9.3.1 　进程事件　　248\n9.3.2 　自动重启　　249\n9.3.3 　负载均衡　　254\n9.3.4 　状态共享　　255\n9.4 　Cluster模块　　257\n9.4.1 　Cluster工作原理　　258\n9.4.2 　Cluster事件　　259\n9.5 　总结　　259\n9.6 　参考资源　　260\n第10章　测试　　261\n10.1 　单元测试　　261\n10.1.1 　单元测试的意义　　261\n10.1.2 　单元测试介绍　　263\n10.1.3 　工程化与自动化　　276\n10.1.4 　小结　　277\n10.2 　性能测试　　278\n10.2.1 　基准测试　　278\n10.2.2 　压力测试　　280\n10.2.3 　基准测试驱动开发　　281\n10.2.4 　测试数据与业务数据的转换　　283\n10.3 　总结　　284\n10.4 　参考资源　　284\n第11章　产品化　　285\n11.1 　项目工程化　　285\n11.1.1 　目录结构　　285\n11.1.2 　构建工具　　286\n11.1.3 　编码规范　　289\n11.1.4 　代码审查　　289\n11.2 　部署流程　　290\n11.2.1 　部署环境　　291\n11.2.2 　部署操作　　291\n11.3 　性能　　293\n11.3.1 　动静分离　　293\n11.3.2 　启用缓存　　294\n11.3.3 　多进程架构　　294\n11.3.4 　读写分离　　295\n11.4 　日志　　295\n11.4.1 　访问日志　　295\n11.4.2 　异常日志　　296\n11.4.3 　日志与数据库　　299\n11.4.4 　分割日志　　299\n11.4.5 　小结　　299\n11.5 　监控报警　　299\n11.5.1 　监控　　300\n11.5.2 　报警的实现　　302\n11.5.3 　监控系统的稳定性　　303\n11.6 　稳定性　　303\n11.7 　异构共存　　304\n11.8 　总结　　305\n11.9 　参考资源　　305\n附录A 　安装Node　　306\nA.1 　Windows系统下的Node安装　　306\nA.2 　Mac系统下Node的安装　　307\nA.3 　Linux系统下Node的安装　　308\nA.4 　总结　　309\nA.5 　参考资源　　309\n附录B 　调试Node　　310\nB.1 　Debugger　　310\nB.2 　Node Inspector　　311\nB.2.1 　安装Node Inspector　　312\nB.2.2 　错误堆栈　　312\nB.3 　总结　　313\n附录C 　Node编码规范　　314\nC.1 　根源　　314\nC.2 　编码规范　　315\nC.2.1 　空格与格式　　315\nC.2.2 　命名规范　　317\nC.2.3 　比较操作　　318\nC.2.4 　字面量　　318\nC.2.5 　作用域　　318\nC.2.6 　数组与对象　　319\nC.2.7 　异步　　320\nC.2.8 　类与模块　　320\nC.2.9 　注解规范　　321\nC.3 　最佳实践　　321\nC.3.1 　冲突的解决原则　　321\nC.3.2 　给编辑器设置检测工具　　321\nC.3.3 　版本控制中的hook　　322\nC.3.4 　持续集成　　322\nC.4 　总结　　322\nC.5 　参考资源　　323\n附录D 　搭建局域NPM仓库　　324\nD.1 　NPM仓库的安装　　325\nD.1.1 　安装Erlang和CouchDB　　325\nD.1.2 　搭建NPM仓库　　326\nD.2 　高阶应用　　328\nD.2.1 　镜像仓库　　328\nD.2.2 　私有模块应用　　328\nD.2.3 　纯私有仓库　　329\nD.3 　总结　　331\nD.4 　参考资源　　332",
    "ebook_url": "https://read.douban.com/ebook/12053349/",
    "pages": "332",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27269296.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27269296.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27269296.jpg"
    },
    "alt": "https://book.douban.com/subject/25768396/",
    "id": "25768396",
    "publisher": "人民邮电出版社",
    "isbn10": "7115335508",
    "isbn13": "9787115335500",
    "title": "深入浅出Node.js",
    "url": "https://api.douban.com/v2/book/25768396",
    "alt_title": "",
    "author_intro": "朴灵\n真名田永强，文艺型码农，就职于阿里巴巴数据平台，资深工程师，Node.js布道者，写了多篇文章介绍Node.js的细节。活跃于CNode社区，是线下会议NodeParty的组织者和JSConf China（沪JS和京JS）的组织者之一。热爱开源，多个Node.js模块的作者。个人GitHub地址：http://github.com/JacksonTian。叩首问路，码梦为生。",
    "summary": "本书从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。\n本书适合想深入了解 Node 的人员阅读。",
    "ebook_price": "39.99",
    "series": { "id": "13000", "title": "图灵原创" },
    "price": "CNY 69.00"
  },
  "9787302423287": {
    "rating": { "max": 10, "numRaters": 1731, "average": "8.7", "min": 0 },
    "subtitle": "",
    "author": ["周志华"],
    "pubdate": "2016-1-1",
    "tags": [
      { "count": 2629, "name": "机器学习", "title": "机器学习" },
      { "count": 1231, "name": "人工智能", "title": "人工智能" },
      { "count": 651, "name": "数据挖掘", "title": "数据挖掘" },
      { "count": 582, "name": "计算机", "title": "计算机" },
      { "count": 521, "name": "数据分析", "title": "数据分析" },
      { "count": 516, "name": "MachineLearning", "title": "MachineLearning" },
      { "count": 432, "name": "计算机科学", "title": "计算机科学" },
      { "count": 393, "name": "AI", "title": "AI" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28735609.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "目录\n第1章 1\n1.1 引言 1\n1.2 基本术 2\n1.3 假设空间 4\n1.4 归纳偏好 6\n1.5 发展历程 10\n1.6 应用现状 13\n1.7 阅读材料 16\n习题 19\n参考文献 20\n休息一会儿 22\n第2章 模型评估与选择 23\n2.1 经验误差与过拟合 23\n2.2 评估方法 24\n2.2.1 留出法 25\n2.2.2 交叉验证法 26\n2.2.3 自助法 27\n2.2.4 调参与最终模型 28\n2.3 性能度量 28\n2.3.1 错误率与精度 29\n2.3.2 查准率、查全率与F1 30\n2.3.3 ROC与AUC 33\n2.3.4 代价敏感错误率与代价曲线 35\n2.4 比较检验 37\n2.4.1 假设检验 37\n2.4.2 交叉验证t检验 40\n2.4.3 McNemar检验 41\n2.4.4 Friedman检验与后续检验 42\n2.5 偏差与方差 44\n2.6 阅读材料 46\n习题 48\n参考文献 49\n休息一会儿 51\n第3章 线性模型 53\n3.1 基本形式 53\n3.2 线性回归 53\n3.3 对数几率回归 57\n3.4 线性判别分析 60\n3.5 多分类学习 63\n3.6 类别不平衡问题 66\n3.7 阅读材料 67\n习题 69\n参考文献 70\n休息一会儿 72\n第4章 决策树 73\n4.1 基本流程 73\n4.2 划分选择 75\n4.2.1 信息增益 75\n4.2.2 增益率 77\n4.2.3 基尼指数 79\n4.3 剪枝处理 79\n4.3.1 预剪枝 80\n4.3.2 后剪枝 82\n4.4 连续与缺失值 83\n4.4.1 连续值处理 83\n4.4.2 缺失值处理 85\n4.5 多变量决策树 88\n4.6 阅读材料 92\n习题 93\n参考文献 94\n休息一会儿 95\n第5章 神经网络 97\n5.1 神经元模型 97\n5.2 感知机与多层网络 98\n5.3 误差逆传播算法 101\n5.4 全局最小与局部极小 106\n5.5 其他常见神经网络 108\n5.5.1 RBF网络 108\n5.5.2 ART网络 108\n5.5.3 SOM网络 109\n5.5.4 级联相关网络 110\n5.5.5 Elman网络 111\n5.5.6 Boltzmann机 111\n5.6 深度学习 113\n5.7 阅读材料 115\n习题 116\n参考文献 117\n休息一会儿 120\n第6章 支持向量机 121\n6.1 间隔与支持向量 121\n6.2 对偶问题 123\n6.3 核函数 126\n6.4 软间隔与正则化 129\n6.5 支持向量回归 133\n6.6 核方法 137\n6.7 阅读材料 139\n习题 141\n参考文献 142\n休息一会儿 145\n第7章 贝叶斯分类器 147\n7.1 贝叶斯决策论 147\n7.2 极大似然估计 149\n7.3 朴素贝叶斯分类器 150\n7.4 半朴素贝叶斯分类器 154\n7.5 贝叶斯网 156\n7.5.1 结构 157\n7.5.2 学习 159\n7.5.3 推断 161\n7.6 EM算法 162\n7.7 阅读材料 164\n习题 166\n参考文献 167\n休息一会儿 169\n第8章 集成学习 171\n8.1 个体与集成 171\n8.2 Boosting 173\n8.3 Bagging与随机森林 178\n8.3.1 Bagging 178\n8.3.2 随机森林 179\n8.4 结合策略 181\n8.4.1 平均法 181\n8.4.2 投票法 182\n8.4.3 学习法 183\n8.5 多样性 185\n8.5.1 误差--分歧分解 185\n8.5.2 多样性度量 186\n8.5.3 多样性增强 188\n8.6 阅读材料 190\n习题 192\n参考文献 193\n休息一会儿 196\n第9章 聚类 197\n9.1 聚类任务 197\n9.2 性能度量 197\n9.3 距离计算 199\n9.4 原型聚类 202\n9.4.1 k均值算法 202\n9.4.2 学习向量量化 204\n9.4.3 高斯混合聚类 206\n9.5 密度聚类 211\n9.6 层次聚类 214\n9.7 阅读材料 217\n习题 220\n参考文献 221\n休息一会儿 224\n第10章 降维与度量学习 225\n10.1 k近邻学习 225\n10.2 低维嵌入 226\n10.3 主成分分析 229\n10.4 核化线性降维 232\n10.5 流形学习 234\n10.5.1 等度量映射 234\n10.5.2 局部线性嵌入 235\n10.6 度量学习 237\n10.7 阅读材料 240\n习题 242\n参考文献 243\n休息一会儿 246\n第11章 特征选择与稀疏学习 247\n11.1 子集搜索与评价 247\n11.2 过滤式选择 249\n11.3 包裹式选择 250\n11.4 嵌入式选择与L$_1$正则化 252\n11.5 稀疏表示与字典学习 254\n11.6 压缩感知 257\n11.7 阅读材料 260\n习题 262\n参考文献 263\n休息一会儿 266\n第12章 计算学习理论 267\n12.1 基础知识 267\n12.2 PAC学习 268\n12.3 有限假设空间 270\n12.3.1 可分情形 270\n12.3.2 不可分情形 272\n12.4 VC维 273\n12.5 Rademacher复杂度 279\n12.6 稳定性 284\n12.7 阅读材料 287\n习题 289\n参考文献 290\n休息一会儿 292\n第13章 半监督学习 293\n13.1 未标记样本 293\n13.2 生成式方法 295\n13.3 半监督SVM 298\n13.4 图半监督学习 300\n13.5 基于分歧的方法 304\n13.6 半监督聚类 307\n13.7 阅读材料 311\n习题 313\n参考文献 314\n休息一会儿 317\n第14章 概率图模型 319\n14.1 隐马尔可夫模型 319\n14.2 马尔可夫随机场 322\n14.3 条件随机场 325\n14.4 学习与推断 328\n14.4.1 变量消去 328\n14.4.2 信念传播 330\n14.5 近似推断 331\n14.5.1 MCMC采样 331\n14.5.2 变分推断 334\n14.6 话题模型 337\n14.7 阅读材料 339\n习题 341\n参考文献 342\n休息一会儿 345\n第15章 规则学习 347\n15.1 基本概念 347\n15.2 序贯覆盖 349\n15.3 剪枝优化 352\n15.4 一阶规则学习 354\n15.5 归纳逻辑程序设计 357\n15.5.1 最小一般泛化 358\n15.5.2 逆归结 359\n15.6 阅读材料 363\n习题 365\n参考文献 366\n休息一会儿 369\n第16章 强化学习 371\n16.1 任务与奖赏 371\n16.2 $K$-摇臂赌博机 373\n16.2.1 探索与利用 373\n16.2.2 $\\epsilon $-贪心 374\n16.2.3 Softmax 375\n16.3 有模型学习 377\n16.3.1 策略评估 377\n16.3.2 策略改进 379\n16.3.3 策略迭代与值迭代 381\n16.4 免模型学习 382\n16.4.1 蒙特卡罗强化学习 383\n16.4.2 时序差分学习 386\n16.5 值函数近似 388\n16.6 模仿学习 390\n16.6.1 直接模仿学习 391\n16.6.2 逆强化学习 391\n16.7 阅读材料 393\n习题 394\n参考文献 395\n休息一会儿 397\n附录 399\nA 矩阵 399\nB 优化 403\nC 概率分布 409\n后记 417\n索引 419",
    "pages": "425",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28735609.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28735609.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28735609.jpg"
    },
    "alt": "https://book.douban.com/subject/26708119/",
    "id": "26708119",
    "publisher": "清华大学出版社",
    "isbn10": "7302423288",
    "isbn13": "9787302423287",
    "title": "机器学习",
    "url": "https://api.douban.com/v2/book/26708119",
    "alt_title": "",
    "author_intro": "周志华，南京大学教授，计算机科学与技术系副主任，软件新技术国家重点实验室常务副主任，机器学习与数据挖掘研究所（LAMDA）所长，校、系学术委员会委员；ACM杰出科学家，IEEE Fellow，IAPR Fellow，中国计算机学会会士；长江学者特聘教授，国家杰出青年基金获得者。2007年创建南京大学机器学习与数据挖掘研究所（LAMDA），2010年11月任软件新技术国家重点实验室常务副主任，2013年5月任计算机系副主任。",
    "summary": "机器学习是计算机科学与人工智能的重要分支领域. 本书作为该领域的入门教材，在内容上尽可能涵盖机器学习基础知识的各方面。 为了使尽可能多的读者通过本书对机器学习有所了解, 作者试图尽可能少地使用数学知识. 然而, 少量的概率、统计、代数、优化、逻辑知识似乎不可避免. 因此, 本书更适合大学三年级以上的理工科本科生和研究生, 以及具有类似背景的对机器学 习感兴趣的人士. 为方便读者, 本书附录给出了一些相关数学基础知识简介.\n全书共16 章，大致分为3 个部分：第1 部分（第1～3 章）介绍机器学习的基础知识；第2 部分（第4～10 章）讨论一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11～16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习等.前3章之外的后续各章均相对独立, 读者可根据自己的兴趣和时间情况选择使用. 根据课时情况, 一个学期的本科生课程可考虑讲授前9章或前10章; 研究生课程则不妨使用全书.\n书中除第1章外, 每章都给出了十道习题. 有的习题是帮助读者巩固本章学习, 有的是为了引导读者扩展相关知识. 一学期的一般课程可使用这些习题, 再辅以两到三个针对具体数据集的大作业. 带星号的习题则有相当难度, 有些并无现成答案, 谨供富有进取心的读者启发思考.\n本书可作为高等院校计算机、自动化及相关专业的本科生或研究生教材，也可供对机器学习感兴趣的研究人员和工程技术人员阅读参考。",
    "price": "88.00元"
  },
  "9787115317957": {
    "rating": { "max": 10, "numRaters": 946, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["Peter Harrington"],
    "pubdate": "2013-6",
    "tags": [
      { "count": 1601, "name": "机器学习", "title": "机器学习" },
      { "count": 688, "name": "python", "title": "python" },
      { "count": 382, "name": "MachineLearning", "title": "MachineLearning" },
      { "count": 381, "name": "数据挖掘", "title": "数据挖掘" },
      { "count": 341, "name": "算法", "title": "算法" },
      { "count": 235, "name": "数据分析", "title": "数据分析" },
      { "count": 202, "name": "计算机", "title": "计算机" },
      { "count": 154, "name": "编程", "title": "编程" }
    ],
    "origin_title": "Machine Learning in Action",
    "image": "https://img3.doubanio.com/view/subject/m/public/s26696371.jpg",
    "binding": "",
    "translator": ["李锐", "李鹏", "曲亚东", "王斌"],
    "catalog": "目　录\n\n第一部分　分类\n第1章　机器学习基础　　2\n1.1 　何谓机器学习　　3\n1.1.1 　传感器和海量数据　　4\n1.1.2 　机器学习非常重要　　5\n1.2 　关键术语　　5\n1.3 　机器学习的主要任务　　7\n1.4 　如何选择合适的算法　　8\n1.5 　开发机器学习应用程序的步骤　　9\n1.6 　Python语言的优势　　10\n1.6.1 　可执行伪代码　　10\n1.6.2 　Python比较流行　　10\n1.6.3 　Python语言的特色　　11\n1.6.4 　Python语言的缺点　　11\n1.7 　NumPy函数库基础　　12\n1.8 　本章小结　　13\n第2章　k-近邻算法 　　15\n2.1 　k-近邻算法概述　　15\n2.1.1 　准备：使用Python导入数据　　17\n2.1.2 　从文本文件中解析数据　　19\n2.1.3 　如何测试分类器　　20\n2.2 　示例：使用k-近邻算法改进约会网站的配对效果　　20\n2.2.1 　准备数据：从文本文件中解析数据　　21\n2.2.2 　分析数据：使用Matplotlib创建散点图　　23\n2.2.3 　准备数据：归一化数值　　25\n2.2.4 　测试算法：作为完整程序验证分类器　　26\n2.2.5 　使用算法：构建完整可用系统　　27\n2.3 　示例：手写识别系统　　28\n2.3.1 　准备数据：将图像转换为测试向量　　29\n2.3.2 　测试算法：使用k-近邻算法识别手写数字　　30\n2.4 　本章小结　　31\n第3章　决策树 　　32\n3.1 　决策树的构造　　33\n3.1.1 　信息增益　　35\n3.1.2 　划分数据集　　37\n3.1.3 　递归构建决策树　　39\n3.2 　在Python中使用Matplotlib注解绘制树形图　　42\n3.2.1 　Matplotlib注解　　43\n3.2.2 　构造注解树　　44\n3.3 　测试和存储分类器　　48\n3.3.1 　测试算法：使用决策树执行分类　　49\n3.3.2 　使用算法：决策树的存储　　50\n3.4 　示例：使用决策树预测隐形眼镜类型　　50\n3.5 　本章小结　　52\n第4章　基于概率论的分类方法：朴素贝叶斯 　　53\n4.1 　基于贝叶斯决策理论的分类方法　　53\n4.2 　条件概率　　55\n4.3 　使用条件概率来分类　　56\n4.4 　使用朴素贝叶斯进行文档分类　　57\n4.5 　使用Python进行文本分类　　58\n4.5.1 　准备数据：从文本中构建词向量　　58\n4.5.2 　训练算法：从词向量计算概率　　60\n4.5.3 　测试算法：根据现实情况修改分类器　　62\n4.5.4 　准备数据：文档词袋模型　　64\n4.6 　示例：使用朴素贝叶斯过滤垃圾邮件　　64\n4.6.1 　准备数据：切分文本　　65\n4.6.2 　测试算法：使用朴素贝叶斯进行交叉验证　　66\n4.7 　示例：使用朴素贝叶斯分类器从个人广告中获取区域倾向　　68\n4.7.1 　收集数据：导入RSS源　　68\n4.7.2 　分析数据：显示地域相关的用词　　71\n4.8 　本章小结　　72\n第5章　Logistic回归 　　73\n5.1 　基于Logistic回归和Sigmoid函数的分类　　74\n5.2 　基于最优化方法的最佳回归系数确定　　75\n5.2.1 　梯度上升法　　75\n5.2.2 　训练算法：使用梯度上升找到最佳参数　　77\n5.2.3 　分析数据：画出决策边界　　79\n5.2.4 　训练算法：随机梯度上升　　80\n5.3 　示例：从疝气病症预测病马的死亡率　　85\n5.3.1 　准备数据：处理数据中的缺失值　　85\n5.3.2 　测试算法：用Logistic回归进行分类　　86\n5.4 　本章小结　　88\n第6章　支持向量机　　89\n6.1 　基于最大间隔分隔数据　　89\n6.2 　寻找最大间隔　　91\n6.2.1 　分类器求解的优化问题　　92\n6.2.2 　SVM应用的一般框架　　93\n6.3 　SMO高效优化算法　　94\n6.3.1 　Platt的SMO算法　　94\n6.3.2 　应用简化版SMO算法处理小规模数据集　　94\n6.4 　利用完整Platt SMO算法加速优化　　99\n6.5 　在复杂数据上应用核函数　　105\n6.5.1 　利用核函数将数据映射到高维空间　　106\n6.5.2 　径向基核函数　　106\n6.5.3 　在测试中使用核函数　　108\n6.6 　示例：手写识别问题回顾　　111\n6.7 　本章小结　　113\n第7章　利用AdaBoost元算法提高分类\n性能 　　115\n7.1 　基于数据集多重抽样的分类器　　115\n7.1.1 　bagging：基于数据随机重抽样的分类器构建方法　　116\n7.1.2 　boosting　　116\n7.2 　训练算法：基于错误提升分类器的性能　　117\n7.3 　基于单层决策树构建弱分类器　　118\n7.4 　完整AdaBoost算法的实现　　122\n7.5 　测试算法：基于AdaBoost的分类　　124\n7.6 　示例：在一个难数据集上应用AdaBoost　　125\n7.7 　非均衡分类问题　　127\n7.7.1 　其他分类性能度量指标：正确率、召回率及ROC曲线　　128\n7.7.2 　基于代价函数的分类器决策控制　　131\n7.7.3 　处理非均衡问题的数据抽样方法　　132\n7.8 　本章小结　　132\n第二部分　利用回归预测数值型数据\n第8章　预测数值型数据：回归 　　136\n8.1 　用线性回归找到最佳拟合直线　　136\n8.2 　局部加权线性回归　　141\n8.3 　示例：预测鲍鱼的年龄　　145\n8.4 　缩减系数来“理解”数据　　146\n8.4.1 　岭回归　　146\n8.4.2 　lasso　　148\n8.4.3 　前向逐步回归　　149\n8.5 　权衡偏差与方差　　152\n8.6 　示例：预测乐高玩具套装的价格　　153\n8.6.1 　收集数据：使用Google购物的API　　153\n8.6.2 　训练算法：建立模型　　155\n8.7 　本章小结　　158\n第9章　树回归　　159\n9.1 　复杂数据的局部性建模　　159\n9.2 　连续和离散型特征的树的构建　　160\n9.3 　将CART算法用于回归　　163\n9.3.1 　构建树　　163\n9.3.2 　运行代码　　165\n9.4 　树剪枝　　167\n9.4.1 　预剪枝　　167\n9.4.2 　后剪枝　　168\n9.5 　模型树　　170\n9.6 　示例：树回归与标准回归的比较　　173\n9.7 　使用Python的Tkinter库创建GUI　　176\n9.7.1 　用Tkinter创建GUI　　177\n9.7.2 　集成Matplotlib和Tkinter　　179\n9.8 　本章小结　　182\n第三部分　无监督学习\n第10章　利用K-均值聚类算法对未标注数据分组　　184\n10.1 　K-均值聚类算法　　185\n10.2 　使用后处理来提高聚类性能　　189\n10.3 　二分K-均值算法　　190\n10.4 　示例：对地图上的点进行聚类　　193\n10.4.1 　Yahoo! PlaceFinder API　　194\n10.4.2 　对地理坐标进行聚类　　196\n10.5 　本章小结　　198\n第11章　使用Apriori算法进行关联分析　　200\n11.1 　关联分析　　201\n11.2 　Apriori原理　　202\n11.3 　使用Apriori算法来发现频繁集　　204\n11.3.1 　生成候选项集　　204\n11.3.2 　组织完整的Apriori算法　　207\n11.4 　从频繁项集中挖掘关联规则　　209\n11.5 　示例：发现国会投票中的模式　　212\n11.5.1 　收集数据：构建美国国会投票记录的事务数据集　　213\n11.5.2 　测试算法：基于美国国会投票记录挖掘关联规则　　219\n11.6 　示例：发现毒蘑菇的相似特征　　220\n11.7 　本章小结　　221\n第12章　使用FP-growth算法来高效发现频繁项集　　223\n12.1 　FP树：用于编码数据集的有效方式　　224\n12.2 　构建FP树　　225\n12.2.1 　创建FP树的数据结构　　226\n12.2.2 　构建FP树　　227\n12.3 　从一棵FP树中挖掘频繁项集　　231\n12.3.1 　抽取条件模式基　　231\n12.3.2 　创建条件FP树　　232\n12.4 　示例：在Twitter源中发现一些共现词　　235\n12.5 　示例：从新闻网站点击流中挖掘　　238\n12.6 　本章小结　　239\n第四部分　其他工具\n第13章　利用PCA来简化数据　　242\n13.1 　降维技术　　242\n13.2 　PCA　　243\n13.2.1 　移动坐标轴　　243\n13.2.2 　在NumPy中实现PCA　　246\n13.3 　示例：利用PCA对半导体制造数据降维　　248\n13.4 　本章小结　　251\n第14章　利用SVD简化数据　　252\n14.1 　SVD的应用　　252\n14.1.1 　隐性语义索引　　253\n14.1.2 　推荐系统　　253\n14.2 　矩阵分解　　254\n14.3 　利用Python实现SVD　　255\n14.4 　基于协同过滤的推荐引擎　　257\n14.4.1 　相似度计算　　257\n14.4.2 　基于物品的相似度还是基于用户的相似度？　　260\n14.4.3 　推荐引擎的评价　　260\n14.5 　示例：餐馆菜肴推荐引擎　　260\n14.5.1 　推荐未尝过的菜肴　　261\n14.5.2 　利用SVD提高推荐的效果　　263\n14.5.3 　构建推荐引擎面临的挑战　　265\n14.6 　基于SVD的图像压缩　　266\n14.7 　本章小结　　268\n第15章　大数据与MapReduce　　270\n15.1 　MapReduce：分布式计算的框架　　271\n15.2 　Hadoop流　　273\n15.2.1 　分布式计算均值和方差的mapper　　273\n15.2.2 　分布式计算均值和方差的reducer　　274\n15.3 　在Amazon网络服务上运行Hadoop程序　　275\n15.3.1 　AWS上的可用服务　　276\n15.3.2 　开启Amazon网络服务之旅　　276\n15.3.3 　在EMR上运行Hadoop作业　　278\n15.4 　MapReduce上的机器学习　　282\n15.5 　在Python中使用mrjob来自动化MapReduce　　283\n15.5.1 　mrjob与EMR的无缝集成　　283\n15.5.2 　mrjob的一个MapReduce脚本剖析　　284\n15.6 　示例：分布式SVM的Pegasos算法　　286\n15.6.1 　Pegasos算法　　287\n15.6.2 　训练算法：用mrjob实现MapReduce版本的SVM　　288\n15.7 　你真的需要MapReduce吗？　　292\n15.8 　本章小结　　292\n附录A 　Python入门　　294\n附录B 　线性代数　　303\n附录C 　概率论复习　　309\n附录D 　资源　　312\n索引　　313\n版权声明　　316\n",
    "pages": "332",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s26696371.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s26696371.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s26696371.jpg"
    },
    "alt": "https://book.douban.com/subject/24703171/",
    "id": "24703171",
    "publisher": "人民邮电出版社",
    "isbn10": "711531795X",
    "isbn13": "9787115317957",
    "title": "机器学习实战",
    "url": "https://api.douban.com/v2/book/24703171",
    "alt_title": "Machine Learning in Action",
    "author_intro": "Peter Harrington\n拥有电气工程学士和硕士学位，他曾经在美国加州和中国的英特尔公司工作7年。Peter拥有5项美国专利，在三种学术期刊上发表过文章。他现在是Zillabyte公司的首席科学家，在加入该公司之前，他曾担任2年的机器学习软件顾问。Peter在业余时间还参加编程竞赛和建造3D打印机。",
    "summary": "机器学习是人工智能研究领域中一个极其重要的研究方向，在现今的大数据时代背景下，捕获数据并从中萃取有价值的信息或模式，成为各行业求生存、谋发展的决定性手段，这使得这一过去为分析师和数学家所专属的研究领域越来越为人们所瞩目。\n本书第一部分主要介绍机器学习基础，以及如何利用算法进行分类，并逐步介绍了多种经典的监督学习算法，如k近邻算法、朴素贝叶斯算法、Logistic回归算法、支持向量机、AdaBoost集成方法、基于树的回归算法和分类回归树（CART）算法等。第三部分则重点介绍无监督学习及其一些主要算法：k均值聚类算法、Apriori算法、FP-Growth算法。第四部分介绍了机器学习算法的一些附属工具。\n全书通过精心编排的实例，切入日常工作任务，摒弃学术化语言，利用高效的可复用Python代码来阐释如何处理统计数据，进行数据分析及可视化。通过各种实例，读者可从中学会机器学习的核心算法，并能将其运用于一些策略性任务中，如分类、预测、推荐。另外，还可用它们来实现一些更高级的功能，如汇总和简化等。",
    "price": "69.00元"
  },
  "9787302275954": {
    "rating": { "max": 10, "numRaters": 1644, "average": "9.0", "min": 0 },
    "subtitle": "",
    "author": ["李航"],
    "pubdate": "2012-3",
    "tags": [
      { "count": 2177, "name": "机器学习", "title": "机器学习" },
      { "count": 1675, "name": "统计学习", "title": "统计学习" },
      { "count": 742, "name": "数据挖掘", "title": "数据挖掘" },
      { "count": 729, "name": "统计学", "title": "统计学" },
      { "count": 603, "name": "数学", "title": "数学" },
      { "count": 564, "name": "统计", "title": "统计" },
      { "count": 546, "name": "计算机", "title": "计算机" },
      { "count": 533, "name": "MachineLearning", "title": "MachineLearning" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s9108113.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章 统计学习方法概论\n1.1 统计学习\n1.2 监督学习\n1.3 统计学习三要素\n1.4 模型评估与模型选择\n1.5 i~则化与交叉验证\n1.6 泛化能力\n1.7 生成模型与判别模型\n1.8 分类问题\n1.9 标注问题\n1.10 回归问题\n本章概要\n继续阅读\n习题\n参考文献\n第2章 感知机\n2.1 感知机模型\n2.2 感知机学习策略\n2.3 感知机学习算法\n本章概要\n继续阅读\n习题\n参考文献\n第3章 众近邻法\n3.1 k近邻算法\n3.2 k近邻模型\n3.3 k近邻法的实现：kd树\n本章概要\n继续阅读\n习题\n参考文献\n第4章 朴素贝叶斯法\n4.1 朴素贝叶斯法的学习与分类\n4.2 朴素贝叶斯法的参数估计\n本章概要\n继续阅读\n习题\n参考文献\n第5章 决策树\n第6章 逻辑斯谛回归与最大熵模型\n第7章 支持向量机\n第8章 提升方法\n第9章 em算法及其推广\n第10章 隐马尔可夫模型\n第11章 条件随机场\n第12章 统计学习方法总结\n附录a 梯度下降法\n附录b 牛顿法和拟牛顿法\n附录c 拉格朗日对偶性\n索引",
    "pages": "235",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s9108113.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s9108113.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s9108113.jpg"
    },
    "alt": "https://book.douban.com/subject/10590856/",
    "id": "10590856",
    "publisher": "清华大学出版社",
    "isbn10": "7302275955",
    "isbn13": "9787302275954",
    "title": "统计学习方法",
    "url": "https://api.douban.com/v2/book/10590856",
    "alt_title": "",
    "author_intro": "李航 日本京都大学电气工程系毕业，日本东京大学计算机科学博士。曾任职于日本NEC公司中央研究所，微软亚洲研究院高级研究员及主任研究员，现任华为诺亚方舟实验室首席科学家。北京大学、南开大学、西安交通大学客座教授。研究方向包括信息检索、自然语言处理、统计机器学习及数据挖掘。",
    "summary": "详细介绍支持向量机、Boosting、最大熵、条件随机场等十个统计学习方法。",
    "price": "38.00元"
  },
  "9787121310928": {
    "rating": { "max": 10, "numRaters": 100, "average": "9.3", "min": 0 },
    "subtitle": "",
    "author": ["何海涛"],
    "pubdate": "2017-5",
    "tags": [
      { "count": 106, "name": "面试", "title": "面试" },
      { "count": 76, "name": "算法", "title": "算法" },
      { "count": 65, "name": "计算机", "title": "计算机" },
      { "count": 58, "name": "编程", "title": "编程" },
      { "count": 45, "name": "数据结构", "title": "数据结构" },
      { "count": 38, "name": "找工作", "title": "找工作" },
      { "count": 22, "name": "计算机科学", "title": "计算机科学" },
      { "count": 22, "name": "工作", "title": "工作" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29413793.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章  面试的流程\t1\n1.1  面试官谈面试\t1\n1.2  面试的3种形式\t2\n1.2.1  电话面试\t2\n1.2.2  共享桌面远程面试\t3\n1.2.3  现场面试\t4\n1.3  面试的3个环节\t5\n1.3.1  行为面试环节\t5\n1.3.2  技术面试环节\t10\n1.3.3  应聘者提问环节\t17\n1.4  本章小结\t18\n第2章  面试需要的基础知识\t20\n2.1  面试官谈基础知识\t20\n2.2  编程语言\t21\n2.2.1  C++\t22\n2.2.2  C#\t27\n2.3  数据结构\t36\n2.3.1  数组\t36\n2.3.2  字符串\t47\n2.3.3  链表\t55\n2.3.4  树\t59\n2.3.5  栈和队列\t67\n2.4  算法和数据操作\t71\n2.4.1  递归和循环\t72\n2.4.2  查找和排序\t78\n2.4.3  回溯法\t87\n2.4.4  动态规划与贪婪算法\t93\n2.4.5  位运算\t98\n2.5  本章小结\t103\n第3章  高质量的代码\t104\n3.1  面试官谈代码质量\t104\n3.2  代码的规范性\t105\n3.3  代码的完整性\t106\n3.4  代码的鲁棒性\t132\n3.5  本章小结\t151\n第4章  解决面试题的思路\t153\n4.1  面试官谈面试思路\t153\n4.2  画图让抽象问题形象化\t154\n4.3  举例让抽象问题具体化\t163\n4.4  分解让复杂问题简单化\t184\n4.5  本章小结\t199\n第5章  优化时间和空间效率\t201\n5.1  面试官谈效率\t201\n5.2  时间效率\t202\n5.3  时间效率与空间效率的平衡\t237\n5.4  本章小结\t254\n第6章  面试中的各项能力\t256\n6.1  面试官谈能力\t256\n6.2  沟通能力和学习能力\t257\n6.3  知识迁移能力\t260\n6.4  抽象建模能力\t293\n6.5  发散思维能力\t305\n6.6  本章小结\t313\n第7章  两个面试案例\t315\n7.1  案例一：（面试题67）把字符串转换成整数\t316\n7.2  案例二：（面试题68）树中两个节点的最低公共祖先\t324",
    "pages": "348",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29413793.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29413793.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29413793.jpg"
    },
    "alt": "https://book.douban.com/subject/27008702/",
    "id": "27008702",
    "publisher": "电子工业出版社",
    "isbn10": "7121310929",
    "isbn13": "9787121310928",
    "title": "剑指Offer：名企面试官精讲典型编程题（第2版）",
    "url": "https://api.douban.com/v2/book/27008702",
    "alt_title": "",
    "author_intro": "何海涛，现美国微软总部资深软件工程师，先后在Autodesk、思科、微软中国等跨国企业任职。著有《剑指Offer——名企面试官精讲典型编程题》、《Coding Interviews: Questions, Analysis and Solutions》（本书英文版）等书。多年来从事软件开发工作，对软件设计、开发、调试等均有较深的功底，对 C/C++、C#以及.NET等语言及平台都较为熟悉，对图形图像、CAD、设计模式、项目管理等领域均有专业经验。",
    "summary": "《剑指Offer：名企面试官精讲典型编程题（第2版）》剖析了80个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这5个面试要点。《剑指Offer：名企面试官精讲典型编程题（第2版）》共分7章，主要包括面试的流程，讨论面试每一环节需要注意的问题；面试需要的基础知识，从编程语言、数据结构及算法三方面总结程序员面试知识点；高质量的代码，讨论影响代码质量的3个要素（规范性、完整性和鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况并对非法输入进行合理处理；解决面试题的思路，总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，应聘者可利用画图、举例和分解这3种方法将其化繁为简，先形成清晰思路，再动手编程；优化时间和空间效率，读者将学会优化时间效率及用空间换时间的常用算法，从而在面试中找到最优解；面试中的各项能力，总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力；两个面试案例，总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。",
    "price": "65.00"
  },
  "9787115427472": {
    "rating": { "max": 10, "numRaters": 96, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["中村成洋", "相川光"],
    "pubdate": "2016-7-1",
    "tags": [
      { "count": 175, "name": "GC", "title": "GC" },
      { "count": 123, "name": "垃圾回收", "title": "垃圾回收" },
      { "count": 96, "name": "算法", "title": "算法" },
      { "count": 66, "name": "JVM", "title": "JVM" },
      { "count": 48, "name": "计算机", "title": "计算机" },
      { "count": 35, "name": "编译原理", "title": "编译原理" },
      { "count": 23, "name": "计算机科学", "title": "计算机科学" },
      { "count": 23, "name": "性能", "title": "性能" }
    ],
    "origin_title": "ガベージコレクションのアルゴリズムと実装",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28830934.jpg",
    "binding": "平装",
    "translator": ["丁灵"],
    "catalog": "序章\nGC的定义  1\nGC的好处  2\nGC的历史  3\n为什么我们现在要学GC  4\n读者对象  6\n本书中的符号  7\n算法篇\n第1章 学习GC之前\n1.1 对象/头/域  12\n1.2 指针  14\n1.3 mutator  15\n1.4 堆  15\n1.5 活动对象/非活动对象  16\n1.6 分配  16\n1.7 分块  17\n1.8 根  17\n1.9 评价标准  19\n第2章 GC标记-清除算法\n2.1 什么是GC标记-清除算法  22\n2.2 优点  29\n2.3 缺点  29\n2.4 多个空闲链表  31\n2.5 BiBOP法  33\n2.6 位图标记  34\n2.7 延迟清除法  37\n第3章 引用计数法\n3.1 引用计数的算法  40\n3.2 优点  44\n3.3 缺点  44\n3.4 延迟引用计数法  46\n3.5 Sticky引用计数法  50\n3.6 1位引用计数法  52\n3.7 部分标记-清除算法  55\n第4章 GC复制算法\n4.1 什么是GC复制算法  66\n4.2 优点  73\n4.3 缺点  74\n4.4 Cheney的GC复制算法  74\n4.5 近似深度优先搜索方法  78\n4.6 多空间复制算法  83\n第5章 GC标记-压缩算法\n5.1 什么是GC标记-压缩算法  89\n5.2 优点  94\n5.3 缺点  95\n5.4 Two-Finger算法  95\n5.5 表格算法  100\n5.6 ImmixGC算法  106\n第6章 保守式GC\n6.1 什么是保守式GC  119\n6.2 优点  122\n6.3 缺点  122\n6.4 准确式GC  123\n6.5 间接引用  125\n6.6 MostlyCopyingGC  127\n6.7 黑名单  139\n第7章 分代垃圾回收\n7.1 什么是分代垃圾回收  142\n7.2 Ungar的分代垃圾回收  143\n7.3 优点  153\n7.4 缺点  154\n7.5 记录各代之间的引用的方法  154\n7.6 多代垃圾回收  156\n7.7 列车垃圾回收  157\n第8章 增量式垃圾回收\n8.1 什么是增量式垃圾回收  166\n8.2 优点和缺点  174\n8.3 Steele的算法  174\n8.4 汤浅的算法  176\n8.5 比较各个写入屏障  178\n第9章 RC Immix算法\n9.1 目的  180\n9.2 合并型引用计数法  180\n9.3 合并型引用计数法和Immix的融合  185\n9.4 优点和缺点  189\n实现篇\n第10章 Python的垃圾回收\n10.1 本章前言  192\n10.2 对象管理  194\n10.3 Python的内存分配器  196\n10.4 第0层 通用的基础分配器  197\n10.5 第1层 Python低级内存分配器  198\n10.6 第2层 Python对象分配器  208\n10.7 第3层 对象特有的分配器  231\n10.8 引用计数法  234\n10.9 引用的所有权  239\n10.10 如何应对有循环引用的垃圾对象  245\n10.11 性能调整的建议  269\n第11章 DalvikVM的垃圾回收\n11.1 本章前言  271\n11.2 重新学习mmap  275\n11.3 DalvikVM的源代码  279\n11.4 DalvikVM的GC算法  282\n11.5 对象管理  282\n11.6 标记阶段  299\n11.7 清除阶段  322\n11.8 Q&A  327\n第12章 Rubinius的垃圾回收\n12.1 本章前言  329\n12.2 Rubinius的GC算法  333\n12.3 对象管理  334\n12.4 走向准确式GC之路  343\n12.5 GC复制算法  359\n12.6 Q&A  375\n第13章 V8的垃圾回收\n13.1 本章前言  379\n13.2 V8的GC算法  382\n13.3 对象管理  382\n13.4 通往准确式GC之路（V8篇）  389\n13.5 GC标记-压缩算法  398\n13.6 标记阶段  400\n13.7 压缩阶段  412\n13.8 Q&A  431\n附录\n附录A 简单语言入门：Python篇  432\n附录B 简单语言入门：Java篇  435\n附录C 简单语言入门：Ruby篇  436\n附录D 简单语言入门：JavaScript篇  437\n后记  439\n参考文献  441",
    "pages": "456",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28830934.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28830934.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28830934.jpg"
    },
    "alt": "https://book.douban.com/subject/26821357/",
    "id": "26821357",
    "publisher": "人民邮电出版社",
    "isbn10": "711542747X",
    "isbn13": "9787115427472",
    "title": "垃圾回收的算法与实现",
    "url": "https://api.douban.com/v2/book/26821357",
    "alt_title": "ガベージコレクションのアルゴリズムと実装",
    "author_intro": "",
    "summary": "★ Ruby之父Matz作推荐语：上古传承的魔法，彻底揭开垃圾回收的秘密！\n★ 日本天才程序员兼Lisp黑客竹内郁雄审校\n本书前半介绍基本GC算法，包括标记-清除GC、引用计数、复制算法的GC、串行GC的算法、并发GC的算法等。后半介绍V8、Rubinius、Dalvik、CPython等几种具体GC的实现。本书适合各领域程序员阅读。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "99.00元"
  },
  "9787302255659": {
    "rating": { "max": 10, "numRaters": 1074, "average": "7.9", "min": 0 },
    "subtitle": "",
    "author": ["程杰"],
    "pubdate": "2011-6",
    "tags": [
      { "count": 1133, "name": "数据结构", "title": "数据结构" },
      { "count": 447, "name": "算法", "title": "算法" },
      { "count": 386, "name": "计算机", "title": "计算机" },
      { "count": 247, "name": "编程", "title": "编程" },
      { "count": 182, "name": "程序设计", "title": "程序设计" },
      { "count": 110, "name": "计算机科学", "title": "计算机科学" },
      { "count": 106, "name": "大话", "title": "大话" },
      { "count": 105, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s6382631.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章数据结构绪论 1\n1.1开场白 2\n如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子。\n1.2你数据结构怎么学的？ 3\n他完成开发并测试通过后，得意地提交了代码。项目经理看完代码后拍着桌子对他说：“你数据结构是怎么学的？”\n1.3数据结构起源 4\n1.4基本概念和术语 5\n正所谓“巧妇难为无米之炊”，再强大的计算机，也要有“米”下锅才可以干活，否则就是一堆破铜烂铁。这个“米”就是数据。\n1.4.1数据 5\n1.4.2数据元素 5\n1.4.3数据项 6\n1.4.4数据对象 6\n1.4.5数据结构 6\n1.5逻辑结构与物理结构 7\n1.5.1逻辑结构 7\n1.5.2物理结构 9\n1.6抽象数据类型 11\n大家都需要房子住，但显然没钱考虑大房子是没有意义的。于是商品房就出现了各种各样的户型，有几百平米的别墅，也有仅两平米的胶囊公寓……\n1.6.1数据类型 11\n.1.6.2抽象数据类型 12\n1.7总结回顾 14\n1.8结尾语 15\n最终的结果一定是，你对着别人很牛的说“数据结构——就那么回事。”\n第2章算法 17\n2.1开场白 18\n2.2数据结构与算法关系 18\n计算机界的前辈们，是一帮很牛很牛的人，他们使得很多看似没法解决或者很难解决的问题，变得如此美妙和神奇。\n2.3两种算法的比较 19\n高斯在上小学的一天，老师要求每个学生都计算1+2+…+100的结果，谁先算出来谁先回家……\n2.4算法定义 20\n现实世界中的算法千变万化，没有通用算法可以解决所有问题。甚至一个小问题，某个解决此类问题很优秀的算法却未必就适合它。\n2.5算法的特性 21\n2.5.1输入输出 21\n2.5.2有穷性 21\n2.5.3确定性 21\n2.5.4可行性 21\n2.6算法设计的要求 22\n求100个人的高考成绩平均分与求全省所有考生的成绩平均分在占用时间和内存存储上有非常大的差异，我们自然追求高效率和低存储的算法来解决问题。\n2.6.1正确性 22\n2.6.2可读性 23\n2.6.3健壮性 23\n2.6.4时间效率高和存储量低 23\n2.7算法效率的度量方法 24\n随着n值越来越大，它们在时间效率上的差异也就越来越大。好比有些人每天都在学习，而另一些人，打打游戏、睡睡大觉，毕业后前者名企争着要，后者求职处处无门。\n2.7.1事后统计方法 24\n2.7.2事前分析估算方法 25\n2.8函数的渐近增长 27\n2.9算法时间复杂度 29\n理解大o推导不算难，难的其实是对数列的一些相关运算，这考察的更多的是数学知识和能力。\n2.9.1算法时间复杂度定义 29\n2.9.2推导大o阶方法 30\n2.9.3常数阶 30\n2.9.4线性阶 31\n2.9.5对数阶 32\n2.9.6平方阶 32\n2.10常见的时间复杂度 35\n有些时候，告诉你某些东西不可以去尝试，也是一种知识的传递。总不能非要去被毒蛇咬一口才知道蛇不可以去招惹吧。\n2.11最坏情况与平均情况 35\n2.12算法空间复杂度 36\n事先建立一个有2050大的数组，然后把所有年份按下标数字对应，如果是闰年，此数组项的值就是1，如果不是就是0。这样，所谓的判断某一年是否是闰年就变成了查找这个数组的某一项的值是多少的问题。\n2.13总结回顾 37\n2.14结尾语 38\n愚公移山固然可敬，但发明炸药和推土机，可能更加实在和聪明。\n第3章线性表 41\n3.1开场白 42\n门外家长都挤在大门口与门里的小孩子的井然有序，形成了鲜明对比。哎，有时大人的所作所为，其实还不如孩子。\n3.2线性表的定义 42\n3.3线性表的抽象数据类型 45\n有时我们想知道某个小朋友（比如麦兜）是否是班级的同学，老师会告诉我说，没有，麦兜是在春田花花幼儿园里。这种查找某个元素是否存在的操作很常用。\n3.4线性表的顺序存储结构 47\n他每次一吃完早饭就冲着去了图书馆，挑一个好地儿，把他书包里的书，一本一本的按座位放好，长长一排，九个座硬是被他占了。\n3.4.1顺序存储定义 47\n3.4.2顺序存储方式 47\n3.4.3数据长度与线性表长度区别 48\n3.4.4地址计算方法 49\n3.5顺序存储结构的插入与删除 50\n春运时去买火车票，大家都排队排着好好的，这时来了一个美女：“可否让我排在你前面？”这可不得了，后面的人像蠕虫一样，全部都得退后一步。\n3.5.1获得元素操作 50\n3.5.2插入操作 51\n3.5.3删除操作 52\n3.5.4线性表顺序存储结构的优缺点 54\n3.6线性表的链式存储结构 55\n反正也是要让相邻元素间留有足够余地，那干脆所有元素都不要考虑相邻位置了，哪有空位就到哪里。而只是让每个元素知道它下一个元素的位置在哪里。\n3.6.1顺序存储结构不足的解决\n办法 55\n3.6.2线性表链式存储结构定义 56\n3.6.3头指针与头结点的异同 58\n3.6.4线性表链式存储结构代码描述 58\n3.7单链表的读取 60\n3.8单链表的插入与删除 61\n本来是爸爸左牵着妈妈的手、右牵着宝宝的手在马路边散步。突然迎面走来一美女，爸爸失神般地望着，此情景被妈妈逮个正着，于是扯开父子俩，拉起宝宝的左手就快步朝前走去。\n3.8.1单链表的插入 61\n3.8.2单链表的删除 64\n3.9单链表的整表创建 66\n3.10单链表的整表删除 69\n3.11单链表结构与顺序存储结构优缺点 70\n3.12静态链表 71\n对于一些语言，如basic、fortran等早期的编程高级语言，由于没有指针，这链表结构，按照前面我们的讲法，它就没法实现了。怎么办呢？\n3.12.1静态链表的插入操作 73\n3.12.2静态链表的删除操作 75\n3.12.3静态链表优缺点 77\n3.13循环链表 78\n这个轮回的思想很有意思。它强调了不管你今生是穷是富，如果持续行善积德，下辈子就会好过，反之就会遭到报应。\n3.14双向链表 81\n就像每个人的人生一样，欲收获就得付代价。双向链表既然是比单链表多了如可以反向遍历查找等的数据结构，那么也就需要付出一些小的代价。\n3.15总结回顾 84\n3.16结尾语 85\n如果你觉得上学读书是受罪，假设你可以活到80岁，其实你最多也就吃了20年苦。用人生四分之一的时间来换取其余时间的幸福生活，这点苦不算啥。\n第4章栈与队列 87\n4.1开场白 88\n想想看，在你准备用枪的时候，突然这手枪明明有子弹却打不出来，这不是要命吗。\n4.2栈的定义 89\n类似的很多软件，比如word、photoshop等，都有撤消（undo）的操作，也是用栈这种思想方式来实现的。\n4.2.1栈的定义 89\n4.2.2进栈出栈变化形式 90\n4.3栈的抽象数据类型 91\n4.4栈的顺序存储结构及实现 92\n4.4.1栈的顺序存储结构 92\n4.4.2栈的顺序存储结构进栈操作 93\n4.4.3栈的顺序存储结构出栈操作 94\n4.5两栈共享空间 94\n两个大学室友毕业同时到北京工作，他们都希望租房时能找到独自住的一室户或一室一厅，可找来找去发现，实在是承受不起。\n4.6栈的链式存储结构及实现 97\n4.6.1栈的链式存储结构 97\n4.6.2栈的链式存储结构进栈操作 98\n4.6.3栈的链式存储结构出栈操作 99\n4.7栈的作用 100\n4.8栈的应用——递归 100\n当你往镜子前面一站，镜子里面就有一个你的像。但你试过两面镜子一起照吗？如果a、b两面镜子相互面对面放着，你往中间一站，嘿，两面镜子里都有你的千百个“化身”。\n4.8.1斐波那契数列实现 101\n4.8.2递归定义 103\n4.9栈的应用——四则运算表达式求值 104\n4.9.1后缀（逆波兰）表示法定义 104\n4.9.2后缀表达式计算结果 106\n4.9.3中缀表达式转后缀表达式 108\n4.10队列的定义 111\n电脑有时会处于疑似死机的状态。就当你失去耐心，打算了reset时。突然它像酒醒了一样，把你刚才点击的所有操作全部都按顺序执行了一遍。\n4.11队列的抽象数据类型 112\n4.12循环队列 113\n你上了公交车发现前排有两个空座位，而后排所有座位都已经坐满，你会怎么做？立马下车，并对自己说，后面没座了，我等下一辆？没这么笨的人，前面有座位，当然也是可以坐的。\n4.12.1队列顺序存储的不足 112\n4.12.2循环队列定义 114\n4.13队列的链式存储结构及实现 117\n4.13.1队列链式存储结构入队操作118\n4.13.2队列链式存储结构出队操作 119\n4.14总结回顾 120\n4.15结尾语 121\n人生，需要有队列精神的体现。南极到北极，不过是南纬90度到北纬90度的队列，如果你中途犹豫，临时转向，也许你就只能和企鹅相伴永远。可事实上，无论哪个方向，只要你坚持到底，你都可以到达终点。\n第5章串 123\n5.1开场白 124\n“枯眼望遥山隔水，往来曾见几心知？壶空怕酌一杯酒，笔下难成和韵诗。途路阻人离别久，讯音无雁寄回迟。孤灯夜守长寥寂，夫忆妻兮父忆儿。”……可再仔细一读发现，这首诗竟然可以倒过来读。\n5.2串的定义 124\n我所提到的“over”、“end”、“lie”其实就是“lover”、“friend”、“believe”这些单词字符串的子串。\n5.3串的比较 126\n5.4串的抽象数据类型 127\n5.5串的存储结构 128\n感情上发生了问题，为了向女友解释一下，我准备发一条短信，一共打了75个字。最后八个字是“我恨你是不可能的”，点发送。后来得知对方收到的，只有70个字，短信结尾是“……我恨你”。\n5.5.1串的顺序存储结构 129\n5.5.2串的链式存储结构 131\n5.6朴素的模式匹配算法 131\n主串为s=”00000000000000000000000000000000000000000000000001”，而要匹配的子串为t=”0000000001”，……在匹配时，每次都得将t中字符循环到最后一位才发现，哦，原来它们是不匹配的。\n5.7kmp模式匹配算法 135\n很多年前我们的科学家觉得像这种有多个0和1重复字符的字符串，却需要挨个遍历的算法，是非常糟糕的事情。\n5.7.1kmp模式匹配算法原理 135\n5.7.2next数组值推导 139\n5.7.3kmp模式匹配算法实现 141\n5.7.4kmp模式匹配算法改进 142\n5.7.5nextval数组值推导 144\n5.8总结回顾 146\n5.9结尾语 146\n《璇玑图》共八百四十字，纵横各二十九字，纵、横、斜、交互、正、反读或退一字、迭一字读均可成诗，诗有三、四、五、六、七言不等，目前有人统计可组成七千九百五十八首诗。听清楚哦，是7958首。\n第6章树 149\n6.1开场白 150\n无论多高多大的树，那也是从小到大的，由根到叶，一点点成长起来的。俗话说十年树木，百年树人，可一棵大树又何止是十年这样容易。\n6.2树的定义 150\n树的定义其实就是我们在讲解栈时提到的递归的方法。也就是在树的定义之中还用到了树的概念，这是比较新的一种定义方法。\n6.2.1结点分类 152\n6.2.2结点间关系 152\n6.2.3树的其他相关概念 153\n6.3树的抽象数据类型 154\n6.4树的存储结构 155\n6.4.1双亲表示法 155\n6.4.2孩子表示法 158\n6.4.3孩子兄弟表示法 162\n6.5二叉树的定义 163\n苏东坡曾说：“人有悲欢离合，月有阴晴圆缺，此事古难全”。意思就是完美是理想，不完美才是人生。我们通常举的例子也都是左高右低、参差不齐的二叉树。那是否存在完美的二叉树呢？\n6.5.1二叉树特点 164\n6.5.2特殊二叉树 166\n6.6二叉树的性质 169\n6.6.1二叉树性质1 169\n6.6.2二叉树性质2 169\n6.6.3二叉树性质3 169\n6.6.4二叉树性质4 170\n6.6.5二叉树性质5 171\n6.7二叉树的存储结构 172\n6.7.1二叉树顺序存储结构 172\n6.7.2二叉链表 173\n6.8遍历二叉树 174\n你人生的道路上，高考填志愿要面临哪个城市、哪所大学、具体专业等选择，由于选择方式的不同，遍历的次序就完全不同。\n6.8.1二叉树遍历原理 174\n6.8.2二叉树遍历方法 175\n6.8.3前序遍历算法 178\n6.8.4中序遍历算法 181\n6.8.5后序遍历算法 184\n6.8.6推导遍历结果 184\n6.9二叉树的建立 187\n6.10线索二叉树 188\n我们现在提倡节约型社会，一切都应该节约为本。对待我们的程序当然也不例外，能不浪费的时间或空间，都应该考虑节省。\n6.10.1线索二叉树原理 188\n6.10.2线索二叉树结构实现 191\n6.11树、森林与二叉树的转换 195\n有个乡镇企业也买了同样的生产线，老板发现这个问题后找了个小工来说：你必须搞定，不然炒你鱿鱼。小工很快想出了办法：他在生产线旁边放了台风扇猛吹，空皂盒自然会被吹走。\n6.11.1树转换为二叉树 196\n6.11.2森林转换为二叉树 197\n6.11.3二叉树转换为树 197\n6.11.4二叉树转换为森林 199\n6.11.5树与森林的遍历 199\n6.12赫夫曼树及其应用 200\n压缩而不出错是如何做到的呢？简单的说，就是把我们要压缩的文本进行重新编码，以达到减少不必要的空间的技术。压缩和解压缩技术就是基于赫夫曼的研究之上发展而来，我们应该记住他。\n6.12.1赫夫曼树 200\n6.12.2赫夫曼树定义与原理 203\n6.12.3赫夫曼编码 205\n6.13总结回顾 208\n6.14结尾语 209\n人受伤时会流下泪水。树受伤时，天将再不会哭。希望我们的未来不要仅仅是钢筋水泥建造的高楼，也要有那郁郁葱葱的森林和草地，我们人类才可能与自然和谐共处。\n第7章图 211\n7.1开场白 212\n如果你不善于规划，很有可能就会出现如玩好新疆后到海南，然后再冲向黑龙江这样的荒唐决策。\n7.2图的定义 213\n现实中，人与人之间关系就非常复杂，比如我的认识的朋友，可能他们之间也互相认识，这就不是简单的一对一、一对多的关系了，那就是我们今天要研究的主题——图。\n7.2.1各种图定义 214\n7.2.2图的顶点与边间关系 217\n7.2.3连通图相关术语 219\n7.2.4图的定义与术语总结 222\n7.3图的抽象数据类型 222\n7.4图的存储结构 223\n因为美国的黑夜就是中国的白天，利用互联网，他的员工白天上班就可以监控到美国仓库夜间的实际情况，如果发生了像火灾、偷盗这样的突发事件，及时电话到美国当地相关人员处理\n7.4.1邻接矩阵 224\n7.4.2邻接表 228\n7.4.3十字链表 232\n7.4.4邻接多重表 234\n7.4.5边集数组 236\n7.5图的遍历 237\n我有一天早晨准备出门，发现钥匙不见了。一定是我儿子拿着玩，不知道丢到哪个犄角旮旯去了，你们说，我应该如何找？\n7.5.1深度优先遍历 238\n7.5.2广度优先遍历 242\n7.6最小生成树 245\n如果你加班加点，没日没夜设计出的结果是方案一，我想你离被炒鱿鱼应该是不远了（同学微笑）。因为这个方案比后两个方案一半还多的成本会让老板气晕过去的。\n7.6.1普里姆（prim）算法 247\n7.6.2克鲁斯卡尔（kruskal）算法 251\n7.7最短路径 257\n有人为了省钱，需路程最短，但换乘站间距离长等原因并不省时间；另一些人，他为赶时间，最大的需求是总时间要短；还有一类人，他们都不想多走路，关键是换乘要少，这样可以在车上好好休息一下。\n7.7.1迪杰斯特拉（dijkstra）算法 259\n7.7.3弗洛伊德（floyd）算法 265\n7.8拓扑排序 270\n电影制作不可能在人员到位进驻场地时，导演还没有找到，也不可能在拍摄过程中，场地都没有。这都会导致荒谬的结果。\n7.8.1拓扑排序介绍 271\n7.8.2拓扑排序算法 272\n7.9关键路径 277\n假如造一个轮子要0.5天、造一个发动机要3天、造一个车底盘要2天、造一个外壳要2天，其它零部件2天，全部零部件集中到一处要0.5天，组装成车要2天，请问，在汽车厂造一辆车，最短需要多少天呢？\n7.9.1关键路径算法原理 279\n7.9.2关键路径算法 280\n7.10总结回顾 287\n7.11结尾语 289\n世界上最遥远的距离，不是牛a与牛c之间狭小空隙，而是你们当中，有人在通往牛逼的路上一路狂奔，而有人步入大学校园就学会放弃。\n第8章查找 291\n8.1开场白 292\n当你精心写了一篇博文或者上传一组照片到互联网上，来自世界各地的无数“蜘蛛”便会蜂拥而至。所谓蜘蛛就是搜索引擎公司服务器上软件，它把互联网当成了蜘蛛网，没日没夜的访问上面的各种信息。\n8.2查找概论 293\n比如网络时代的新名词，如“蜗居”、“蚁族”等，如果需要将它们收录到汉语词典中，显然收录时就需要查找它们是否存在，以及找到如果不存在时应该收录的位置。\n8.3顺序表查找 295\n8.3.1顺序表查找算法 296\n8.3.2顺序表查找优化 297\n8.4有序表查找 298\n我在纸上已经写好了一个100以内的正整数请你猜，问几次可以猜出来。当时已经介绍了如何才可以最快的猜出这个数字。我们把这种每次取中间记录查找的方法叫做折半查找。\n8.4.1折半查找 298\n8.4.2插值查找 301\n8.4.3斐波那契查找 302\n8.5线性索引查找 306\n我母亲年纪大了，经常在家里找不到东西，于是她用一小本子，记录了家里所有小东西放置的位置，比如户口本放在右手床头柜下面抽屉中，钞票放在衣……咳，这个就不提了。\n8.5.1稠密索引 307\n8.5.2分块索引 308\n8.5.3倒排索引 311\n8.6二叉排序树 313\n后来老虎来了，一人拼命地跑，另一人则急中生智，爬到了树上。而老虎是不会爬树的，结果……。爬树者改变了跑的思想，这一改变何等重要，捡回了自己的一条命。\n8.6.1二叉排序树查找操作 316\n8.6.2二叉排序树插入操作 318\n8.6.3二叉排序树删除操作 320\n8.6.4二叉排序树总结 327\n8.7平衡二叉树（avl树） 328\n平板就是一个世界，当诱惑降临，人心中的平衡被打破，世界就会混乱，最后留下的只有孤独寂寞失败。这种单调的机械化的社会，禁不住诱惑的侵蚀，最容易被侵蚀的，恰恰是最空虚的心灵。\n8.7.1平衡二叉树实现原理 330\n8.7.2平衡二叉树实现算法 334\n8.8多路查找树（b树） 341\n要观察一个公司是否严谨，看他们如何开会就知道了。如果开会时每一个人都只是带一张嘴，即兴发言，这肯定是一家不严谨的公司。\n8.8.12-3树 343\n8.8.22-3-4树 348\n8.8.3b树 349\n8.8.4b+树 351\n8.9散列表查找（哈希表）概述 353\n你很想学太极拳，听说学校有个叫张三丰的人打得特别好，于是到学校学生处找人，工作人员拿出学生名单，最终告诉你，学校没这个人，并说张三丰几百年前就已经在武当山作古了。\n8.9.1散列表查找定义 354\n8.9.2散列表查找步骤 355\n8.10散列函数的构造方法 356\n8.10.1直接定址法 357\n8.10.2数字分析法 358\n8.10.3平方取中法 359\n8.10.4折叠法 359\n8.10.5除留余数法 359\n8.10.6随机数法 360\n8.11处理散列冲突的方法 360\n我们每个人都希望身体健康，虽然疾病可以预防，但不可避免，没有任何人可以说，生下来到现在没有生过一次病。\n8.11.1开放定址法 361\n8.11.2再散列函数法 363\n8.11.3链地址法 363\n8.11.4公共溢出区法 364\n8.12散列表查找实现 365\n8.12.1散列表查找算法实现 365\n8.12.2散列表查找性能分析 367\n8.13总结回顾 368\n8.14结尾语 369\n如果我是个喜欢汽车的人，时常搜汽车信息。那么当我在搜索框中输入“甲壳虫”、“美洲虎”等关键词时，不要让动物和人物成为搜索的头条。\n第9章排序 373\n9.1开场白 374\n假如我想买一台iphone4的手机，于是上了某电子商务网站去搜索。可搜索后发现，有8863个相关的物品，如此之多，这叫我如何选择。我其实是想买便宜一点的，但是又怕遇到骗子，想找信誉好的商家，如何做？\n9.2排序的基本概念与分类 375\n比如我们某些大学为了选拔在主科上更优秀的学生，要求对所有学生的所有科目总分倒序排名，并且在同样总分的情况下将语数外总分做倒序排名。这就是对总分和语数外总分两个次关键字的组合排序。\n9.2.1排序的稳定性 376\n9.2.2内排序与外排序 377\n9.2.3排序用到的结构与函数 378\n9.3冒泡排序 378\n无论你学习哪种编程语言，在学到循环和数组时，通常都会介绍一种排序算法，而这个算法一般就是冒泡排序。并不是它的名称很好听，而是说这个算法的思路最简单，最容易理解。\n9.3.1最简单排序实现 379\n9.3.2冒泡排序算法 380\n9.3.3冒泡排序优化 382\n9.3.4冒泡排序复杂度分析 383\n9.4简单选择排序 384\n还有一种做股票的人，他们很少出手，只是在不断观察和判断，等时机一到，果断买进或卖出。他们因为冷静和沉着，以及交易的次数少，而最终收益颇丰。\n9.4.1简单选择排序算法 384\n9.4.2简单选择排序复杂度分析 385\n9.5直接插入排序 386\n哪怕你是第一次玩扑克牌，只要认识这些数字，理牌的方法都是不用教的。将3和4移动到5的左侧，再将2移动到最左侧，顺序就算是理好了。这里，我们的理牌方法，就是直接插入排序法。\n9.5.1直接插入排序算法 386\n9.5.2直接插入排序复杂度分析 388\n9.6希尔排序 389\n不管怎么说，希尔排序算法的发明，使得我们终于突破了慢速排序的时代（超越了时间复杂度为o(n2)），之后，更为高效的排序算法也就相继出现了。\n9.6.1希尔排序原理 391\n9.6.2希尔排序算法 391\n9.6.3希尔排序复杂度分析 395\n9.7堆排序 396\n什么叫堆结构呢？回忆一下我们小时候，特别是男同学，基本都玩过叠罗汉的恶作剧。通常都是先把某个要整的人按倒在地，然后大家就一拥而上扑了上去……后果？后果当然就是一笑了之。\n9.7.1堆排序算法 398\n9.7.2堆排序复杂度分析 405\n9.8归并排序 406\n即使你是你们班级第一、甚至年级第一名，如果你没有上分数线，则说明你的成绩排不到全省前1万名，你也就基本失去了当年上本科的机会了。\n9.8.1归并排序算法 407\n9.8.2归并排序复杂度分析 413\n9.8.3非递归实现归并排序 413\n9.9快速排序 417\n终于我们的高手要登场了，将来你工作后，你的老板让你写个排序算法，而你会的算法中竟然没有快速排序，我想你还是不要声张，偷偷去把快速排序算法找来敲进电脑，这样至少你不至于被大伙儿取笑。\n9.9.1快速排序算法 417\n9.9.2快速排序复杂度分析 421\n9.9.3快速排序优化 422\n9.10总结回顾 428\n目前还没有十全十美的排序算法，有优点就会有缺点，即使是快速排序法，也只是在整体性能上优越，它也存在排序不稳定、需要大量辅助空间、对少量数据排序无优势等不足。\n9.11结尾语 430\n如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！\n附录参考文献 435",
    "pages": "440",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s6382631.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s6382631.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s6382631.jpg"
    },
    "alt": "https://book.douban.com/subject/6424904/",
    "id": "6424904",
    "publisher": "清华大学出版社",
    "isbn10": "7302255652",
    "isbn13": "9787302255659",
    "title": "大话数据结构",
    "url": "https://api.douban.com/v2/book/6424904",
    "alt_title": "",
    "author_intro": "一个被读者誉为很适合写IT技术书的家伙。《大话设计模式》作者。此书07年末出版至今已经简体版印刷9次、繁体版印刷6次，取得了较好的成绩，开创了一种适合国人阅读的趣味讲解IT知识的风格模式。其本人参与过政府、证券、游戏、交通等多种行业的软件开发及项目管理工作，也曾做过软件培训的教师。因曾有过两年半高中数学教学的独特经历，使得其书作当中处处以初学者视角考虑和分析问题，他成为了当前很受欢迎的IT技术图书作者之一。\n博客：http://cj723.cnblogs.com；\n微博：http://weibo.com/cj723；\nEmail：chengjielong@163.com",
    "summary": "本书为超级畅销书《大话设计模式》作者程杰潜心三年推出的扛鼎之作！以一个计算机教师教学为场景，讲解数据结构和相关算法的知识。通篇以一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。与市场上的同类数据结构图书相比，本书内容趣味易读，算法讲解细致深刻，是一本非常适合自学的读物。\n本书以一个计算机教师教学为场景，讲解数据结构和相关算法的知识。通篇?一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。与市场上的同类数据结构图书相比，本书内容趣味易读，算法讲解细致深刻，是一本非常适合自学的读物。",
    "series": { "id": "34103", "title": "大话系列" },
    "price": "59.00元"
  },
  "9787115320100": {
    "rating": { "max": 10, "numRaters": 211, "average": "8.9", "min": 0 },
    "subtitle": "",
    "author": ["秋叶拓哉", "岩田阳一", "北川宜稔"],
    "pubdate": "2013-7-1",
    "tags": [
      { "count": 433, "name": "算法", "title": "算法" },
      { "count": 256, "name": "编程", "title": "编程" },
      { "count": 225, "name": "ACM竞赛", "title": "ACM竞赛" },
      { "count": 144, "name": "ACM", "title": "ACM" },
      { "count": 141, "name": "计算机", "title": "计算机" },
      { "count": 83, "name": "计算机科学", "title": "计算机科学" },
      { "count": 62, "name": "Algorithms", "title": "Algorithms" },
      { "count": 61, "name": "programming", "title": "programming" }
    ],
    "origin_title": "プログラミングコンテストチャレンジブック [第2版]　~問題解決のアルゴリズム活用力とコーディングテクニックを鍛える~",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29048069.jpg",
    "binding": "平装",
    "translator": ["巫泽俊", "庄俊元", "李津羽"],
    "catalog": "译者序\n前言\n第1章　蓄势待发——准备篇\n1.1 　何谓程序设计竞赛\n1.2 　最负盛名的程序设计竞赛\n1.2.1 　世界规模的大赛——Google Code Jam（GCJ）\n1.2.2 　向高排名看齐！——TopCoder\n1.2.3 　历史最悠久的竞赛—— ACM-ICPC\n1.2.4 　面向中学生的信息学奥林匹克竞赛——JOI-IOI\n1.2.5 　通过网络自动评测——Online Judge（OJ）\n1.3 　本书的使用方法\n1.3.1 　本书所涉及的内容\n1.3.2 　所用的编程语言\n1.3.3 　题目描述的处理\n1.3.4 　程序结构\n1.3.5 　练习题\n1.3.6 　读透本书后更上一层楼的练习方法\n1.4 　如何提交解答\n1.4.1 　POJ的提交方法\n1.4.2 　GCJ的提交方法\n1.5 　以高效的算法为目标\n1.5.1 　什么是复杂度\n1.5.2 　关于运行时间\n1.6 　轻松热身\n1.6.1 　先从简单题开始\n1.6.2 　POJ的题目Ants\n1.6.3 　难度增加的抽签问题\n阅读\n第2章　初出茅庐——初级篇\n2.1 　最基础的“穷竭搜索”\n2.1.1 　递归函数\n2.1.2 　栈\n2.1.3 　队列\n2.1.4 　深度优先搜索\n2.1.5 　宽度优先搜索\n2.1.6 　特殊状态的枚举\n2.1.7 　剪枝\n2.2 　一往直前！贪心法\n2.2.1 　硬币问题\n2.2.2 　区间问题\n2.2.3 　字典序最小问题\n2.2.4 　其他例题\n2.3 　记录结果再利用的“动态规划”\n2.3.1 　记忆化搜索与动态规划\n2.3.2 　进一步探讨递推关系\n2.3.3 　有关计数问题的DP\n2.4 　加工并存储数据的数据结构\n2.4.1 　树和二叉树\n2.4.2 　优先队列和堆\n2.4.3 　二叉搜索树\n2.4.4 　并查集\n2.5 　它们其实都是“图”\n2.5.1 　图是什么\n2.5.2 　图的表示\n2.5.3 　图的搜索\n2.5.4 　最短路问题\n2.5.5 　最小生成树\n2.5.6 　应用问题\n2.6 　数学问题的解题窍门\n2.6.1 　辗转相除法\n2.6.2 　有关素数的基础算法\n2.6.3 　模运算\n2.6.4 　快速幂运算\n2.7 　一起来挑战GCJ的题目（1）\n2.7.1 　Minimum Scalar Product\n2.7.2 　Crazy Rows\n2.7.3 　Bribe the Prisoners\n2.7.4 　Millionaire\n阅读\n第3章　出类拔萃——中级篇\n3.1 　不光是查找值！“二分搜索”\n3.1.1 　从有序数组中查找某个值\n3.1.2 　假定一个解并判断是否可行\n3.1.3 　最大化最小值\n3.1.4 　最大化平均值\n3.2 　常用技巧精选（一）\n3.2.1 　尺取法\n3.2.2 　反转（开关问题）\n3.2.3 　弹性碰撞\n3.2.4 　折半枚举（双向搜索）\n3.2.5 　坐标离散化\n3.3 　活用各种数据结构\n3.3.1 　线段树\n3.3.2 　Binary Indexed Tree\n3.3.3 　分桶法和平方分割\n3.4 　熟练掌握动态规划\n3.4.1 　状态压缩DP\n3.4.2 　矩阵的幂\n3.4.3 　利用数据结构高效求解\n3.5 　借助水流解决问题的网络流\n3.5.1 　最大流\n3.5.2 　最小割\n3.5.3 　二分图匹配\n3.5.4 　一般图匹配\n3.5.5 　匹配、边覆盖、独立集和顶点覆盖\n3.5.6 　最小费用流\n3.5.7 　应用问题\n3.6 　与平面和空间打交道的计算几何\n3.6.1 　计算几何基础\n3.6.2 　极限情况\n3.6.3 　平面扫描\n3.6.4 　凸包\n3.6.5 　数值积分\n3.7 　一起来挑战GCJ的题目（2）\n3.7.1 　Numbers\n3.7.2 　No Cheating\n3.7.3 　Stock Charts\n3.7.4 　Watering Plants\n3.7.5 　Number Sets\n3.7.6 　Wi-fi Towers\n第4章　登峰造极——高级篇\n4.1 　更加复杂的数学问题\n4.1.1 　矩阵\n4.1.2 　模运算的世界\n4.1.3 　计数\n4.1.4 　具有对称性的计数\n4.2 　找出游戏的必胜策略\n4.2.1 　游戏与必胜策略\n4.2.2 　Nim\n4.2.3 　Grundy数\n4.3 　成为图论大师之路\n4.3.1 　强连通分量分解\n4.3.2 　2-SAT\n4.3.3 　LCA\n4.4 　常用技巧精选（二）\n4.4.1 　栈的运用\n4.4.2 　双端队列的运用\n4.4.3 　倍增法\n4.5 　开动脑筋智慧搜索\n4.5.1 　剪枝\n4.5.2 　A*与IDA*\n4.6 　划分、解决、合并：分治法\n4.6.1 　数列上的分治法\n4.6.2 　树上的分治法\n4.6.3 　平面上的分治法\n4.7 　华丽地处理字符串\n4.7.1 　字符串上的动态规划算法\n4.7.2 　字符串匹配\n4.7.3 　后缀数组\n4.8 　一起来挑战GCJ的题目（3）\n4.8.1 　Mine Layer\n4.8.2 　Year of More Code Jam\n4.8.3 　Football Team\n4.8.4 　Endless Knight\n4.8.5 　The Year of Code Jam\n阅读\n本书中未涉及的拓展主题\n书中例题列表\n参考文献",
    "pages": "414",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29048069.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29048069.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29048069.jpg"
    },
    "alt": "https://book.douban.com/subject/24749842/",
    "id": "24749842",
    "publisher": "人民邮电出版社",
    "isbn10": "7115320101",
    "isbn13": "9787115320100",
    "title": "挑战程序设计竞赛",
    "url": "https://api.douban.com/v2/book/24749842",
    "alt_title": "プログラミングコンテストチャレンジブック [第2版]　~問題解決のアルゴリズム活用力とコーディングテクニックを鍛える~",
    "author_intro": "★秋叶拓哉\nGoogle Code Jam 2010 第9名\nACM-ICPC World Finals 2012 第11名\nTopCoder Open 2012 Algorithm 第4名\n昵称iwi\n★岩田阳一\nGoogle Code Jam 2009 第3名\nTopCoder Open 2010 Marathon 冠军\nIPSC 2010 个人组 冠军\n昵称wata\n★北川宜稔\nACM-ICPC World Finals 2010第16名\n昵称kita_masa\n★巫泽俊\nACM-ICPC World Finals 2009 第6名\nACM-ICPC World Finals 2011 冠军\nGoogle Code Jam 2012 第7名\n昵称watashi和rejudge\n★庄俊元\nACM-ICPC Asia Phuket Regional 2011 冠军\n2012年跻身ACM-ICPC World Finals以及百度Astar总决赛\n昵称navi和navimoe\n★李津羽\n浙江大学2011级计算机系博士生\n在浙大CAD&CG实验室从事科研工作",
    "summary": "世界顶级程序设计高手的经验总结\n【ACM-ICPC全球总冠军】巫泽俊主译\n日本ACM-ICPC参赛者人手一册\n本书对程序设计竞赛中的基础算法和经典问题进行了汇总，分为准备篇、初级篇、中级篇与高级篇4章。作者结合自己丰富的参赛经验，对严格筛选的110 多道各类试题进行了由浅入深、由易及难的细致讲解，并介绍了许多实用技巧。每章后附有习题，供读者练习，巩固所学。\n本书适合程序设计人员、程序设计竞赛爱好者以及高校计算机专业师生阅读。",
    "price": "CNY 79.00"
  },
  "9787302356288": {
    "rating": { "max": 10, "numRaters": 203, "average": "8.9", "min": 0 },
    "subtitle": "",
    "author": ["刘汝佳"],
    "pubdate": "2014-6-1",
    "tags": [
      { "count": 206, "name": "算法", "title": "算法" },
      { "count": 116, "name": "编程", "title": "编程" },
      { "count": 101, "name": "计算机", "title": "计算机" },
      { "count": 97, "name": "ACM", "title": "ACM" },
      { "count": 84, "name": "算法竞赛", "title": "算法竞赛" },
      { "count": 76, "name": "数据结构与算法", "title": "数据结构与算法" },
      { "count": 63, "name": "计算机科学", "title": "计算机科学" },
      { "count": 52, "name": "Algorithms", "title": "Algorithms" }
    ],
    "origin_title": "刘汝佳",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28393836.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1部分　语言篇\n第1章　程序设计入门 1\n1.1 算术表达式 1\n1.2 变量及其输入 3\n1.3 顺序结构程序设计 6\n1.4 分支结构程序设计 9\n1.5 注解与习题 13\n1.5.1 C语言、C99、C11及其他 13\n1.5.2 数据类型与输入格式 14\n1.5.3 习题 15\n1.5.4 小结 16\n第2章　循环结构程序设计 18\n2.1 for循环 18\n2.2 while循环和do-while循环 22\n2.3 循环的代价 25\n2.4 算法竞赛中的输入输出框架 27\n2.5 注解与习题 34\n2.5.1 习题 34\n2.5.2 小结 36\n第3章　数组和字符串 37\n3.1 数组 37\n3.2 字符数组 41\n3.3 竞赛题目选讲 45\n3.4 注解与习题 53\n3.4.1 进位制与整数表示 54\n3.4.2 思考题 55\n3.4.3 黑盒测试和在线评测系统 55\n3.4.4 例题一览与习题 56\n3.4.5 小结 59\n第4章　函数和递归 61\n4.1 自定义函数和结构体 61\n4.2 函数调用与参数传递 65\n4.2.1 形参与实参 65\n4.2.2 调用栈 66\n4.2.3 用指针作参数 69\n4.2.4 初学者易犯的错误 71\n4.2.5 数组作为参数和返回值 71\n4.2.6 把函数作为函数的参数 73\n4.3 递归 74\n4.3.1 递归定义 74\n4.3.2 递归函数 75\n4.3.3 C语言对递归的支持 75\n4.3.4 段错误与栈溢出 77\n4.4 竞赛题目选讲 79\n4.5 注解与习题 92\n4.5.1 头文件、副作用及其他 93\n4.5.2 例题一览和习题 95\n4.5.3 小结 99\n第5章　 C++与STL入门 100\n5.1 从C到C++ 100\n5.1.1 C++版框架 101\n5.1.2 引用 102\n5.1.3 字符串 103\n5.1.4 再谈结构体 105\n5.1.5 模板 106\n5.2 STL初步 108\n5.2.1 排序与检索 108\n5.2.2 不定长数组：vector 109\n5.2.3 集合：set 112\n5.2.4 映射：map 113\n5.2.5 栈、队列与优先队列 115\n5.2.6 测试STL 120\n5.3 应用：大整数类 123\n5.3.1 大整数类BigInteger 124\n5.3.2 四则运算 125\n5.3.3 比较运算符 126\n5.4 竞赛题目举例 127\n5.5 习题 134\n第2部分　基础篇\n第6章　数据结构基础 139\n6.1 再谈栈和队列 139\n6.2 链表 143\n6.3 树和二叉树 148\n6.3.1 二叉树的编号 148\n6.3.2 二叉树的层次遍历 150\n6.3.3 二叉树的递归遍历 155\n6.3.4 非二叉树 160\n6.4 图 162\n6.4.1 用DFS求连通块 162\n6.4.2 用BFS求最短路 164\n6.4.3 拓扑排序 167\n6.4.4 欧拉回路 168\n6.5 竞赛题目选讲 170\n6.6 训练参考 175\n第7章　暴力求解法 182\n7.1 简单枚举 182\n7.2 枚举排列 184\n7.2.1 生成1~n的排列 184\n7.2.2 生成可重集的排列 185\n7.2.3 解答树 186\n7.2.4 下一个排列 187\n7.3 子集生成 188\n7.3.1 增量构造法 188\n7.3.2 位向量法 188\n7.3.3 二进制法 189\n7.4 回溯法 191\n7.4.1 八皇后问题 191\n7.4.2 其他应用举例 194\n7.5 路径寻找问题 198\n7.6 迭代加深搜索 206\n7.7 竞赛题目选讲 209\n7.8 训练参考 213\n第3部分　竞赛篇\n第8章　高效算法设计 220\n8.1 算法分析初步 220\n8.1.1 渐进时间复杂度 220\n8.1.2 上界分析 222\n8.1.3 分治法 223\n8.1.4 正确对待算法分析结果 224\n8.2 再谈排序与检索 225\n8.2.1 归并排序 225\n8.2.2 快速排序 227\n8.2.3 二分查找 227\n8.3 递归与分治 229\n8.4 贪心法 231\n8.4.1 背包相关问题 231\n8.4.2 区间相关问题 232\n8.4.3 Huffman编码 234\n8.5 算法设计与优化策略 235\n8.6 竞赛题目选讲 244\n8.7 训练参考 252\n第9章　动态规划初步 259\n9.1 数字三角形 259\n9.1.1 问题描述与状态定义 259\n9.1.2 记忆化搜索与递推 260\n9.2 DAG上的动态规划 262\n9.2.1 DAG模型 262\n9.2.2 最长路及其字典序 262\n9.2.3 固定终点的最长路和最短路 264\n9.2.4 小结与应用举例 267\n9.3 多阶段决策问题 270\n9.3.1 多段图的最短路 270\n9.3.2 0-1背包问题 271\n9.4 更多经典模型 274\n9.4.1 线性结构上的动态规划 274\n9.4.2 树上的动态规划 280\n9.4.3 复杂状态的动态规划 284\n9.5 竞赛题目选讲 290\n9.6 训练参考 303\n第10章　数学概念与方法 310\n10.1 数论初步 310\n10.1.1 欧几里德算法和唯一分解定理 310\n10.1.2 Eratosthenes筛法 312\n10.1.3 扩展欧几里德算法 313\n10.1.4 同余与模算术 314\n10.1.5 应用举例 316\n10.2 计数与概率基础 318\n10.2.1 杨辉三角与二项式定理 319\n10.2.2 数论中的计数问题 321\n10.2.3 编码与解码 323\n10.2.4 离散概率初步 324\n10.3 其他数学专题 327\n10.3.1 递推 327\n10.3.2 数学期望 332\n10.3.3 连续概率 334\n10.4 竞赛题目选讲 336\n10.5 训练参考 341\n第11章　图论模型与算法 352\n11.1 再谈树 352\n11.1.1 无根树转有根树 352\n11.1.2 表达式树 353\n11.2 最小生成树 355\n11.2.1 Kruskal算法 356\n11.2.2 竞赛题目选解 358\n11.3 最短路问题 359\n11.3.1 Dijkstra算法 359\n11.3.2 Bellman-Ford算法 363\n11.3.3 Floyd算法 364\n11.3.4 竞赛题目选讲 365\n11.4 网络流初步 366\n11.4.1 最大流问题 366\n11.4.2 增广路算法 367\n11.4.3 最小割最大流定理 369\n11.4.4 最小费用最大流问题 370\n11.4.5 应用举例 372\n11.5 竞赛题目选讲 375\n11.6 训练参考 379\n11.7 总结与展望 384\n第12章　高级专题 386\n12.1 知识点选讲 386\n12.1.1 自动机 386\n12.1.2 树的经典问题和方法 392\n12.1.3 可持久化数据结构 397\n12.1.4 多边形的布尔运算 399\n12.2 难题选解 404\n12.2.1 数据结构 404\n12.2.2 网络流 409\n12.2.3 数学 411\n12.2.4 几何 415\n12.2.5 非完美算法 419\n12.2.6 杂题选讲 423\n12.3 小结与习题 446\n附录A 开发环境与方法 455\nA.1 命令行 455\nA.1.1 文件系统 455\nA.1.2 进程 456\nA.1.3 程序的执行 456\nA.1.4 重定向和管道 457\nA.1.5 常见命令 457\nA.2 操作系统脚本编程入门 458\nA.2.1 Windows下的批处理 458\nA.2.2 Linux下的Bash脚本 459\nA.2.3 再谈随机数 460\nA.3 编译器和调试器 460\nA.3.1 gcc的安装和测试 460\nA.3.2 常见编译选项 461\nA.3.3 gdb简介 462\nA.3.4 gdb的高级功能 463\nA.4 浅谈IDE 464\n主要参考书目 465",
    "pages": "464",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28393836.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28393836.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28393836.jpg"
    },
    "alt": "https://book.douban.com/subject/25902102/",
    "id": "25902102",
    "publisher": "清华大学出版社",
    "isbn10": "7302356289",
    "isbn13": "9787302356288",
    "title": "算法竞赛入门经典（第2版）",
    "url": "https://api.douban.com/v2/book/25902102",
    "alt_title": "刘汝佳",
    "author_intro": "刘汝佳，1982年12月生，高中毕业于重庆市外国语学校。2000年3月获得NOI2000全国青少年信息学奥林匹克竞赛一等奖第四名，进入国家集训队，并因此保送到清华大学计算机科学与技术系。大一时获2001年ACM/ICPC国际大学生程序设计竞赛亚洲-上海赛区冠军和2002年世界总决赛银牌（世界第四），2005年获学士学位，2008年获硕士学位。\n学生时代曾为中国计算机学会NOI科学委员会学生委员，担任IOI2002-2008中国国家队教练，并为NOI系列比赛命题十余道。现为NOI竞赛委员会委员，并在NOI 25周年时获得中国计算机学会颁发的“特别贡献奖”。\n2004年至今共为ACM/ICPC亚洲赛区命题二十余道，担任6次裁判和2次命题总监，并应邀参加IOI和ACM/ICPC相关国际研讨会，发表论文两篇。\n2004年初作为第一作者出版专著《算法艺术与信息学竞赛》，2009年出版译著《编程挑战》，2009年出版《算法竞赛入门经典》，2012年出版《算法竞赛入门经典——训练指南》。\n多年来在全国二十余个城市进行中学生竞赛培训工作，为北京、上海、吉隆坡等地的著名高校授课与宣讲，并多次与TopCoder、百度和网易有道等知名企业合作举办比赛，让更多的IT人才获得展示自我的平台。",
    "summary": "《算法竞赛入门经典（第2版）》是一本算法竞赛的入门与提高教材，把C/C++语言、算法和解题有机地结合在一起，淡化理论，注重学习方法和实践技巧。全书内容分为12 章，包括程序设计入门、循环结构程序设计、数组和字符串、函数和递归、C++与STL入门、数据结构基础、暴力求解法、高效算法设计、动态规划初步、数学概念与方法、图论模型与算法、高级专题等内容，覆盖了算法竞赛入门和提高所需的主要知识点，并含有大量例题和习题。书中的代码规范、简洁、易懂，不仅能帮助读者理解算法原理，还能教会读者很多实用的编程技巧；书中包含的各种开发、测试和调试技巧也是传统的语言、算法类书籍中难以见到的。\n《算法竞赛入门经典（第2版）》可作为全国青少年信息学奥林匹克联赛（NOIP）复赛教材、全国青少年信息学奥林匹克竞赛（NOI）和ACM国际大学生程序设计竞赛（ACM/ICPC）的训练资料，也可作为IT工程师与科研人员的参考用书。",
    "price": "CNY 49.80"
  },
  "9787121060748": {
    "rating": { "max": 10, "numRaters": 3023, "average": "8.4", "min": 0 },
    "subtitle": "微软技术面试心得",
    "author": ["《编程之美》小组 编"],
    "pubdate": "2008-3",
    "tags": [
      { "count": 2222, "name": "算法", "title": "算法" },
      { "count": 1542, "name": "编程之美", "title": "编程之美" },
      { "count": 1514, "name": "编程", "title": "编程" },
      { "count": 1065, "name": "面试", "title": "面试" },
      { "count": 1000, "name": "计算机", "title": "计算机" },
      { "count": 640, "name": "程序设计", "title": "程序设计" },
      { "count": 530, "name": "微软", "title": "微软" },
      { "count": 489, "name": "思维", "title": "思维" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s2992671.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章 游戏之乐--游戏中碰到的题目\n1.1 让CPU占用率曲线听你指挥\n1.2 中国象棋将帅问题\n1.3 一摞烙饼的排序\n1.4 买书问题\n1.5 快速找出故障机器\n1.6 饮料供货\n1.7 光影切割问题\n1.8 小飞的电梯调度算法\n1.9 高效率地安排见面会\n1.10 双线程高效下载\n1.11 NIM（1）一排石头的游戏\n1.12 NIM（2）“拈”游戏分析\n1.13 NIM（3）两堆石头的游戏\n1.14 连连看游戏设计\n1.15 构造数独\n1.16 24点游戏\n1.17 俄罗斯方块游戏\n1.18 挖雷游戏\n第2章 数字之魅--数字中的技巧\n2.1 求二进制数中1的个数\n2.2 不要被阶乘吓倒\n2.3 寻找发帖“水王”\n2.4 1的数目\n2.5 寻找最大的K个数\n2.6 精确表达浮点数\n2.7 最大公约数问题\n2.8 找符合条件的整数\n2.9 斐波那契（Fibonacci）数列\n2.10 寻找数组中的最大值和最小值\n2.11 寻找最近点对\n2.12 快速寻找满足条件的两个数\n2.13 子数组的最大乘积\n2.14 求数组的子数组之和的最大值\n2.15 子数组之和的最大值（二维）\n2.16 求数组中最长递增子序列\n2.17 数组循环移位\n2.18 数组分割\n2.19 区间重合判断\n2.20 程序理解和时间分析\n2.21 只考加法的面试题\n第3章 结构之法--字符串及链表的探索\n3.1 字符串移位包含的问题\n3.2 电话号码对应英语单词\n3.3 计算字符串的相似度\n3.4 从无头单链表中删除节点\n3.5 最短摘要的生成\n3.6 编程判断两个链表是否相交\n3.7 队列中取最大值操作问题\n3.8 求二叉树中节点的最大距离\n3.9 重建二叉树\n3.10 分层遍历二叉树\n3.11 程序改错\n第4章 数学之趣--数学游戏的乐趣\n4.1 金刚坐飞机问题\n4.2 瓷砖覆盖地板\n4.3 买票找零\n4.4 点是否在三角形内\n4.5 磁带文件存放优化\n4.6 桶中取黑白球\n4.7 蚂蚁爬杆\n4.8 三角形测试用例\n4.9 数独知多少\n4.10 数字哑谜和回文\n4.11 挖雷游戏的概率",
    "ebook_url": "https://read.douban.com/ebook/1523295/",
    "pages": "327",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s2992671.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s2992671.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s2992671.jpg"
    },
    "alt": "https://book.douban.com/subject/3004255/",
    "id": "3004255",
    "publisher": "电子工业出版社",
    "isbn10": "7121060744",
    "isbn13": "9787121060748",
    "title": "编程之美",
    "url": "https://api.douban.com/v2/book/3004255",
    "alt_title": "",
    "author_intro": "",
    "summary": "这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。本书的内容分为下面几个部分：\n（1）游戏之乐：从游戏和其他有趣问题出发，化繁为简，分析总结。\n（2）数字之魅：编程的过程实际上就是和数字及字符打交道的过程。这一部分收集了一些好玩的对数字进行处理的题目。\n（3）结构之法：汇集了常见的对字符串、链表、队列，以及树等进行操作的题目。\n（4）数学之趣：列举了一些不需要写具体程序的数学问题，锻炼读者的抽象思维能力。\n书中绝大部分题目都提供了详细的解说。 每道题目后面还有一至两道扩展问题，供读者进一步钻研。\n书中还讲述了面试的各种小故事，告诉读者微软需要什么样的技术人才，重视什么样的能力，如何甄别人才。回答读者关于IT业面试，招聘，职业发展的疑问。这本书的很多题目会出现在IT 行业的各种笔试、面试中，但这本书更深层的意义在于引导读者思考，和读者共享思考之乐，编程之美。",
    "ebook_price": "22.00",
    "price": "40.00元"
  },
  "9787115459572": {
    "rating": { "max": 10, "numRaters": 16, "average": "8.5", "min": 0 },
    "subtitle": "",
    "author": ["陈小玉"],
    "pubdate": "2017-7-1",
    "tags": [
      { "count": 38, "name": "算法", "title": "算法" },
      { "count": 23, "name": "编程", "title": "编程" },
      { "count": 8, "name": "计算机科学", "title": "计算机科学" },
      { "count": 8, "name": "计算机", "title": "计算机" },
      { "count": 7, "name": "数学", "title": "数学" },
      { "count": 3, "name": "经典课本", "title": "经典课本" },
      { "count": 3, "name": "2017", "title": "2017" },
      { "count": 2, "name": "我想读这本书", "title": "我想读这本书" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29513356.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章　算法之美 1\n1.1　打开算法之门 2\n1.2　妙不可言—算法复杂性 2\n1.3　美不胜收—魔鬼序列 9\n1.4　灵魂之交—马克思手稿中的数学题 16\n1.5　算法学习瓶颈 21\n1.6　你怕什么 22\n第2章　贪心算法 24\n2.1　人之初，性本贪 25\n2.1.1 贪心本质 25\n2.1.2 贪亦有道 26\n2.1.3 贪心算法秘籍 26\n2.2　加勒比海盗船—最优装载问题 27\n2.2.1 问题分析 27\n2.2.2 算法设计 28\n2.2.3 完美图解 28\n2.2.4 伪代码详解 29\n2.2.5 实战演练 30\n2.2.6 算法解析及优化拓展 31\n2.3　阿里巴巴与四十大盗—背包问题 32\n2.3.1 问题分析 32\n2.3.2 算法设计 33\n2.3.3 完美图解 33\n2.3.4 伪代码详解 34\n2.3.5 实战演练 35\n2.3.6 算法解析及优化拓展 36\n2.4　高级钟点秘书—会议安排 37\n2.4.1 问题分析 38\n2.4.2 算法设计 39\n2.4.3 完美图解 40\n2.4.4 伪代码详解 41\n2.4.5 实战演练 42\n2.4.6 算法解析及优化拓展 45\n2.5　一场说走就走的旅行—最短路径 45\n2.5.1 问题分析 46\n2.5.2 算法设计 46\n2.5.3 完美图解 47\n2.5.4 伪代码详解 51\n2.5.5 实战演练 52\n2.5.6 算法解析及优化拓展 55\n2.6　神秘电报密码—哈夫曼编码 59\n2.6.1 问题分析 60\n2.6.2 算法设计 62\n2.6.3 完美图解 63\n2.6.4 伪代码详解 65\n2.6.5 实战演练 74\n2.6.6 算法解析及优化拓展 77\n2.7　沟通无限校园网—最小生成树 77\n2.7.1 问题分析 78\n2.7.2 算法设计 79\n2.7.3 完美图解 80\n2.7.4 伪代码详解 87\n2.7.5 实战演练 88\n2.7.6 算法解析 90\n2.7.7 算法优化拓展 90\n第3章　分治法 99\n3.1　山高皇帝远 100\n3.1.1 治众如治寡—分而治之 100\n3.1.2 天时地利人和—分治算法要素 100\n3.1.3 分治算法秘籍 101\n3.2　猜数游戏—二分搜索技术 101\n3.2.1 问题分析 101\n3.2.2 算法设计 102\n3.2.3 完美图解 102\n3.2.4 伪代码详解 103\n3.2.5 实战演练 104\n3.2.6 算法解析与拓展 105\n3.3　合久必分，分久必合—合并排序 107\n3.3.1 问题分析 108\n3.3.2 算法设计 108\n3.3.3 完美图解 108\n3.3.4 伪代码详解 108\n3.3.5 实战演练 111\n3.3.6 算法解析与拓展 112\n3.4　兵贵神速—快速排序 113\n3.4.1 问题分析 114\n3.4.2 算法设计 115\n3.4.3 完美图解 116\n3.4.4 伪代码详解 117\n3.4.5 实战演练 118\n3.4.6 算法解析与拓展 120\n3.5　效率至上—大整数乘法 124\n3.5.1 问题分析 124\n3.5.2 算法设计 125\n3.5.3 完美图解 126\n3.5.4 伪代码详解 128\n3.5.5 实战演练 132\n3.5.6 算法解析与拓展 135\n3.6　分治算法复杂度求解秘籍 137\n第4章　动态规划 141\n4.1　神奇的兔子序列 142\n4.2　动态规划基础 143\n4.2.1　算法思想 143\n4.2.2　算法要素 143\n4.2.3　解题秘籍 143\n4.3　孩子有多像爸爸—最长的公共子序列 145\n4.3.1　问题分析 145\n4.3.2　算法设计 147\n4.3.3　完美图解 148\n4.3.4　伪代码详解 152\n4.3.5　实战演练 153\n4.3.6　算法解析及优化拓展 155\n4.4　DNA基因鉴定—编辑距离 156\n4.4.1　问题分析 156\n4.4.2　算法设计 158\n4.4.3　完美图解 159\n4.4.4　伪代码详解 161\n4.4.5　实战演练 162\n4.4.6　算法解析及优化拓展 163\n4.5　长江一日游—游艇租赁 164\n4.5.1　问题分析 164\n4.5.2　算法设计 166\n4.5.3　完美图解 166\n4.5.4　伪代码详解 170\n4.5.5　实战演练 171\n4.5.6　算法解析及优化拓展 172\n4.6　快速计算—矩阵连乘 172\n4.6.1　问题分析 173\n4.6.2　算法设计 176\n4.6.3　完美图解 176\n4.6.4　伪代码详解 180\n4.6.5　实战演练 181\n4.6.6　算法解析及优化拓展 182\n4.7　切呀切披萨—最优三角剖分 183\n4.7.1　问题分析 183\n4.7.2　算法设计 186\n4.7.3　完美图解 187\n4.7.4　伪代码详解 191\n4.7.5　实战演练 192\n4.7.6　算法解析及优化拓展 194\n4.8　小石子游戏—石子合并 194\n4.8.1　问题分析 195\n4.8.2　算法设计 197\n4.8.3　完美图解 198\n4.8.4　伪代码详解 203\n4.8.5　实战演练 205\n4.8.6　算法解析及优化拓展 206\n4.9　大卖场购物车1—0-1背包问题 209\n4.9.1　问题分析 210\n4.9.2　算法设计 211\n4.9.3　完美图解 212\n4.9.4　伪代码详解 216\n4.9.5　实战演练 217\n4.9.6　算法解析及优化拓展 218\n4.10　快速定位—最优二叉搜索树 220\n4.10.1　问题分析 221\n4.10.2　算法设计 225\n4.10.3　完美图解 226\n4.10.4　伪代码详解 239\n4.10.5　实战演练 241\n4.10.6　算法解析及优化拓展 243\n4.11　动态规划算法秘籍 246\n第5章　回溯法 248\n5.1　回溯法基础 249\n5.1.1　算法思想 249\n5.1.2　算法要素 249\n5.1.3　解题秘籍 251\n5.2　大卖场购物车2—0-1背包问题 252\n5.2.1　问题分析 252\n5.2.2　算法设计 253\n5.2.3　完美图解 255\n5.2.4　伪代码详解 258\n5.2.5　实战演练 259\n5.2.6　算法解析 262\n5.2.7　算法优化拓展 262\n5.3　部落护卫队—最大团 265\n5.3.1　问题分析 266\n5.3.2　算法设计 267\n5.3.3　完美图解 269\n5.3.4　伪代码详解 274\n5.3.5　实战演练 275\n5.3.6　算法解析及优化拓展 277\n5.4　地图调色板—地图着色 278\n5.4.1　问题分析 278\n5.4.2　算法设计 279\n5.4.3　完美图解 280\n5.4.4　伪代码详解 285\n5.4.5　实战演练 286\n5.4.6　算法解析及优化拓展 288\n5.5　一山不容二虎—n皇后问题 289\n5.5.1　问题分析 290\n5.5.2　算法设计 291\n5.5.3　完美图解 292\n5.5.4　伪代码详解 300\n5.5.5　实战演练 301\n5.5.6　算法解析及优化拓展 303\n5.6　机器零件加工—最优加工顺序 305\n5.6.1　问题分析 305\n5.6.2　算法设计 308\n5.6.3　完美图解 308\n5.6.4　伪代码详解 313\n5.6.5　实战演练 314\n5.6.6　算法解析 316\n5.6.7　算法优化拓展 316\n5.7　奇妙之旅1—旅行商问题 319\n5.7.1　问题分析 319\n5.7.2　算法设计 320\n5.7.3　完美图解 321\n5.7.4　伪代码详解 330\n5.7.5　实战演练 331\n5.7.6　算法解析及优化拓展 333\n5.8　回溯法算法秘籍 336\n第6章　分支限界法 338\n6.1　横行天下—广度优先 339\n6.1.1　算法思想 340\n6.1.2　算法步骤 340\n6.1.3　解题秘籍 341\n6.2　大卖场购物车3—0-1背包问题 341\n6.2.1　问题分析 342\n6.2.2　算法设计 343\n6.2.3　完美图解 345\n6.2.4　伪代码详解 350\n6.2.5　实战演练 352\n6.2.6　算法解析 355\n6.2.7　算法优化拓展—优先队列式分支限界法 356\n6.3　奇妙之旅2—旅行商问题 366\n6.3.1　问题分析 366\n6.3.2　算法设计 367\n6.3.3　完美图解 368\n6.3.4　伪代码详解 371\n6.3.5　实战演练 373\n6.3.6　算法解析 376\n6.3.7　算法优化拓展 377\n6.4　铺设电缆—最优工程布线 385\n6.4.1　问题分析 386\n6.4.2　算法设计 386\n6.4.3　完美图解 387\n6.4.4　伪代码详解 399\n6.4.5　实战演练 400\n6.4.6　算法解析及优化拓展 403\n6.5　回溯法与分支限界法的异同 404\n第7章　线性规划网络流 405\n7.1　线性规划问题 406\n7.1.1 线性规划标准型 408\n7.1.2 单纯形算法图解 409\n7.1.3 解题秘籍 413\n7.1.4 练习 413\n7.2　工厂最大效益—单纯形算法 414\n7.2.1 问题分析 414\n7.2.2 完美图解 415\n7.2.3 伪代码详解 418\n7.2.4 实战演练 420\n7.2.5 算法解析及优化拓展 423\n7.3　最大网络流—最短增广路算法 424\n7.3.1 问题分析 424\n7.3.2 增广路算法 427\n7.3.3 完美图解 431\n7.3.4 伪代码详解 437\n7.3.5 实战演练 439\n7.3.6 算法解析 441\n7.3.7 算法优化拓展—重贴标签算法ISAP 442\n7.4　最小费用最大流—最小费用路算法 455\n7.4.1 问题分析 456\n7.4.2 算法设计 456\n7.4.3 完美图解 457\n7.4.4 伪代码详解 459\n7.4.5 实战演练 461\n7.4.6 算法解析 465\n7.4.7 算法优化拓展—消圈算法 466\n7.5　精明的老板—配对方案问题 468\n7.5.1 问题分析 468\n7.5.2 算法设计 469\n7.5.3 完美图解 469\n7.5.4 伪代码详解 470\n7.5.5 实战演练 471\n7.5.6 算法解析 475\n7.5.7 算法优化拓展—匈牙利算法 475\n7.6　国际会议交流—圆桌问题 480\n7.6.1 问题分析 481\n7.6.2 算法设计 482\n7.6.3 完美图解 482\n7.6.4 伪代码详解 484\n7.6.5 实战演练 485\n7.6.6 算法解析及优化拓展 489\n7.7　要考试啦—试题库问题 489\n7.7.1 问题分析 490\n7.7.2 算法设计 490\n7.7.3 完美图解 491\n7.7.4 伪代码详解 493\n7.7.5 实战演练 494\n7.7.6 算法解析及优化拓展 498\n7.8　太空实验计划—最大收益问题 499\n7.8.1 问题分析 499\n7.8.2 算法设计 500\n7.8.3 完美图解 502\n7.8.4 伪代码详解 505\n7.8.5 实战演练 506\n7.8.6 算法解析及优化拓展 510\n7.9　央视娱乐节目购物街—方格取数问题 511\n7.9.1 问题分析 511\n7.9.2 算法设计 512\n7.9.3 完美图解 513\n7.9.4 伪代码详解 514\n7.9.5 实战演练 516\n7.9.6 算法解析及优化拓展 520\n7.10　走着走着，就走到了西藏—旅游路线问题 521\n7.10.1 问题分析 521\n7.10.2 算法设计 523\n7.10.3 完美图解 523\n7.10.4 伪代码详解 525\n7.10.5 实战演练 528\n7.10.6 算法解析及优化拓展 532\n7.11　网络流问题解题秘籍 533\n附录A　特征方程和通项公式 534\n附录B　sort函数 537\n附录C　优先队列 541\n附录D　邻接表 549\n附录E　并查集 555\n附录F　四边不等式 561\n附录G　排列树 565\n附录H　贝尔曼规则 579\n附录I　增广路中称为关键边的次数 582\n附录J　最大流最小割定理 585",
    "pages": "587",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29513356.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29513356.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29513356.jpg"
    },
    "alt": "https://book.douban.com/subject/27109832/",
    "id": "27109832",
    "publisher": "人民邮电出版社",
    "isbn10": "7115459576",
    "isbn13": "9787115459572",
    "title": "趣学算法",
    "url": "https://api.douban.com/v2/book/27109832",
    "alt_title": "",
    "author_intro": "陈小玉，副教授，硕士，高级程序员，研究方向：智能计算、机器学习与数据挖掘。主讲《数据结构》、《算法设计与分析》、《人工智能》等专业课程，并发表过多篇计算机专业论文和项目。",
    "summary": "本书内容按照算法策略分为7章。\n第1章从算法之美、简单小问题、趣味故事引入算法概念、时间复杂度、空间复杂度的概念和计算方法，以及算法设计的爆炸性增量问题，使读者体验算法的奥妙。\n第2～7章介绍经典算法的设计策略、实战演练、算法分析及优化拓展，分别讲解贪心算法、分治算法、动态规划、回溯法、分支限界法、线性规划和网络流。每一种算法都有4～10个实例，共50个大型实例，包括经典的构造实例和实际应用实例，按照问题分析、算法设计、完美图解、伪代码详解、实战演练、算法解析及优化拓展的流程，讲解清楚且通俗易懂。附录介绍常见的数据结构及算法改进用到的相关知识，包括sort函数、优先队列、邻接表、并查集、四边不等式、排列树、贝尔曼规则、增广路复杂性计算、最大流最小割定理等内容。\n本书可作为程序员的学习用书，也适合从未有过编程经验但又对算法有强烈兴趣的初学者使用，同时也可作为高等院校计算机、数学及相关专业的师生用书和培训学校的教材。",
    "price": "89.00元"
  },
  "9787115473899": {
    "rating": { "max": 10, "numRaters": 45, "average": "7.8", "min": 0 },
    "subtitle": "让Web性能更上一层楼",
    "author": ["Stephen Ludin", "Javier Garza"],
    "pubdate": "2018-1",
    "tags": [
      { "count": 24, "name": "计算机网络", "title": "计算机网络" },
      { "count": 23, "name": "HTTP/2", "title": "HTTP/2" },
      { "count": 23, "name": "HTTP", "title": "HTTP" },
      { "count": 8, "name": "计算机", "title": "计算机" },
      { "count": 5, "name": "前端", "title": "前端" },
      { "count": 4, "name": "计算机基础知识", "title": "计算机基础知识" },
      { "count": 4, "name": "Web", "title": "Web" },
      { "count": 3, "name": "network", "title": "network" }
    ],
    "origin_title": "Learning HTTP/2",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29665581.jpg",
    "binding": "平装",
    "translator": ["罗正龙", "郑维智"],
    "catalog": "目录\n版权声明\nO'Reilly Media, Inc. 介绍\n中文版推荐序一：等待与希望\n中文版推荐序二\n序\n前言\n第 1 章　HTTP 进化史\n第 2 章　HTTP/2 快速入门\n第 3 章　Web 优化“黑魔法”的动机与方式\n第 4 章　HTTP/2 迁移\n第 5 章　HTTP/2 协议\n第 6 章　HTTP/2 性能\n第 7 章　HTTP/2 实现\n第 8 章　HTTP/2 调试\n第 9 章　展望未来\n附录 A　HTTP/2 帧\n附录 B　工具引用",
    "pages": "136",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29665581.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29665581.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29665581.jpg"
    },
    "alt": "https://book.douban.com/subject/27665112/",
    "id": "27665112",
    "publisher": "人民邮电出版社",
    "isbn10": "7115473897",
    "isbn13": "9787115473899",
    "title": "HTTP/2基础教程",
    "url": "https://api.douban.com/v2/book/27665112",
    "alt_title": "Learning HTTP/2",
    "author_intro": "Stephen Ludin，Akamai公司Web性能部门CAO，带领Akamai公司的Foundry团队，负责研发下一代Web技术。\nJavier Garza，Akamai公司高级企业架构师，专注于公司的主要客户及战略合作伙伴。他也是Web性能优化和HTTP/2的布道者，为Akamai的产品开发团队提供技术建议和客户反馈",
    "summary": "让网站和应用更快速、更简洁、更稳健，从而有效提升用户体验，这无疑是众多开发者梦寐以求的。然而互联网发展日新月异，HTTP/1.1协议已经难以满足现今的需求。在众多Web性能提升方案中，HTTP/2值得尝试。\n本书是HTTP/2实用指南，介绍了HTTP/2的设计初衷和新特性，以及如何才能充分利用这些特性来打造高性能网站及应用。作者用定量分析方法，对比了不同网络环境下及不同浏览器上HTTP/1.1与HTTP/2的性能差异，并指出了网站迁移到HTTP/2需要注意的问题及对策。\n本书主要内容：\nHTTP发展回顾——面临性能挑战，促使协议升级\nHTTP/2概览——优点及迁移方法\n既有的建议方案，以及提升Web性能的技巧\nHTTP/2支持的浏览器、服务器、代理，以及内容分发网络\n相比于HTTP/1.1，采用HTTP/2的网站在性能上有何提升\nHTTP/2对网络通信中一些具体问题的改进，如延迟、丢包、首字节时间等",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "49.00元"
  },
  "9787115432728": {
    "rating": { "max": 10, "numRaters": 34, "average": "7.8", "min": 0 },
    "subtitle": "在服务器和Web应用上部署SSL-TLS和PKI",
    "author": ["[英] Ivan Risti?"],
    "pubdate": "2016-9",
    "tags": [
      { "count": 46, "name": "https", "title": "https" },
      { "count": 35, "name": "网络安全", "title": "网络安全" },
      { "count": 24, "name": "计算机网络", "title": "计算机网络" },
      { "count": 24, "name": "HTTP", "title": "HTTP" },
      { "count": 19, "name": "web", "title": "web" },
      { "count": 16, "name": "计算机", "title": "计算机" },
      { "count": 10, "name": "计算机科学", "title": "计算机科学" },
      { "count": 9, "name": "网络", "title": "网络" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29028883.jpg",
    "binding": "平装",
    "translator": ["杨洋", "李振宇", "蒋锷", "周辉", "陈传文"],
    "catalog": "第1章　SSL、TLS和密码学　　1\n1.1　传输层安全　　1\n1.2　网络层　　2\n1.3　协议历史　　3\n1.4　密码学　　4\n1.4.1　构建基块　　4\n1.4.2　协议　　12\n1.4.3　攻击密码　　13\n1.4.4　衡量强度　　13\n1.4.5　中间人攻击　　15\n第2章　协议　　19\n2.1　记录协议　　19\n2.2　握手协议　　21\n2.2.1　完整的握手　　21\n2.2.2　客户端身份验证　　26\n2.2.3　会话恢复　　28\n2.3　密钥交换　　29\n2.3.1　RSA密钥交换　　30\n2.3.2　Diffie-Hellman密钥交换　　31\n2.3.3　椭圆曲线Diffie-Hellman密钥交换　　33\n2.4　身份验证　　34\n2.5　加密　　34\n2.5.1　序列加密　　34\n2.5.2　分组加密　　35\n2.5.3　已验证的加密　　36\n2.6　重新协商　　37\n2.7　应用数据协议　　38\n2.8　警报协议　　38\n2.9　关闭连接　　39\n2.10　密码操作　　39\n2.10.1　伪随机函数　　39\n2.10.2　主密钥　　40\n2.10.3　密钥生成　　40\n2.11　密码套件　　41\n2.12　扩展　　42\n2.12.1　应用层协议协商　　43\n2.12.2　证书透明度　　44\n2.12.3　椭圆曲线功能　　44\n2.12.4　心跳　　45\n2.12.5　次协议协商　　46\n2.12.6　安全重新协商　　47\n2.12.7　服务器名称指示　　47\n2.12.8　会话票证　　48\n2.12.9　签名算法　　48\n2.12.10　OCSP stapling　　49\n2.13　协议限制　　49\n2.14　协议版本间的差异　　50\n2.14.1　SSL 3　　50\n2.14.2　TLS 1.0　　50\n2.14.3　TLS 1.1　　50\n2.14.4　TLS 1.2　　51\n第3章　公钥基础设施　　52\n3.1　互联网公钥基础设施　　52\n3.2　标准　　54\n3.3　证书　　55\n3.3.1　证书字段　　55\n3.3.2　证书扩展　　57\n3.4　证书链　　58\n3.5　信赖方　　60\n3.6　证书颁发机构　　61\n3.7　证书生命周期　　62\n3.8　吊销　　63\n3.9　弱点　　63\n3.10　根密钥泄露　　65\n3.11　生态系统评估　　66\n3.12　进步　　68\n第4章　攻击PKI　　71\n4.1　VeriSign签发的Microsoft代码签名证书　　71\n4.2　Thawte签发的login.live.com　　72\n4.3　StartCom违规（2008）　　72\n4.4　CertStar（Comodo）签发的Mozilla证书　　73\n4.5　伪造的RapidSSL CA证书　　73\n4.5.1　前缀选择碰撞攻击　　75\n4.5.2　创建碰撞证书　　75\n4.5.3　预测前缀　　76\n4.5.4　接下来发生的事　　78\n4.6　Comodo代理商违规　　78\n4.7　StartCom违规（2011）　　80\n4.8　DigiNotar　　80\n4.8.1　公众的发现　　80\n4.8.2　一个证书颁发机构的倒下　　81\n4.8.3　中间人攻击　　82\n4.8.4　ComodoHacker宣布负责　　83\n4.9　DigiCert Sdn. Bhd.　　85\n4.10　火焰病毒　　85\n4.10.1　火焰病毒对抗Windows更新　　86\n4.10.2　火焰病毒对抗Windows终端服务　　87\n4.10.3　火焰病毒对抗MD5　　88\n4.11　TURKTRUST　　89\n4.12　ANSSI　　90\n4.13　印度国家信息中心　　91\n4.14　广泛存在的SSL窃听　　91\n4.14.1　Gogo　　91\n4.14.2　Superfish和它的朋友们　　92\n4.15　CNNIC　　93\n第5章　HTTP和浏览器问题　　95\n5.1　sidejacking　　95\n5.2　Cookie窃取　　97\n5.3　Cookie篡改　　98\n5.3.1　了解HTTP Cookie　　98\n5.3.2　Cookie篡改攻击　　99\n5.3.3　影响　　102\n5.3.4　缓解方法　　103\n5.4　SSL剥离　　103\n5.5　中间人攻击证书　　104\n5.6　证书警告　　105\n5.6.1　为什么有这么多无效证书　　107\n5.6.2　证书警告的效果　　108\n5.6.3　点击—通过式警告与例外　　109\n5.6.4　缓解方法　　110\n5.7　安全指示标志　　110\n5.8　混合内容　　112\n5.8.1　根本原因　　112\n5.8.2　影响　　114\n5.8.3　浏览器处理　　114\n5.8.4　混合内容的流行程度　　116\n5.8.5　缓解方法　　117\n5.9　扩展验证证书　　118\n5.10　证书吊销　　119\n5.10.1　客户端支持不足　　119\n5.10.2　吊销检查标准的主要问题　　119\n5.10.3　证书吊销列表　　120\n5.10.4　在线证书状态协议　　122\n第6章　实现问题　　127\n6.1　证书校验缺陷　　127\n6.1.1　在库和平台中的证书校验缺陷　　128\n6.1.2　应用程序校验缺陷　　131\n6.1.3　主机名校验问题　　132\n6.2　随机数生成　　133\n6.2.1　Netscape Navigator浏览器（1994）　　133\n6.2.2　Debian（2006）　　134\n6.2.3　嵌入式设备熵不足问题　　135\n6.3　心脏出血　　137\n6.3.1　影响　　137\n6.3.2　缓解方法　　139\n6.4　FREAK　　139\n6.4.1　出口密码　　140\n6.4.2　攻击　　140\n6.4.3　影响和缓解方法　　143\n6.5　Logjam　　144\n6.5.1　针对不安全DHE密钥交换的主动攻击　　144\n6.5.2　针对不安全DHE密钥交换的预先计算攻击　　145\n6.5.3　针对弱DH密钥交换的状态—水平威胁　　146\n6.5.4　影响　　147\n6.5.5　缓解方法　　148\n6.6　协议降级攻击　　148\n6.6.1　SSL 3中的回退保护　　149\n6.6.2　互操作性问题　　149\n6.6.3　自愿协议降级　　152\n6.6.4　TLS 1.0和之后协议的回退保护　　153\n6.6.5　攻击自愿协议降级　　154\n6.6.6　现代回退防御　　154\n6.7　截断攻击　　156\n6.7.1　截断攻击的历史　　157\n6.7.2　Cookie截断　　157\n6.8　部署上的弱点　　159\n6.8.1　虚拟主机混淆　　159\n6.8.2　TLS会话缓存共享　　160\n第7章　协议攻击　　161\n7.1　不安全重新协商　　161\n7.1.1　为什么重新协商是不安全的　　162\n7.1.2　触发弱点　　162\n7.1.3　针对HTTP协议的攻击　　163\n7.1.4　针对其他协议的攻击　　166\n7.1.5　由架构引入的不安全重新协商问题　　167\n7.1.6　影响　　167\n7.1.7　缓解方法　　167\n7.1.8　漏洞发现和补救时间表　　168\n7.2　BEAST　　169\n7.2.1　BEAST的原理　　170\n7.2.2　客户端缓解方法　　173\n7.2.3　服务器端缓解方法　　175\n7.2.4　历史　　176\n7.2.5　影响　　177\n7.3　压缩旁路攻击　　178\n7.3.1　压缩预示如何生效　　178\n7.3.2　攻击的历史　　180\n7.3.3　CRIME　　181\n7.3.4　针对TLS和SPDY攻击的缓解方法　　187\n7.3.5　针对HTTP压缩攻击的缓解方法　　188\n7.4　Lucky 13　　189\n7.4.1　什么是填充预示　　189\n7.4.2　针对TLS的攻击　　190\n7.4.3　影响　　191\n7.4.4　缓解方法　　191\n7.5　RC4缺陷　　192\n7.5.1　密钥调度弱点　　192\n7.5.2　单字节偏差　　193\n7.5.3　前256字节偏差　　194\n7.5.4　双字节偏差　　196\n7.5.5　针对密码进行攻击的改进　　196\n7.5.6　缓解方法：RC4与BEAST、Lucky 13和POODLE的比较　　197\n7.6　三次握手攻击　　198\n7.6.1　攻击　　198\n7.6.2　影响　　202\n7.6.3　先决条件　　203\n7.6.4　缓解方法　　203\n7.7　POODLE　　204\n7.7.1　实际攻击　　207\n7.7.2　影响　　208\n7.7.3　缓解方法　　208\n7.8　Bullrun　　209\n第8章　部署　　212\n8.1　密钥　　212\n8.1.1　密钥算法　　212\n8.1.2　密钥长度　　213\n8.1.3　密钥管理　　213\n8.2　证书　　215\n8.2.1　证书类型　　215\n8.2.2　证书主机名　　215\n8.2.3　证书共享　　216\n8.2.4　签名算法　　216\n8.2.5　证书链　　217\n8.2.6　证书吊销　　218\n8.2.7　选择合适的CA　　218\n8.3　协议配置　　219\n8.4　密码套件配置　　220\n8.4.1　服务器密码套件配置优先　　220\n8.4.2　加密强度　　220\n8.4.3　前向保密　　221\n8.4.4　性能　　222\n8.4.5　互操作性　　222\n8.5　服务器配置和架构　　223\n8.5.1　共享环境　　223\n8.5.2　虚拟安全托管　　223\n8.5.3　会话缓存　　223\n8.5.4　复杂体系结构　　224\n8.6　问题缓解方法　　225\n8.6.1　重新协商　　225\n8.6.2　BEAST（HTTP）　　225\n8.6.3　CRIME（HTTP）　　225\n8.6.4　Lucky 13　　226\n8.6.5　RC4　　226\n8.6.6　TIME和BREACH（HTTP）　　227\n8.6.7　三次握手攻击　　227\n8.6.8　心脏出血　　228\n8.7　钉扎　　228\n8.8　HTTP　　228\n8.8.1　充分利用加密　　228\n8.8.2　Cookie安全　　229\n8.8.3　后端证书和域名验证　　229\n8.8.4　HTTP严格传输安全　　229\n8.8.5　内容安全策略　　230\n8.8.6　协议降级保护　　230\n第9章　性能优化　　231\n9.1　延迟和连接管理　　232\n9.1.1　TCP 优化　　232\n9.1.2　长连接　　234\n9.1.3　SPDY、HTTP 2.0以及其他　　235\n9.1.4　内容分发网络　　235\n9.2　TLS协议优化　　237\n9.2.1　密钥交换　　237\n9.2.2　证书　　240\n9.2.3　吊销检查　　242\n9.2.4　会话恢复　　243\n9.2.5　传输开销　　243\n9.2.6　对称加密　　244\n9.2.7　TLS记录缓存延迟　　246\n9.2.8　互操作性　　247\n9.2.9　硬件加速　　247\n9.3　拒绝服务攻击　　248\n9.3.1　密钥交换和加密CPU开销　　249\n9.3.2　客户端发起的重新协商　　250\n9.3.3　优化过的TLS拒绝服务攻击　　250\n第10章　HTTP严格传输安全、内容安全策略和钉扎　　251\n10.1　HTTP严格传输安全　　251\n10.1.1　配置HSTS　　252\n10.1.2　确保主机名覆盖　　253\n10.1.3　Cookie安全　　253\n10.1.4　攻击向量　　254\n10.1.5　浏览器支持　　255\n10.1.6　强大的部署清单　　256\n10.1.7　隐私问题　　257\n10.2　内容安全策略　　257\n10.2.1　防止混合内容问题　　258\n10.2.2　策略测试　　259\n10.2.3　报告　　259\n10.2.4　浏览器支持　　259\n10.3　钉扎　　260\n10.3.1　钉扎的对象　　261\n10.3.2　在哪里钉扎　　262\n10.3.3　应该使用钉扎吗　　263\n10.3.4　在本机应用程序中使用钉扎　　263\n10.3.5　Chrome公钥钉扎　　264\n10.3.6　Microsoft Enhanced Mitiga-tion Experience Toolkit　　265\n10.3.7　HTTP公钥钉扎扩展　　265\n10.3.8　DANE　　267\n10.3.9　证书密钥可信保证　　270\n10.3.10　证书颁发机构授权　　271\n第11章　OpenSSL　　272\n11.1　入门　　272\n11.1.1　确定OpenSSL版本和配置　　273\n11.1.2　构建OpenSSL　　274\n11.1.3　查看可用命令　　275\n11.1.4　创建可信证书库　　276\n11.2　密钥和证书管理　　277\n11.2.1　生成密钥　　277\n11.2.2　创建证书签名申请　　280\n11.2.3　用当前证书生成CSR文件　　282\n11.2.4　非交互方式生成CSR　　282\n11.2.5　自签名证书　　283\n11.2.6　创建对多个主机名有效的证书　　283\n11.2.7　检查证书　　284\n11.2.8　密钥和证书格式转换　　286\n11.3　配置　　288\n11.3.1　选择密码套件　　288\n11.3.2　性能　　298\n11.4　创建私有证书颁发机构　　300\n11.4.1　功能和限制　　301\n11.4.2　创建根CA　　301\n11.4.3　创建二级CA　　306\n第12章　使用OpenSSL进行测试　　309\n12.1　连接SSL服务　　309\n12.2　测试升级到SSL的协议　　312\n12.3　使用不同的握手格式　　313\n12.4　提取远程证书　　313\n12.5　测试支持的协议　　314\n12.6　测试支持的密码套件　　314\n12.7　测试要求包含SNI的服务器　　315\n12.8　测试会话复用　　316\n12.9　检查OCSP吊销状态　　316\n12.10　测试OCSP stapling　　318\n12.11　检查CRL吊销状态　　319\n12.12　测试重新协商　　321\n12.13　测试BEAST漏洞　　322\n12.14　测试心脏出血　　323\n12.15　确定Diffie-Hellman参数的强度　　325\n第13章　配置Apache　　327\n13.1　安装静态编译OpenSSL的Apache　　328\n13.2　启用TLS　　329\n13.3　配置TLS协议　　329\n13.4　配置密钥和证书　　330\n13.5　配置多个密钥　　331\n13.6　通配符和多站点证书　　332\n13.7　虚拟安全托管　　333\n13.8　为错误消息保留默认站点　　334\n13.9　前向保密　　335\n13.10　OCSP stapling　　336\n13.10.1　配置OCSP stapling　　336\n13.10.2　处理错误　　337\n13.10.3　使用自定义OCSP响应程序　　338\n13.11　配置临时的DH密钥交换　　338\n13.12　TLS会话管理　　338\n13.12.1　独立会话缓存　　338\n13.12.2　独立会话票证　　339\n13.12.3　分布式会话缓存　　340\n13.12.4　分布式会话票证　　341\n13.12.5　禁用会话票证　　342\n13.13　客户端身份验证　　343\n13.14　缓解协议问题　　344\n13.14.1　不安全的重新协商　　344\n13.14.2　BEAST　　344\n13.14.3　CRIME　　344\n13.15　部署HTTP严格传输安全　　345\n13.16　监视会话缓存状态　　346\n13.17　记录协商的TLS参数　　346\n13.18　使用mod_sslhaf的高级日志记录　　347\n第14章　配置Java和Tomcat　　349\n14.1　Java加密组件　　349\n14.1.1　无限制的强加密　　350\n14.1.2　Provider配置　　350\n14.1.3　功能概述　　351\n14.1.4　协议漏洞　　352\n14.1.5　互操作性问题　　352\n14.1.6　属性配置调优　　354\n14.1.7　常见错误消息　　355\n14.1.8　保护Java Web应用　　358\n14.1.9　常见密钥库操作　　362\n14.2　Tomcat　　366\n14.2.1　TLS配置　　369\n14.2.2　JSSE配置　　371\n14.2.3　APR和OpenSSL配置　　373\n第15章　配置Microsoft Windows和IIS　　375\n15.1　Schannel　　375\n15.1.1　功能概述　　375\n15.1.2　协议漏洞　　377\n15.1.3　互操作性问题　　377\n15.2　Microsoft根证书计划　　379\n15.2.1　管理系统可信证书库　　379\n15.2.2　导入可信证书　　380\n15.2.3　可信证书黑名单　　380\n15.2.4　禁用根证书自动更新　　380\n15.3　配置　　380\n15.3.1　Schannel配置　　381\n15.3.2　密码套件配置　　382\n15.3.3　密钥和签名限制　　384\n15.3.4　重新协商配置　　389\n15.3.5　配置会话缓存　　390\n15.3.6　监控会话缓存　　391\n15.3.7　FIPS 140-2　　391\n15.3.8　第三方工具　　393\n15.4　保护ASP.NET网站应用的安全　　394\n15.4.1　强制使用SSL　　394\n15.4.2　Cookie的保护　　395\n15.4.3　保护会话Cookie和Forms身份验证的安全　　395\n15.4.4　部署HTTP严格传输安全　　396\n15.5　Internet信息服务　　396\n第16章　配置Nginx　　402\n16.1　以静态链接OpenSSL方式安装Nginx　　402\n16.2　启用TLS　　403\n16.3　配置TLS协议　　403\n16.4　配置密钥和证书　　404\n16.5　配置多密钥　　405\n16.6　通配符证书和多站点证书　　405\n16.7　虚拟安全托管　　406\n16.8　默认站点返回错误消息　　406\n16.9　前向保密　　407\n16.10　OCSP stapling　　407\n16.10.1　配置OCSP stapling　　408\n16.10.2　自定义OCSP响应　　409\n16.10.3　手动配置OCSP响应　　409\n16.11　配置临时DH密钥交换　　410\n16.12　配置临时ECDH密钥交换　　410\n16.13　TLS会话管理　　411\n16.13.1　独立会话缓存　　411\n16.13.2　独立会话票证　　411\n16.13.3　分布式会话缓存　　412\n16.13.4　分布式会话票证　　412\n16.13.5　禁用会话票证　　413\n16.14　客户端身份验证　　413\n16.15　缓解协议问题　　414\n16.15.1　不安全的重新协商　　414\n16.15.2　BEAST　　415\n16.15.3　CRIME　　415\n16.16　部署HTTP严格传输安全　　415\n16.17　TLS缓冲区调优　　416\n16.18　日志记录　　416\n第17章　总结　　418\n",
    "pages": "436",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29028883.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29028883.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29028883.jpg"
    },
    "alt": "https://book.douban.com/subject/26869219/",
    "id": "26869219",
    "publisher": "人民邮电出版社",
    "isbn10": "7115432724",
    "isbn13": "9787115432728",
    "title": "HTTPS权威指南",
    "url": "https://api.douban.com/v2/book/26869219",
    "alt_title": "",
    "author_intro": "作者简介：\nIvan Ristić\n资深安全专家、工程师，开发了开源应用防火墙ModSecurity以及许多SSL/TLS和PKI相关工具，并运营提供Web应用安全测试服务的SSL Labs网站。Ivan Ristić是诸多安全论坛的积极参与者，经常在Black Hat、RSA、OWASP AppSec等安全大会上发表演讲。他曾任Qualys的应用程序安全研究主任，是SSL Labs、Feisty Duck和Hardenize的创始人。\n译者简介：\n杨洋\n前阿里巴巴SSL/TLS、密码学和网络安全领域专家，曾负责阿里巴巴集团全站HTTPS和7层DDoS防御等产品的核心设计和研发。\n李振宇\n阿里巴巴运维专家，负责阿里巴巴集团HTTPS证书管理、架构设计等相关工作。\n蒋锷\n阿里巴巴应用运维专家，负责阿里巴巴集团HTTPS接入平台的建设，同时担任阿里巴巴全站HTTPS项目总项目经理，助力阿里巴巴进入HTTPS时代。\n周辉\n阿里巴巴应用运维专家，负责阿里全站HTTPS性能优化以及淘宝海外用户访问性能优化。\n陈传文\n前阿里巴巴集团专家，曾负责Tengine以及HTTPS接入层设计与研发。现专注于无线安全方面的研究探索工作。",
    "summary": "本书是集理论、协议细节、漏洞分析、部署建议于一体的详尽Web应用安全指南。书中具体内容包括：密码学基础，TLS协议，PKI体系及其安全性，HTTP和浏览器问题，协议漏洞；最新的攻击形式，如BEAST、CRIME、BREACH、Lucky 13等；详尽的部署建议；如何使用OpenSSL生成密钥和确认信息；如何使用Apache httpd、IIS、Nginx等进行安全配置。",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "99.00元"
  },
  "9787115281487": {
    "rating": { "max": 10, "numRaters": 1355, "average": "8.6", "min": 0 },
    "subtitle": "权威指南",
    "author": ["David Gourley", "Brian Totty"],
    "pubdate": "2012-9",
    "tags": [
      { "count": 2156, "name": "HTTP", "title": "HTTP" },
      { "count": 1002, "name": "网络", "title": "网络" },
      { "count": 770, "name": "计算机", "title": "计算机" },
      { "count": 617, "name": "互联网", "title": "互联网" },
      { "count": 584, "name": "协议", "title": "协议" },
      { "count": 532, "name": "web开发", "title": "web开发" },
      { "count": 313, "name": "基础理论", "title": "基础理论" },
      { "count": 249, "name": "编程", "title": "编程" }
    ],
    "origin_title": "HTTP: The Definitive Guide",
    "image": "https://img1.doubanio.com/view/subject/m/public/s11329547.jpg",
    "binding": "Paperback",
    "translator": ["陈涓", "赵振平"],
    "catalog": "目录\n第一部分 　HTTP：Web 的基础\n第1章 　HTTP 概述　　3\n1.1 　HTTP——因特网的多媒体信使 　 　4\n1.2 　Web 客户端和服务器  4\n1.3 　资源　　 5\n1.3.1 　媒体类型 　 　6\n1.3.2 　URI 　 　7\n1.3.3 　URL　　7\n1.3.4 　URN　　8\n1.4 　事务　　 9\n1.4.1 　方法　　9\n1.4.2 　状态码 　 　10\n1.4.3 　Web 页面中可以包含多个对象  10\n1.5 　报文　　11\n1.6 　连接　　13\n1.6.1 　TCP/IP 　 　13\n1.6.2 　连接、IP 地址及端口号 　 　14\n1.6.3 　使用Telnet 实例 　 　16\n1.7 　协议版本　　18\n1.8 　Web 的结构组件 　 　19\n1.8.1 　代理 　 　19\n1.8.2 　缓存 　 　20\n1.8.3 　网关 　 　20\n1.8.4 　隧道 　 　21\n1.8.5 　Agent 代理 　 　21\n1.9 　起始部分的结束语 　 　22\n1.10 　更多信息　　22\n1.10.1 　HTTP 协议信息  22\n1.10.2 　历史透视 　 　23\n1.10.3 　其他万维网信息 　 　23\n第2章 URL 与资源 　 　25\n2.1 　浏览因特网资源 　 　26\n2.2 　URL 的语法 　 　28\n2.2.1 　方案——使用什么协议 　 　29\n2.2.2 　主机与端口 　 　30\n2.2.3 　用户名和密码 　 　30\n2.2.4 　路径 　 　31\n2.2.5 　参数 　 　31\n2.2.6 　查询字符串 　 　32\n2.2.7 　片段 　 　33\n2.3 　URL 快捷方式 　 　34\n2.3.1 　相对URL  34\n2.3.2 　自动扩展URL  37\n2.4 　各种令人头疼的字符 　 　38\n2.4.1 　URL 字符集  38\n2.4.2 　编码机制  38\n2.4.3 　字符限制  39\n2.4.4 　另外一点说明 　 　40\n2.5 　方案的世界　　40\n2.6 　未来展望　　42\n2.7 　更多信息　　44\n第3章 　HTTP 报文 　 　45\n3.1 　报文流 　 　46\n3.1.1 　报文流入源端服务器 　 　46\n3.1.2 　报文向下游流动 　 　47\n3.2 　报文的组成部分 　 　47\n3.2.1 　报文的语法 　 　48\n3.2.2 　起始行 　 　50\n3.2.3 　首部 　 　53\n3.2.4 　实体的主体部分 　 　55\n3.2.5 　版本0.9 的报文 　 　55\n3.3 　方法　　56\n3.3.1 　安全方法  56\n3.3.2 　GET　　56\n3.3.3 　HEAD 　 　57\n3.3.4 　PUT　　57\n3.3.5 　POST 　 　58\n3.3.6 　TRACE 　 　58\n3.3.7 　OPTIONS 60\n3.3.8 　DELETE 　 　60\n3.3.9 　扩展方法  61\n3.4 　状态码 　 　62\n3.4.1 　100 ～ 199——信息性状态码 　 　62\n3.4.2 　200 ～ 299——成功状态码 　 　63\n3.4.3 　300 ～ 399——重定向状态码 　 　64\n3.4.4 　400 ～ 499——客户端错误状态码 　 　68\n3.4.5 　500 ～ 599——服务器错误状态码 　 　69\n3.5 　首部　　70\n3.5.1 　通用首部  71\n3.5.2 　请求首部  72\n3.5.3 　响应首部  74\n3.5.4 　实体首部  75\n3.6 　更多信息　　77\n第4章 　连接管理 　 　79\n4.1 　TCP 连接 　 　80\n4.1.1 　TCP 的可靠数据管道 　 　80\n4.1.2 　TCP 流是分段的、由IP 分组传送  81\n4.1.3 　保持TCP 连接的正确运行 　 　82\n4.1.4 　用TCP 套接字编程  84\n4.2 　对TCP 性能的考虑  85\n4.2.1 　HTTP 事务的时延 　 　86\n4.2.2 　性能聚焦区域 　 　87\n4.2.3 　TCP 连接的握手时延 　 　87\n4.2.4 　延迟确认  88\n4.2.5 　TCP 慢启动 　 　89\n4.2.6 　Nagle 算法与TCP_NODELAY 　 　89\n4.2.7 　TIME_WAIT 累积与端口耗尽 　 　90\n4.3 　HTTP 连接的处理 　 　91\n4.3.1 　常被误解的Connection 首部  91\n4.3.2 　串行事务处理时延 　 　92\n4.4 　并行连接　　94\n4.4.1 　并行连接可能会提高页面的加载速度 　 　94\n4.4.2 　并行连接不一定更快 　 　95\n4.4.3 　并行连接可能让人“感觉”更快一些 　 　95\n4.5 　持久连接　　96\n4.5.1 　持久以及并行连接 　 　96\n4.5.2 　HTTP/1.0+ keep-alive 连接 　 　97\n4.5.3 　Keep-Alive 操作 　 　98\n4.5.4 　Keep-Alive 选项 　 　98\n4.5.5 　Keep-Alive 连接的限制和规则 　 　99\n4.5.6 　Keep-Alive 和哑代理  100\n4.5.7 　插入Proxy-Connection  102\n4.5.8 　HTTP/1.1 持久连接 　 　104\n4.5.9 　持久连接的限制和规则  104\n4.6 　管道化连接 　 　105\n4.7 　关闭连接的奥秘  106\n4.7.1 “ 任意”解除连接  106\n4.7.2 　Content-Length 及截尾操作 　 　107\n4.7.3 　连接关闭容限、重试以及幂等性  107\n4.7.4 　正常关闭连接  108\n4.8 　更多信息　　110\n4.8.1 　HTTP 连接  110\n4.8.2 　HTTP 性能问题  110\n4.8.3 　TCP/IP　　111\n第二部分 　HTTP 结构\n第5章 　Web 服务器  115\n5.1 　各种形状和尺寸的Web 服务器  116\n5.1.1 　Web 服务器的实现  116\n5.1.2 　通用软件Web 服务器 　 　117\n5.1.3 　Web 服务器设备  117\n5.1.4 　嵌入式Web 服务器 　 　118\n5.2 　最小的Perl Web 服务器  118\n5.3 　实际的Web 服务器会做些什么  120\n5.4 　第一步——接受客户端连接  121\n5.4.1 　处理新连接  121\n5.4.2 　客户端主机名识别  122\n5.4.3 　通过ident 确定客户端用户  122\n5.5 　第二步——接收请求报文  123\n5.5.1 　报文的内部表示法  124\n5.5.2 　连接的输入/ 输出处理结构 　 　125\n5.6 　第三步——处理请求  126\n5.7 　第四步——对资源的映射及访问 　 　126\n5.7.1 　docroot 　 　127\n5.7.2 　目录列表 　 　129\n5.7.3 　动态内容资源的映射  130\n5.7.4 　服务器端包含项  131\n5.7.5 　访问控制 　 　131\n5.8 　第五步——构建响应  131\n5.8.1 　响应实体 　 　131\n5.8.2 　MIME 类型 132\n5.8.3 　重定向 　 　133\n5.9 　第六步——发送响应  134\n5.10 　第七步——记录日志 　 　134\n5.11 　更多信息　　134\n第6章 　代理 　 　135\n6.1 　Web 的中间实体  136\n6.1.1 　私有和共享代理  136\n6.1.2 　代理与网关的对比  137\n6.2 　为什么使用代理  138\n6.3 　代理会去往何处  143\n6.3.1 　代理服务器的部署  144\n6.3.2 　代理的层次结构  144\n6.3.3 　代理是如何获取流量的  147\n6.4 　客户端的代理设置  148\n6.4.1 　客户端的代理配置：手工配置 　 　149\n6.4.2 　客户端代理配置：PAC 文件 　 　149\n6.4.3 　客户端代理配置：WPAD 　 　150\n6.5 　与代理请求有关的一些棘手问题 　 　151\n6.5.1 　代理URI 与服务器URI 的不同 　 　151\n6.5.2 　与虚拟主机一样的问题  152\n6.5.3 　拦截代理会收到部分URI  153\n6.5.4 　代理既可以处理代理请求，也可以处理服务器请求 　 　154\n6.5.5 　转发过程中对URI 的修改  154\n6.5.6 　URI 的客户端自动扩展和主机名解析  155\n6.5.7 　没有代理时URI 的解析 155\n6.5.8 　有显式代理时URI 的解析  156\n6.5.9 　有拦截代理时URI 的解析  157\n6.6 　追踪报文　　158\n6.6.1 　Via 首部 158\n6.6.2 　TRACE 方法 　 　162\n6.7 　代理认证　　164\n6 ｜ 目录\n6.8 　代理的互操作性  165\n6.8.1 　处理代理不支持的首部和方法 　 　166\n6.8.2 　OPTIONS：发现对可选特性的支持  166\n6.8.3 　Allow 首部  167\n6.9 　更多信息　　167\n第7章 　缓存 　 　169\n7.1 　冗余的数据传输  170\n7.2 　带宽瓶颈　　170\n7.3 　瞬间拥塞　　171\n7.4 　距离时延　　172\n7.5 　命中和未命中的  173\n7.5.1 　再验证 　 　173\n7.5.2 　命中率 　 　175\n7.5.3 　字节命中率  176\n7.5.4 　区分命中和未命中的情况 　 　176\n7.6 　缓存的拓扑结构  177\n7.6.1 　私有缓存 　 　177\n7.6.2 　公有代理缓存  177\n7.6.3 　代理缓存的层次结构  179\n7.6.4 　网状缓存、内容路由以及对等缓存 　 　180\n7.7 　缓存的处理步骤  181\n7.7.1 　第一步——接收  181\n7.7.2 　第二步——解析  182\n7.7.3 　第三步——查找  182\n7.7.4 　第四步——新鲜度检测  182\n7.7.5 　第五步——创建响应  182\n7.7.6 　第六步——发送  183\n7.7.7 　第七步——日志  183\n7.7.8 　缓存处理流程图  183\n7.8 　保持副本的新鲜  183\n7.8.1 　文档过期 　 　184\n7.8.2 　过期日期和使用期  185\n7.8.3 　服务器再验证  185\n7.8.4 　用条件方法进行再验证  186\n7.8.5 　If-Modified-Since:Date 再验证 　 　187\n7.8.6 　If-None-Match：实体标签再验证 　 　189\n7.8.7 　强弱验证器  190\n7.8.8 　什么时候应该使用实体标签和最近修改日期 　 　190\n7.9 　控制缓存的能力  191\n7.9.1 　no-Store 与no-Cache 响应首部　　191\n7.9.2 　max-age 响应首部 　 　192\n7.9.3 　Expires 响应首部 　 　192\n7.9.4 　must-revalidate 响应首部  192\n7.9.5 　试探性过期  193\n7.9.6 　客户端的新鲜度限制  194\n7.9.7 　注意事项 　 　194\n7.10 　设置缓存控制 　 　195\n7.10.1 　控制Apache 的HTTP 首部 　 　195\n7.10.2 　通过HTTP-EQUIV 控制HTML 缓存 　 　196\n7.11 　详细算法　　197\n7.11.1 　使用期和新鲜生存期 　 　198\n7.11.2 　使用期的计算 　 　198\n7.11.3 　完整的使用期计算算法 　 　201\n7.11.4 　新鲜生存期计算 　 　202\n7.11.5 　完整的服务器——新鲜度算法 　 　202\n7.12 　缓存和广告 　 　204\n7.12.1 　发布广告者的两难处境 　 　204\n7.12.2 　发布者的响应 　 　204\n7.12.3 　日志迁移 　 　205\n7.12.4 　命中计数和使用限制 　 　205\n7.13 　更多信息　　205\n第8章 　集成点：网关、隧道及中继 　 　207\n8.1 　网关　　208\n8.2 　协议网关　　210\n8.2.1 　HTTP/*：服务器端Web 网关  211\n8.2.2 　HTTP/HTTPS：服务器端安全网关　　212\n8.2.3 　HTTPS/HTTP 客户端安全加速器网关 　 　212\n8.3 　资源网关　　213\n8.3.1 　CGI  215\n8.3.2 　服务器扩展API  215\n8.4 　应用程序接口和Web 服务  216\n8.5 　隧道　　217\n8.5.1 　用CONNECT 建立HTTP 隧道  217\n8.5.2 　数据隧道、定时及连接管理 　 　219\n8.5.3 　SSL 隧道 219\n8.5.4 　SSL 隧道与HTTP/HTTPS 网关的对比  220\n8.5.5 　隧道认证 　 　221\n8.5.6 　隧道的安全性考虑  221\n8.6 　中继　　222\n8.7 　更多信息　　224\n第9章 　Web 机器人  225\n9.1 　爬虫及爬行方式  226\n9.1.1 　从哪儿开始：根集  226\n9.1.2 　链接的提取以及相对链接的标准化 　 　227\n9.1.3 　避免环路的出现  228\n9.1.4 　循环与复制  228\n9.1.5 　面包屑留下的痕迹  229\n9.1.6 　别名与机器人环路  230\n9.1.7 　规范化URL 　 　230\n9.1.8 　文件系统连接环路  231\n9.1.9 　动态虚拟Web 空间 　 　232\n9.1.10 　避免循环和重复 　 　233\n9.2 　机器人的HTTP  236\n9.2.1 　识别请求首部  236\n9.2.2 　虚拟主机 　 　236\n9.2.3 　条件请求 　 　237\n9.2.4 　对响应的处理  238\n9.2.5 　User-Agent 导向  239\n9.3 　行为不当的机器人  239\n9.4 　拒绝机器人访问  240\n9.4.1 　拒绝机器人访问标准  241\n9.4.2 　Web 站点和robots.txt 文件  242\n9.4.3 　robots.txt 文件的格式  243\n9.4.4 　其他有关robots.txt 的知识  246\n9.4.5 　缓存和robots.txt 的过期 　 　246\n9.4.6 　拒绝机器人访问的Perl 代码 　 　246\n9.4.7 　HTML 的robot-control 元标签 　 　249\n9.5 　机器人的规范 　 　251\n9.6 　搜索引擎　　254\n9.6.1 　大格局 　 　255\n9.6.2 　现代搜索引擎结构  255\n9.6.3 　全文索引 　 　255\n9.6.4 　发布查询请求  257\n9.6.5 　对结果进行排序，并提供查询结果 　 　258\n9.6.6 　欺诈　　258\n9.7 　更多信息　　258\n第10章 　HTTP-NG 　 　261\n10.1 　HTTP 发展中存在的问题  262\n10.2 　HTTP-NG 的活动  263\n10.3 　模块化及功能增强  263\n10.4 　分布式对象 　 　264\n10.5 　第一层——报文传输 　 　264\n10.6 　第二层——远程调用 　 　265\n10.7 　第三层——Web 应用 　 　265\n10.8 　WebMUX 　 　265\n10.9 　二进制连接协议 　 　266\n10.10 　当前的状态 　 　267\n10.11 　更多信息 　 　267\n第三部分 　识别、认证与安全\n第11章 　客户端识别与cookie 机制 　 　271\n11.1 　个性化接触 　 　272\n11.2 　HTTP 首部　　273\n11.3 　客户端IP 地址  274\n11.4 　用户登录　　275\n11.5 　胖URL　　277\n11.6 　cookie 　 　278\n11.6.1 　cookie 的类型  278\n11.6.2 　cookie 是如何工作的  279\n11.6.3 　cookie 罐：客户端的状态 　 　280\n11.6.4 　不同站点使用不同的cookie  282\n11.6.5 　cookie 成分  283\n11.6.6 　cookies 版本0（Netscape） 　 　284\n11.6.7 　cookies 版本1（RFC 2965）  285\n11.6.8 　cookie 与会话跟踪  288\n11.6.9 　cookie 与缓存  290\n11.6.10 　cookie、安全性和隐私 　 　291\n11.7 　更多信息　　292\n第12章 　基本认证机制  293\n12.1 　认证 　 　294\n12.1.1 　HTTP 的质询/ 响应认证框架 　 　294\n12.1.2 　认证协议与首部  295\n12.1.3 　安全域  296\n12.2 　基本认证　　297\n12.2.1 　基本认证实例  298\n12.2.2 　Base-64 用户名/ 密码编码 　 　298\n12.2.3 　代理认证  299\n12.3 　基本认证的安全缺陷 　 　300\n12.4 　更多信息　　301\n第13章 　摘要认证 　 　303\n13.1 　摘要认证的改进 　 　304\n13.1.1 　用摘要保护密码  304\n13.1.2 　单向摘要  306\n13.1.3 　用随机数防止重放攻击 　 　307\n13.1.4 　摘要认证的握手机制  307\n13.2 　摘要的计算 　 　308\n13.2.1 　摘要算法的输入数据  308\n13.2.2 　算法H(d) 和KD(s,d)  310\n13.2.3 　与安全性相关的数据（A1）  310\n13.2.4 　与报文有关的数据（A2）  310\n13.2.5 　摘要算法总述 　 　311\n13.2.6 　摘要认证会话  312\n13.2.7 　预授权  312\n13.2.8 　随机数的选择  315\n13.2.9 　对称认证  315\n13.3 　增强保护质量 　 　316\n13.3.1 　报文完整性保护  316\n13.3.2 　摘要认证首部  317\n13.4 　应该考虑的实际问题 　 　317\n13.4.1 　多重质询  318\n13.4.2 　差错处理  318\n13.4.3 　保护空间  318\n13.4.4 　重写URI  319\n13.4.5 　缓存 　 　319\n13.5 　安全性考虑 　 　320\n13.5.1 　首部篡改  320\n13.5.2 　重放攻击  320\n13.5.3 　多重认证机制  320\n13.5.4 　词典攻击  321\n13.5.5 　恶意代理攻击和中间人攻击  321\n13.5.6 　选择明文攻击  321\n13.5.7 　存储密码  322\n13.6 　更多信息　　322\n第14章 　安全HTTP  323\n14.1 　保护HTTP 的安全 　 　324\n14.2 　数字加密　　326\n14.2.1 　密码编制的机制与技巧 　 　326\n14.2.2 　密码 　 　327\n14.2.3 　密码机  328\n14.2.4 　使用了密钥的密码  328\n14.2.5 　数字密码  328\n14.3 　对称密钥加密技术 　 　330\n14.3.1 　密钥长度与枚举攻击  330\n14.3.2 　建立共享密钥  332\n14.4 　公开密钥加密技术 　 　332\n14.4.1 　RSA 　 　333\n14.4.2 　混合加密系统和会话密钥 　 　334\n14.5 　数字签名　　334\n14.6 　数字证书　　336\n14.6.1 　证书的主要内容  336\n14.6.2 　X.509 v3 证书  337\n14.6.3 　用证书对服务器进行认证 　 　338\n14.7 　HTTPS——细节介绍 　 　339\n14.7.1 　HTTPS 概述  339\n14.7.2 　HTTPS 方案  340\n14.7.3 　建立安全传输  341\n14.7.4 　SSL 握手  341\n14.7.5 　服务器证书  343\n14.7.6 　站点证书的有效性  344\n14.7.7 　虚拟主机与证书  345\n14.8 　HTTPS 客户端实例 　 　345\n14.8.1 　OpenSSL  346\n14.8.2 　简单的HTTPS 客户端 　 　347\n14.8.3 　执行OpenSSL 客户端 　 　350\n14.9 　通过代理以隧道形式传输安全流量 　 　351\n14.10 　更多信息 　 　353\n14.10.1 　HTTP 安全性 　 　353\n14.10.2 　SSL 与TLS  353\n14.10.3 　公开密钥基础设施  354\n14.10.4 　数字密码  354\n第四部分 　实体、编码和国际化\n第15章 　实体和编码  357\n15.1 　报文是箱子，实体是货物 　 　359\n15.2 　Content-Length: 实体的大小  361\n15.2.1 　检测截尾  361\n15.2.2 　错误的Content-Length 　 　362\n15.2.3 　Content-Length 与持久连接  362\n15.2.4 　内容编码  362\n15.2.5 　确定实体主体长度的规则 　 　362\n15.3 　实体摘要　　364\n15.4 　媒体类型和字符集 　 　364\n15.4.1 　文本的字符编码  365\n15.4.2 　多部分媒体类型  365\n15.4.3 　多部分表格提交  366\n15.4.4 　多部分范围响应  367\n15.5 　内容编码　　368\n15.5.1 　内容编码过程  368\n15.5.2 　内容编码类型  369\n15.5.3 　Accept-Encoding 首部 　 　369\n15.6 　传输编码和分块编码 　 　371\n15.6.1 　可靠传输  371\n15.6.2 　Transfer-Encoding 首部  372\n15.6.3 　分块编码  373\n15.6.4 　内容编码与传输编码的结合  375\n15.6.5 　传输编码的规则  375\n15.7 　随时间变化的实例 　 　375\n15.8 　验证码和新鲜度 　 　376\n15.8.1 　新鲜度  377\n15.8.2 　有条件的请求与验证码 　 　378\n15.9 　范围请求　　380\n15.10 　差异编码 　 　382\n15.11 　更多信息 　 　385\n第16章 　国际化 　 　387\n16.1 　HTTP 对国际性内容的支持  388\n16.2 　字符集与HTTP 　 　389\n16.2.1 　字符集是把字符转换为二进制码的编码　　389\n16.2.2 　字符集和编码如何工作 　 　390\n16.2.3 　字符集不对，字符就不对 　 　391\n16.2.4 　标准化的MIME charset 值 　 　391\n16.2.5 　Content-Type 首部和Charset 首部以及META 标志 　 　393\n16.2.6 　Accept-Charset 首部 　 　393\n16.3 　多语言字符编码入门 　 　394\n16.3.1 　字符集术语  394\n16.3.2 　字符集的命名很糟糕  395\n16.3.3 　字符 　 　396\n16.3.4 　字形、连笔以及表示形式 　 　396\n16.3.5 　编码后的字符集  397\n16.3.6 　字符编码方案  399\n16.4 　语言标记与HTTP  402\n16.4.1 　Content-Language 首部 　 　402\n16.4.2 　Accept-Language 首部 　 　403\n16.4.3 　语言标记的类型  404\n16.4.4 　子标记  404\n16.4.5 　大小写  405\n16.4.6 　IANA 语言标记注册 　 　405\n16.4.7 　第一个子标记——名字空间  405\n16.4.8 　第二个子标记——名字空间  406\n16.4.9 　其余子标记——名字空间 　 　407\n16.4.10 　配置和语言有关的首选项 　 　407\n16.4.11 　语言标记参考表 　 　407\n16.5 　国际化的URI 　 　408\n16.5.1 　全球性的可转抄能力与有意义的字符的较量 　 　408\n16.5.2 　URI 字符集合  408\n16.5.3 　转义和反转义  409\n16.5.4 　转义国际化字符  409\n16.5.5 　URI 中的模态切换  410\n16.6 　其他需要考虑的地方 　 　410\n16.6.1 　首部和不合规范的数据 　 　410\n16.6.2 　日期 　 　411\n16.6.3 　域名 　 　411\n16.7 　更多信息　　411\n16.7.1 　附录 　 　411\n16.7.2 　互联网的国际化  411\n16.7.3 　国际标准  412\n第17章 　内容协商与转码  413\n17.1 　内容协商技术 　 　414\n17.2 　客户端驱动的协商 　 　415\n17.3 　服务器驱动的协商 　 　415\n17.3.1 　内容协商首部集  416\n17.3.2 　内容协商首部中的质量值 　 　417\n17.3.3 　随其他首部集而变化  417\n17.3.4 　Apache 中的内容协商  417\n17.3.5 　服务器端扩展  418\n17.4 　透明协商　　419\n17.4.1 　进行缓存与备用候选  419\n17.4.2 　Vary 首部 　 　420\n17.5 　转码 　 　422\n17.5.1 　格式转换  422\n17.5.2 　信息综合  423\n17.5.3 　内容注入  423\n17.5.4 　转码与静态预生成的对比 　 　423\n17.6 　下一步计划 　 　424\n17.7 　更多信息　　424\n第五部分 　内容发布与分发\n第18章 　Web 主机托管 　 　429\n18.1 　主机托管服务 　 　430\n18.2 　虚拟主机托管 　 　431\n18.2.1 　虚拟服务器请求缺乏主机信息 　 　432\n18.2.2 　设法让虚拟主机托管正常工作 　 　433\n18.2.3 　HTTP/1.1 的Host 首部 　 　437\n18.3 　使网站更可靠 　 　438\n18.3.1 　镜像的服务器集群  438\n18.3.2 　内容分发网络  440\n18.3.3 　CDN 中的反向代理缓存  440\n18.3.4 　CDN 中的代理缓存 　 　440\n18.4 　让网站更快 　 　441\n18.5 　更多信息　　441\n第19章 　发布系统 　 　443\n19.1 　FrontPage 为支持发布而做的服务器扩展　　444\n19.1.1 　FrontPage 服务器扩展 　 　444\n19.1.2 　FrontPage 术语表 　 　445\n19.1.3 　FrontPage 的RPC 协议 　 　445\n19.1.4 　FrontPage 的安全模型 　 　448\n19.2 　WebDAV 与协作写作 　 　449\n19.2.1 　WebDAV 的方法 449\n19.2.2 　WebDAV 与XML 　 　450\n19.2.3 　WebDAV 首部集 451\n19.2.4 　WebDAV 的锁定与防止覆写 452\n19.2.5 　LOCK 方法  453\n19.2.6 　UNLOCK 方法 　 　456\n19.2.7 　属性和元数据  456\n19.2.8 　PROPFIND 方法  457\n19.2.9 　PROPPATCH 方法 　 　459\n19.2.10 　集合与名字空间管理 　 　460\n19.2.11 　MKCOL 方法  460\n19.2.12 　DELETE 方法 　 　461\n19.2.13 　COPY 与MOVE 方法 　 　462\n19.2.14 　增强的HTTP/1.1 方法 　 　465\n19.2.15 　WebDAV 中的版本管理 466\n19.2.16 　WebDAV 的未来发展  466\n19.3 　更多信息　　467\n第20章 　重定向与负载均衡 　 　469\n20.1 　为什么要重定向 　 　470\n20.2 　重定向到何地 　 　471\n20.3 　重定向协议概览 　 　471\n20.4 　通用的重定向方法 　 　474\n20.4.1 　HTTP 重定向 　 　474\n20.4.2 　DNS 重定向  475\n20.4.3 　任播寻址  480\n20.4.4 　IP MAC 转发 　 　481\n20.4.5 　IP 地址转发  482\n20.4.6 　网元控制协议  484\n20.5 　代理的重定向方法 　 　485\n20.5.1 　显式浏览器配置  485\n20.5.2 　代理自动配置  485\n20.5.3 　Web 代理自动发现协议 　 　487\n20.6 　缓存重定向方法 　 　492\n20.7 　因特网缓存协议 　 　496\n20.8 　缓存阵列路由协议 　 　497\n20.9 　超文本缓存协议 　 　500\n20.9.1 　HTCP 认证 　 　502\n20.9.2 　设置缓存策略  503\n20.10 　更多信息 　 　504\n第21章 　日志记录与使用情况跟踪 　 　505\n21.1 　记录内容　　506\n21.2 　日志格式　　507\n21.2.1 　常见日志格式  507\n21.2.2 　组合日志格式  508\n21.2.3 　网景扩展日志格式  509\n21.2.4 　网景扩展2 日志格式  510\n21.2.5 　Squid 代理日志格式 　 　512\n21.3 　命中率测量 　 　515\n21.3.1 　概述 　 　515\n21.3.2 　Meter 首部  516\n21.4 　关于隐私的考虑 　 　517\n21.5 　更多信息　　518\n第六部分 　附 　录\n附录A 　URI 方案　　521\n附录B 　HTTP 状态码 　 　529\n附录C 　HTTP 首部参考 　 　533\n附录D 　MIME 类型 　 　557\n附录E 　Base-64 编码 　 　603\n附录F 　摘要认证 　 　607\n附录G 　语言标记　　615\n附录H 　MIME 字符集注册表  641\n索引　　661",
    "pages": "720",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s11329547.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s11329547.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s11329547.jpg"
    },
    "alt": "https://book.douban.com/subject/10746113/",
    "id": "10746113",
    "publisher": "人民邮电出版社",
    "isbn10": "7115281483",
    "isbn13": "9787115281487",
    "title": "HTTP权威指南",
    "url": "https://api.douban.com/v2/book/10746113",
    "alt_title": "HTTP: The Definitive Guide",
    "author_intro": "David Gourley是Endeca的首席技术官（Chief Technology Officer），负责Endeca产品的研究及开发。Endeca开发的因特网及内部网络信息访问解决方案为企业级数据的导航及研究提供了一些新的方式。在到Endeca工作之前，David是Inktomi基础工程组的一员，他在那儿帮助开发了Inktomi的因特网搜索数据库，是Inktomi的Web缓存产品的主要开发者。\nDavid在加州大学伯克利分校获得了计算机科学的学士学位，还拥有Web技术方面的几项专利。\nBrian Totty最近出任了Inktomi公司（这是1996年他参与建立的一家公司）研发部副总裁，在公司中他负责Web缓存、流媒体及因特网搜索技术的研发工作。他曾是Silicon Graphics公司的一名科学家，他在那儿为高性能网络和超级计算机系统设计软件并对其进行优化。在那之前，他是苹果计算机公司高级技术组的一名工程师。\nBrian在伊利诺伊大学Urbana-Champaign分校获得了计算机科学的博士学位，在MIT获得了计算机科学及电子工程的学士学位，在那里他获得了计算机系统研究的Organick奖。他还为加州大学扩展系统开发并讲授了一些屡获殊荣的因特网技术方面的课程。\nMarjorie Sayer在Inktomi公司负责编写Web缓存方面的软件。在加州大学伯克利分校获得了数学硕士和博士学位之后，一直致力于数学课程的改革。从1990年开始致力于能量资源管理、并行系统软件、电话和网络方面的写作。\nSailu Reddy目前在Inktomi公司负责嵌入式的性能增强型HTTP 代理的开发。Sailu从事复杂软件系统的开发已经有12年了，从1995年开始深入Web架构的研发工作。他是Netscape第一台Web服务器、Web 代理产品，以及后面几代产品的核心工程师。他具备HTTP应用程序、数据压缩技术、数据库引擎以及合作管理等方面的技术经验。Sailu在亚里桑那大学获得了信息系统的硕士学位并握有Web技术方面的多项专利。\nAnshu Aggarwal是Inktomi公司的工程总监。他领导着Inktomi公司Web缓存产品的协议处理工程组，从1997年就开始参与Inktomi的Web技术设计工作。Anshu在科罗拉多大学Boulder分校获得了计算机科学的硕士和博士学位，从事分布式多处理器的内存一致性技术研究。他还拥有电子工程的硕士和学士学位。Anshu撰写了多篇技术论文，还拥有两项专利。",
    "summary": "超文本转移协议（Hypertext Transfer Protocol，HTTP）是在万维网上进行通信时所使用的协议方案。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。\nHTTP起初是一个简单的协议，因此你可能会认为关于这个协议没有太多好 说的。但现在，你手上拿着的是却一本两磅重 的书。如果你对我们怎么会写出一本650页 的关于HTTP的书感到奇怪的话，可以去看一下目录。本书不仅仅是一本HTTP首部的参考手册；它是一本名副其实的web结构圣经。\n本书中，我们尝试着将HTTP中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对HTTP各方面的特性进行了介绍。纵观全书，我们对HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。而且，为了节省大家寻找参考文献的时间，我们还对很多HTTP应用程序正常工作所必须的、重要的非HTTP技术进行了介绍。在组织得便于使用的附录中，可以找到按照字母排序的首部参考（这些首部构成了最常见的HTTP文本的基础）。我们希望这种概念性的设计有助于读者对HTTP的使用。\n本书是为所有希望理解HTTP以及Web底层结构的人编写的。软硬件工程师也可以将本书作为HTTP及相关web技术的条理清楚的参考书使用。系统架构师和网络管理员可以通过本书更好地了解如何设计、实现并管理复杂的网络架构。性能工程师和分析人员可以从高速缓存和性能优化的相关章节中获益。市场营销和咨询专家可以通过概念的介绍更好地理解web技术的前景。\n本书对一些常见的误解进行了说明，推荐了“各种使用诀窍”，提供了便捷的参考资料，并且对枯燥且令人费解的标准规范进行了可读性很强的介绍。在这本书里，我们对Web正常工作所必须且互相关联的技术进行了详细的介绍。\n本书是很多对因特网技术充满热情的人经过大量工作写成的。希望对你有所帮助。",
    "series": { "id": "28503", "title": "图灵程序设计丛书·Web开发系列" },
    "price": "109.00元"
  },
  "9787115358851": {
    "rating": { "max": 10, "numRaters": 99, "average": "8.4", "min": 0 },
    "subtitle": "",
    "author": ["[韩] 尹圣雨"],
    "pubdate": "2014-7",
    "tags": [
      { "count": 111, "name": "网络编程", "title": "网络编程" },
      { "count": 99, "name": "TCP/IP", "title": "TCP/IP" },
      { "count": 37, "name": "计算机", "title": "计算机" },
      { "count": 31, "name": "编程", "title": "编程" },
      { "count": 28, "name": "计算机网络", "title": "计算机网络" },
      { "count": 22, "name": "网络", "title": "网络" },
      { "count": 12, "name": "后台", "title": "后台" },
      { "count": 12, "name": "web", "title": "web" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27309026.jpg",
    "binding": "平装",
    "translator": ["金国哲"],
    "catalog": "第一部分　开始网络编程\n第1章　理解网络编程和套接字　　2\n1.1 　理解网络编程和套接字　　2\n1.2 　基于Linux的文件操作　　9\n1.3 　基于Windows平台的实现　　15\n1.4 　基于Windows的套接字相关函数及示例　　18\n1.5 　习题　　24\n第2章　套接字类型与协议设置　　26\n2.1 　套接字协议及其数据传输特性　　26\n2.2 　Windows平台下的实现及验证　　32\n2.3 　习题　　35\n第3章　地址族与数据序列　　36\n3.1 　分配给套接字的IP地址与端口号　　36\n3.2 　地址信息的表示　　39\n3.3 　网络字节序与地址变换　　42\n3.4 　网络地址的初始化与分配　　45\n3.5 　基于Windows的实现　　52\n3.6 　习题　　57\n第4章　基于TCP的服务器端/客户端（1）　　59\n4.1 　理解TCP和UDP　　59\n4.2 　实现基于TCP的服务器端/客户端　　64\n4.3 　实现迭代服务器端/客户端　　71\n4.4 　基于Windows的实现　　77\n4.5 　习题　　81\n第5章　基于TCP的服务器端/客户端（2）　　82\n5.1 　回声客户端的完美实现　　82\n5.2 　TCP原理　　91\n5.3 　基于Windows的实现　　96\n5.4 　习题　　99\n第6章　基于UDP的服务器端/客户端　　101\n6.1 　理解UDP　　101\n6.2 　实现基于UDP的服务器端/客户端　　103\n6.3 　UDP的数据传输特性和调用connect函数　　109\n6.4 　基于Windows的实现　　114\n6.5 　习题　　117\n第7章　优雅地断开套接字连接　　118\n7.1 　基于TCP的半关闭　　118\n7.2 　基于Windows的实现　　124\n7.3 　习题　　127\n第8章　域名及网络地址　　128\n8.1 　域名系统　　128\n8.2 　IP地址和域名之间的转换　　130\n8.3 　基于Windows的实现　　136\n8.4 　习题　　138\n第9章　套接字的多种可选项　　140\n9.1 　套接字可选项和I/O缓冲大小　　140\n9.2 　SO_REUSEADDR　　145\n9.3 　TCP_NODELAY　　150\n9.4 　基于Windows的实现　　152\n9.5 　习题　　154\n第10章　多进程服务器端　　155\n10.1 　进程概念及应用　　155\n10.2 　进程和僵尸进程　　159\n10.3 　信号处理　　165\n10.4 　基于多任务的并发服务器　　173\n10.5 　分割TCP的I/O程序　　178\n10.6 　习题　　182\n第11章　进程间通信　　183\n11.1 　进程间通信的基本概念　　183\n11.2 　运用进程间通信　　188\n11.3 　习题　　193\n第12章　I/O复用　　194\n12.1 　基于I/O复用的服务器端　　194\n12.2 　理解select函数并实现服务器端　　197\n12.3 　基于Windows的实现　　206\n12.4 　习题　　209\n第13章　多种I/O函数　　211\n13.1 　send & recv函数　　211\n13.2 　readv & writev函数　　221\n13.3 　基于Windows的实现　　225\n13.4 　习题　　229\n第14章　多播与广播　　230\n14.1 　多播　　230\n14.2 　广播　　236\n14.3 　基于Windows的实现　　240\n14.4 　习题　　242\n第二部分　基于Linux的编程\n第15章　套接字和标准I/O　　246\n15.1 　标准I/O函数的优点　　246\n15.2 　使用标准I/O函数　　249\n15.3 　基于套接字的标准I/O函数使用　　252\n15.4 　习题　　254\n第16章　关于I/O流分离的其他内容　　255\n16.1 　分离I/O流　　255\n16.2 　文件描述符的复制和半关闭　　259\n16.3 　习题　　264\n第17章　优于select的epoll　　265\n17.1 　epoll理解及应用　　265\n17.2 　条件触发和边缘触发　　273\n17.3 　习题　　283\n第18章　多线程服务器端的实现　　284\n18.1 　理解线程的概念　　284\n18.2 　线程创建及运行　　287\n18.3 　线程存在的问题和临界区　　296\n18.4 　线程同步　　299\n18.5 　线程的销毁和多线程并发服务器端的实现　　306\n18.6 　习题　　312\n第三部分　基于Windows的编程\n第19章　Windows平台下线程的使用　　316\n19.1 　内核对象　　316\n19.2 　基于Windows的线程创建　　317\n19.3 　内核对象的2种状态　　322\n19.4 　习题　　325\n第20章　Windows中的线程同步　　327\n20.1 　同步方法的分类及CRITICAL_SECTION同步　　327\n20.2 　内核模式的同步方法　　331\n20.3 　Windows平台下实现多线程服务器端　　339\n20.4 　习题　　343\n第21章　异步通知I/O模型　　344\n21.1 　理解异步通知I/O模型　　344\n21.2 　理解和实现异步通知I/O模型　　346\n21.3 　习题　　356\n第22章　重叠I/O模型　　357\n22.1 　理解重叠I/O模型　　357\n22.2 　重叠I/O的I/O完成确认　　362\n22.3 　习题　　370\n第23章　IOCP　　371\n23.1 　通过重叠I/O理解IOCP　　371\n23.2 　分阶段实现IOCP程序　　379\n23.3 　习题　　387\n第四部分　结束网络编程\n第24章　制作HTTP服务器端　　390\n24.1 　HTTP概要　　390\n24.2 　实现简单的Web服务器端　　394\n24.3 　习题　　401\n第25章　进阶内容　　403\n25.1 　网络编程学习的其他内容　　403\n25.2 　网络编程相关书籍介绍　　404\n索引　　406",
    "pages": "410",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27309026.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27309026.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27309026.jpg"
    },
    "alt": "https://book.douban.com/subject/25911735/",
    "id": "25911735",
    "publisher": "人民邮电出版社",
    "isbn10": "7115358850",
    "isbn13": "9787115358851",
    "title": "TCP/IP网络编程",
    "url": "https://api.douban.com/v2/book/25911735",
    "alt_title": "",
    "author_intro": "作者简介：\n尹圣雨\n曾为风投公司开发人员，因出版IT类书籍并开展相关讲座而闻名。2004年至今一直参与OpenGL ES图形库的建设和3D加速芯片的开发，以及Khronos Group（移动国际标准化财团）的标准制定相关业务，还参与手机DMB芯片的开发。现任（株）Axissoft公司CTO，致力于构建基于Web的解决方案。\nripeness21@gmail.com\n译者简介：\n金国哲\n毕业于重庆大学计算机学院，2009年至今在延边大学计算机系任教。\n主讲课程：Java程序设计、Android应用开发、Web程序设计等。\n主要研究方向：跨语言检索、自然语言处理等。\n曾主持并参与某部队入侵检测系统、论文自动采集及管理系统等多个软件开发项目。",
    "summary": "第一部分主要介绍网络编程基础知识。此部分主要论述Windows和Linux平台网络编程必备基础知识，未过多涉及不同操作系统特性。\n第二部分和第三部分与操作系统有关。第二部分主要是Linux相关内容，而第三部分主要是Windows相关内容。从事Windows编程的朋友浏览第二部分内容后，同样可以提高技艺。\n第四部分对全书内容进行总结，包含了作者在自身经验基础上总结的学习建议，还介绍了网络编程经典书籍。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "79.00元"
  },
  "9787115351531": {
    "rating": { "max": 10, "numRaters": 1810, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["【日】上野宣"],
    "pubdate": "2014-4-15",
    "tags": [
      { "count": 1299, "name": "HTTP", "title": "HTTP" },
      { "count": 612, "name": "网络", "title": "网络" },
      { "count": 564, "name": "计算机", "title": "计算机" },
      { "count": 379, "name": "协议", "title": "协议" },
      { "count": 335, "name": "互联网", "title": "互联网" },
      { "count": 230, "name": "Web", "title": "Web" },
      { "count": 213, "name": "web", "title": "web" },
      { "count": 190, "name": "网络编程", "title": "网络编程" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27283822.jpg",
    "binding": "平装",
    "translator": ["于均良"],
    "catalog": "目录\n第1章　了解Web及网络基础　　001\n1.1　　使用HTTP协议访问Web　　002\n1.2　　HTTP的诞生003\n1.2.1　为知识共享而规划Web　　　　003\n1.2.2　Web成长时代　　　　004\n1.2.3　驻足不前的HTTP　　　　005\n1.3　　网络基础TCP/IP　　006\n1.3.1　TCP/IP协议族　　　　006\n1.3.2　TCP/IP的分层管理　　　　007\n1.3.3　TCP/IP通信传输流　　　　009\n1.4　　与HTTP关系密切的协议:IP、TCP和DNS　　010\n1.4.1　负责传输的IP协议　　　　011\n1.4.2　确保可靠性的TCP协议　　　　012\n1.5　　负责域名解析的DNS服务　　013\n1.6　　各种协议与HTTP协议的关系　　014\n1.7　　URI和URL　　016\n1.7.1　统一资源标识符　　016\n1.7.2　URI格式　　017\n第2章　简单的HTTP协议　　021\n2.1　　HTTP协议用于客户端和服务器端之间的通信　　022\n2.2　　通过请求和响应的交换达成通信　　022\n2.3　　HTTP是不保存状态的协议　　025\n2.4　　请求URI定位资源　　026\n2.5　　告知服务器意图的HTTP　　方法027\n2.6　　使用方法下达命令　　033\n2.7　　持久连接节省通信量　　034\n2.7.1　持久连接　　036\n2.7.2　管线化　　037\n2.8　　使用Cookie的状态管理　　037\n第3章HTTP报文内的HTTP信息　　041\n3.1HTTP报文　　042\n3.2　　请求报文及响应报文的结构　　042\n3.3　　编码提升传输速率　　044\n3.3.1　报文主体和实体主体的差异　　044\n3.3.2　压缩传输的内容编码　　044\n3.3.3　分割发送的分块传输编码　　045\n3.4　　发送多种数据的多部分对象集合　　046\n3.5　　获取部分内容的范围请求048\n3.6　　内容协商返回最合适的内容050\n第4章　返回结果的HTTP状态码　　053\n4.1　　状态码告知从服务器端返回的请求结果054\n4.2　　2XX成功　　055\n4.2.1　200　OK　　　　055\n4.2.2　204　No　Content　　　　056\n4.2.3　206　Partial　Content　　　　056\n4.3　　3XX　重定向　056\n4.3.1　301　Moved　Permanently　　057\n4.3.2　302　Found　057\n4.3.3　303　See　Other　　　　058\n4.3.4　304　Not　Modified　　059\n4.3.5　307　Temporary　Redirect　　059\n4.4　　4XX　客户端错误　　060\n4.4.1　400　Bad　Request　　060\n4.4.2　401　Unauthorized　　060\n4.4.3　403　Forbidden　　061\n4.4.4　404　Not　Found　　061\n4.5　　5XX　服务器错误　　062\n4.5.1　500　Internal　Server　Error　　062\n4.5.2　503　Service　Unavailable　　062\n第5章　与HTTP协作的Web服务器　　065\n5.1　　用单台虚拟主机实现多个域名　　066\n5.2　　通信数据转发程序：代理、网关、隧道　　067\n5.2.1　代理　　068\n5.2.2　网关　　070\n5.2.3　隧道　　070\n5.3　　保存资源的缓存　　071\n5.3.1　缓存的有效期限　　072\n5.3.2　客户端的缓存　　072\n第6章　HTTP　首部　　075\n6.1　　HTTP　报文首部　　076\n6.2　　HTTP　首部字段　　078\n6.2.1　HTTP首部字段传递重要信息　　078\n6.2.2　HTTP首部字段结构　　078\n6.2.3　4种HTTP首部字段类型　　079\n6.2.4　HTTP/1.1首部字段一览　　080\n6.2.5　非HTTP/1.1首部字段　　082\n6.2.6　　　End-to-end首部和Hop-by-hop首部　　083\n6.3　　HTTP/1.1　　通用首部字段　　083\n6.3.1　Cache-Control　　084\n6.3.2　Connection　　091\n6.3.3　Date　　093\n6.3.4　Pragma　　094\n6.3.5　Trailer　　095\n6.3.6　Transfer-Encoding　　096\n6.3.7　Upgrade　　097\n6.3.8　Via　　098\n6.3.9　Warning　　099\n6.4　　请求首部字段　　100\n6.4.1　Accept　　101\n6.4.2　Accept-Charset　　102\n6.4.3　Accept-Encoding　　103\n6.4.4　Accept-Language　　104\n6.4.5　Authorization　　105\n6.4.6　Expect　　106\n6.4.7　From　　107\n6.4.8　Host　　107\n6.4.9　If-Match　　108\n6.4.10　If-Modified-Since　　110\n6.4.11　If-None-Match　　111\n6.4.12　If-Range　　112\n6.4.13　If-Unmodified-Since　　113\n6.4.14　Max-Forwards　　114\n6.4.15　Proxy-Authorization　　115\n6.4.16　Range　　116\n6.4.17　Referer　　116\n6.4.18　TE　　117\n6.4.19　User-Agent　　118\n6.5　　响应首部字段119\n6.5.1　Accept-Ranges　　119\n6.5.2　Age　　120\n6.5.3　ETag　　　　120\n6.5.4　Location　　122\n6.5.5　Proxy-Authenticate　　123\n6.5.6　Retry-After　　123\n6.5.7　Server　　124\n6.5.8　Vary　　125\n6.5.9　WWW-Authenticate　　125\n6.6　　实体首部字段126\n6.6.1　Allow　　126\n6.6.2　Content-Encoding　　127\n6.6.3　Content-Language　　128\n6.6.4　Content-Length　　128\n6.6.5　Content-Location　　129\n6.6.6　Content-MD5　　129\n6.6.7　Content-Range　　130\n6.6.8　Content-Type　　131\n6.6.9　Expires　　131\n6.6.10　　Last-Modified　　132\n6.7　　为Cookie服务的首部字段　　132\n6.7.1　Set-Cookie　　134\n6.7.2　Cookie　　136\n6.8　　其他首部字段137\n6.8.1　X-Frame-Options　　137\n6.8.2　X-XSS-Protection　　138\n6.8.3　DNT　　138\n6.8.4　P3P　　139\n第7章　确保Web安全的HTTPS　　141\n7.1　　HTTP的缺点　　142\n7.1.1　通信使用明文可能会被窃听　　142\n7.1.2　不验证通信方的身份就可能遭遇伪装　　146\n7.1.3　无法证明报文完整性，可能已遭篡改　　148\n7.2　　HTTP+加密+认证+完整性保护=HTTPS　　150\n7.2.1　HTTP加上加密处理和认证以及完整性保护后即是HTTPS　　150\n7.2.2　HTTPS是身披SSL外壳的HTTP　　151\n7.2.3　相互交换密钥的公开密钥加密技术　　152\n7.2.4　证明公开密钥正确性的证书　　155\n7.2.5　HTTPS的安全通信机制　　161\n第8章　确认访问用户身份的认证　　167\n8.1　　何为认证　　168\n8.2　　BASIC　认证　　169\n8.3　　DIGEST　认证171\n8.4　　SSL客户端认证173\n8.4.1　SSL客户端认证的认证步骤　　174\n8.4.2　SSL客户端认证采用双因素认证　　175\n8.4.3　SSL客户端认证必要的费用　　175\n8.5　　基于表单认证　　175\n8.5.1　认证多半为基于表单认证　　176\n8.5.2　Session管理及Cookie应用　　177\n第9章　基于HTTP的功能追加协议　　179\n9.1　　基于HTTP的协议180\n9.2　　消除HTTP瓶颈的SPDY　　180\n9.2.1　HTTP的瓶颈　　180\n9.2.2　SPDY的设计与功能　　184\n9.2.3　SPDY消除Web瓶颈了吗　　185\n9.3　　使用浏览器进行全双工通信的WebSocket　　186\n9.3.1　WebSocket的设计与功能　　186\n9.3.2　WebSocket协议　　186\n9.4　　期盼已久的HTTP/2.0　　189\n9.5　　Web　　服务器管理文件的WebDAV　　190\n9.5.1　扩展HTTP/1.1的WebDAV　　191\n9.5.2　WebDAV内新增的方法及状态码　　192\n第10章　构建Web内容的技术　　195\n10.1　　HTML　　196\n10.1.1　Web页面几乎全由HTML构建　　196\n10.1.2　HTML的版本　　197\n10.1.3　设计应用CSS　　198\n10.2　　动态HTML　　198\n10.2.1　让Web页面动起来的动态HTML　　198\n10.2.2　更易控制HTML　　的DOM　　198\n10.3　　Web应用　　200\n10.3.1　　　通过Web提供功能的Web应用　　200\n10.3.2　与Web服务器及程序协作的CGI　　200\n10.3.3　因Java　　而普及的Servlet　　201\n10.4　　数据发布的格式及语言　　203\n10.4.1　可扩展标记语言　　203\n10.4.2　发布更新信息的RSS/Atom　　204\n10.4.3　JavaScript衍生的轻量级易用JSON　　206\n第11章　Web的攻击技术　　207\n11.1　　针对Web的攻击技术　　208\n11.1.1　HTTP不具备必要的安全功能　　208\n11.1.2　在客户端即可篡改请求　　209\n11.1.3　针对Web应用的攻击模式　　210\n11.2　　因输出值转义不完全引发的安全漏洞　　212\n11.2.1　跨站脚本攻击　　213\n11.2.2　SQL注入攻击　　218\n11.2.3　OS命令注入攻击　　223\n11.2.4　HTTP首部注入攻击　　225\n11.2.5　邮件首部注入攻击　　228\n11.2.6　目录遍历攻击　　229\n11.2.7　远程文件包含漏洞　　230\n11.3　　因设置或设计上的缺陷引发的安全漏洞　　232\n11.3.1　强制浏览　　232\n11.3.2　不正确的错误消息处理　　234\n11.3.3　开放重定向　　237\n11.4　　因会话管理疏忽引发的安全漏洞　　237\n11.4.1　会话劫持　　238\n11.4.2　会话固定攻击　　239\n11.4.3　跨站点请求伪造　　241\n11.5　　其他安全漏洞　　242\n11.5.1　密码破解　　242\n11.5.2　点击劫持　　247\n11.5.3　DoS攻击　　249\n11.5.4　后门程序　　250",
    "ebook_url": "https://read.douban.com/ebook/12054542/",
    "pages": "308",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27283822.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27283822.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27283822.jpg"
    },
    "alt": "https://book.douban.com/subject/25863515/",
    "id": "25863515",
    "publisher": "人民邮电出版社",
    "isbn10": "7115351538",
    "isbn13": "9787115351531",
    "title": "图解HTTP",
    "url": "https://api.douban.com/v2/book/25863515",
    "alt_title": "",
    "author_intro": "作者简介\n上野 宣\nOWASP 日本分会会长，TRICORDER株式会社董事长。\n主要从事安全咨询、风险评估、信息安全教育等工作。著有《今晚我们一起学习邮件协议》（今夜わかるメールプロトコル）、《今晚我们一起学习TCP/IP》（今夜わかるTCP/IP）、《今晚我们一起学习HTTP》（今夜わかるHTTP）。担任The Tangled Web:A Guide to Securing Modern Web Application日文版的审校工作。\n译者简介\n于均良\n上海交通大学硕士，高级软件工程师，马拉松跑者，四点网创始人。",
    "summary": "本书对互联网基盘——HTTP协议进行了全面系统的介绍。作者由HTTP协议的发展历史娓娓道来，严谨细致地剖析了HTTP协议的结构，列举诸多常见通信场景及实战案例，最后延伸到Web安全、最新技术动向等方面。本书的特色为在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解HTTP通信过程中客户端与服务器之间的交互情况。读者可通过本书快速了解并掌握HTTP协议的基础，前端工程师分析抓包数据，后端工程师实现REST API、实现自己的HTTP服务器等过程中所需的HTTP相关知识点本书均有介绍。\n本书适合Web开发工程师，以及对HTTP协议感兴趣的各层次读者。",
    "ebook_price": "19.99",
    "series": { "id": "34135", "title": "图解入门系列" },
    "price": "49.00元"
  },
  "9787115318978": {
    "rating": { "max": 10, "numRaters": 716, "average": "7.8", "min": 0 },
    "subtitle": "",
    "author": ["[日]竹下隆史", "[日]村山公保", "[日]荒井透", "[日]苅田幸雄"],
    "pubdate": "2013-7-1",
    "tags": [
      { "count": 625, "name": "TCP/IP", "title": "TCP/IP" },
      { "count": 368, "name": "网络", "title": "网络" },
      { "count": 326, "name": "计算机网络", "title": "计算机网络" },
      { "count": 220, "name": "计算机", "title": "计算机" },
      { "count": 141, "name": "网络编程", "title": "网络编程" },
      { "count": 94, "name": "计算机科学", "title": "计算机科学" },
      { "count": 72, "name": "编程", "title": "编程" },
      { "count": 64, "name": "图灵程序设计丛书", "title": "图灵程序设计丛书" }
    ],
    "origin_title": "マスタリングTCP/IP 入門編 第5版",
    "image": "https://img1.doubanio.com/view/subject/m/public/s26676928.jpg",
    "binding": "平装",
    "translator": ["乌尼日其其格"],
    "catalog": "第1章 网络基础知识\n1.1 　计算机网络出现的背景\n1.1.1 　计算机的普及与多样化\n1.1.2 　从独立模式到网络互连模式\n1.1.3 　从计算机通信到信息通信\n1.1.4 　计算机网络的作用\n1.2　 计算机与网络发展的7个阶段\n1.2.1 　批处理\n1.2.2 　分时系统\n1.2.3 　计算机之间的通信\n1.2.4 　计算机网络的产生\n1.2.5 　互联网的普及\n1.2.6 　以互联网技术为中心的时代\n1.2.7 　从“单纯建立连接”到“安全建立连接”\n1.2.8 　手握金刚钻的tcp/ip\n1.3 　协议\n1.3.1　 随处可见的协议\n1.3.2　 协议的必要性\n1.3.3　 协议如同人与人的对话\n1.3.4　 计算机中的协议\n1.3.5　 分组交换协议\n1.4 　协议由谁规定\n1.4.1 　计算机通信的诞生及其标准化\n1.4.2 　协议的标准化\n1.5 　协议分层与osi参考模型\n1.5.1 　协议的分层\n1.5.2 　通过对话理解分层\n1.5.3 　osi参考模型\n1.5.4 　osi参考模型中各个分层的作用\n1.6 　osi参考模型通信处理举例\n1.6.1 　7层通信\n1.6.2　 会话层以上的处理\n1.6.3　 传输层以下的处理\n1.7 　传输方式的分类\n1.7.1 　面向有连接型与面向无连接型\n1.7.2 　电路交换与分组交换\n1.7.3 　根据接收端数量分类\n1.8 　地址\n1.8.1　 地址的唯一性\n1.8.2　 地址的层次性\n1.9 　网络的构成要素\n1.9.1 　通信媒介与数据链路\n1.9.2 　网卡\n1.9.3 　中继器\n1.9.4 　网桥/2层交换机\n1.9.5 　路由器/3层交换机\n1.9.6 　4~7层交换机\n1.9.7 　网关\n1.10 　现代网络实态\n1.10.1 　网络的构成\n1.10.2　 互联网通信\n1.10.3　 移动通信\n1.10.4　 从信息发布者的角度看网络\n第2章 tcp/ip基础知识\n2.1 　tcp/ip出现的背景及其历史\n2.1.1 　从军用技术的应用谈起\n2.1.2　 arpanet的诞生\n2.1.3　 tcp/ip的诞生\n2.1.4　 unix系统的普及与互联网的扩张\n2.1.5　 商用互联网服务的启蒙\n2.2 　tcp/ip的标准化\n2.2.1 　tcp/ip的具体含义\n2.2.2 　tcp/ip标准化精髓\n2.2.3　 tcp/ip规范--rfc\n2.2.4 　tcp/ip的标准化流程\n2.2.5 　rfc的获取方法\n2.3　 互联网基础知识\n2.3.1 　互联网定义\n2.3.2 　互联网与tcp/ip的关系\n2.3.3 　互联网的结构\n2.3.4 　isp和区域网\n2.4 　tcp/ip协议分层模型\n2.4.1　 tcp/ip与osi参考模型\n2.4.2　 硬件（物理层）\n2.4.3 　网络接口层（数据链路层）\n2.4.4 　互联网层（网络层）\n2.4.5　 传输层\n2.4.6　 应用层（会话层以上的分层）\n2.5 　tcp/ip分层模型与通信示例\n2.5.1　 数据包首部\n2.5.2　 发送数据包\n2.5.3 　经过数据链路的包\n2.5.4 　数据包接收处理\n第3章 数据链路\n3.1 　数据链路的作用\n3.2 　数据链路相关技术\n3.2.1 　mac地址\n3.2.2　 共享介质型网络\n3.2.3 　非共享介质网络\n3.2.4　 根据mac地址转发\n3.2.5　 环路检测技术\n3.2.6　 vlan\n3.3 　以太网\n3.3.1 　以太网连接形式\n3.3.2　 以太网的分类\n3.3.3 　以太网的历史\n3.3.4 　以太网帧格式\n3.4 　无线通信\n3.4.1　 无线通信的种类\n3.4.2 　ieee802.11\n3.4.3 　ieee802.11b和ieee802.11g\n3.4.4 　ieee802.11a\n3.4.5 　ieee802.11n\n3.4.6 　使用无线lan时的注意事项\n3.4.7　 蓝牙\n3.4.8　 wimax\n3.4.9 　zigbee\n3.5 　ppp\n3.5.1 　ppp定义\n3.5.2 　lcp与ncp\n3.5.3　 ppp的帧格式\n3.5.4 　pppoe\n3.6 　其他数据链路\n3.6.1 　atm\n3.6.2　 pos\n3.6.3 　fddi\n3.6.4 　token ring\n3.6.5 　100vg-anylan\n3.6.6 　光纤通道\n3.6.7 　hippi\n3.6.8　 ieee1394\n3.6.9　 hdmi\n3.6.10 　iscsi\n3.6.11 　infiniband\n3.6.12 　docsis\n3.6.13 　高速plc\n3.7 　公共网络\n3.7.1 　模拟电话线路\n3.7.2　 移动通信服务\n3.7.3 　adsl\n3.7.4 　ftth\n3.7.5 　有线电视\n3.7.6 　专线\n3.7.7 　vpn\n3.7.8 　公共无线lan\n3.7.9 　其他公共无线通信服务\n第4章 ip协议\n4.1 　ip即网际协议\n4.1.1 　ip相当于osi参考模型的第3层\n4.1.2 　网络层与数据链路层的关系\n4.2 　ip基础知识\n4.2.1　 ip地址属于网络层地址\n4.2.2 　路由控制\n4.2.3 　数据链路的抽象化\n4.2.4 　ip属于面向无连接型\n4.3 　ip地址的基础知识\n4.3.1 　ip地址的定义\n4.3.2 　ip地址由网络和主机两部分标识组成\n4.3.3　 ip地址的分类\n4.3.4　 广播地址\n4.3.5　 ip多播\n4.3.6　 子网掩码\n4.3.7　 cidr与vlsm\n4.3.8　 全局地址与私有地址\n4.3.9 　全局地址由谁决定\n4.4 　路由控制\n4.4.1　 ip地址与路由控制\n4.4.2　 路由控制表的聚合\n4.5 　ip分割处理与再构成处理\n4.5.1 　数据链路不同，mtu则相异\n4.5.2 　ip报文的分片与重组\n4.5.3　 路径mtu发现\n4.6 　ipv6\n4.6.1　 ipv6的必要性\n4.6.2　 ipv6的特点\n4.6.3　 ipv6中ip地址的标记方法\n4.6.4 　ipv6地址的结构\n4.6.5　 全局单播地址\n4.6.6　 链路本地单播地址\n4.6.7　 唯一本地地址\n4.6.8 　ipv6分段处理\n4.7 　ipv4首部\n4.8 　ipv6首部格式\n第5章 ip协议相关技术\n5.1 　仅凭ip无法完成通信\n5.2 　dns\n5.2.1　 ip地址不便记忆\n5.2.2　 dns的产生\n5.2.3　 域名的构成\n5.2.4　 dns查询\n5.2.5　 dns如同互联网中的分布式数据库\n5.3 　arp\n5.3.1　 arp概要\n5.3.2　 arp的工作机制\n5.3.3　 ip地址和mac地址缺一不可？\n5.3.4 　rarp\n5.3.5　 代理arp\n5.4 　icmp\n5.4.1 　辅助ip的icmp\n5.4.2 　主要的icmp消息\n5.4.3 　其他icmp消息\n5.4.4 　icmpv6\n5.5　 dhcp\n5.5.1　 dhcp实现即插即用\n5.5.2　 dhcp的工作机制\n5.5.3　 dhcp中继代理\n5.6　 nat\n5.6.1　 nat定义\n5.6.2　 nat的工作机制\n5.6.3　 nat-pt（napt-pt）\n5.6.4　 nat的潜在问题\n5.6.5　 解决nat的潜在问题与nat穿越\n5.7 　ip隧道\n5.8 　其他ip相关技术\n5.8.1 　ip多播相关技术\n5.8.2 　ip任播\n5.8.3 　通信质量控制\n5.8.4 　显式拥塞通知\n5.8.5 　mobile ip\n第6章 tcp与udp\n6.1 　传输层的作用\n6.1.1　 传输层定义\n6.1.2　 通信处理\n6.1.3　 两种传输层协议tcp和udp\n6.1.4　 tcp与udp区分\n6.2　 端口号\n6.2.1　 端口号定义\n6.2.2　 根据端口号识别应用\n6.2.3 　通过ip地址、端口号、协议号进行通信识别\n6.2.4 　端口号如何确定\n6.2.5 　端口号与协议\n6.3　 udp\n6.4　 tcp\n6.4.1 　tcp的特点及其目的\n6.4.2 　通过序列号与确认应答提高可靠性\n6.4.3　 重发超时如何确定\n6.4.4 　连接管理\n6.4.5 　tcp以段为单位发送数据\n6.4.6 　利用窗口控制提高速度\n6.4.7 　窗口控制与重发控制\n6.4.8　 流控制\n6.4.9　 拥塞控制\n6.4.10　 提高网络利用率的规范\n6.4.11　 使用tcp的应用\n6.5　 其他传输层协议\n6.5.1　 udp-lite\n6.5.2　 sctp\n6.5.3 　dccp\n6.6　 udp首部的格式\n6.7　 tcp首部格式\n第7章 路由协议\n7.1　 路由控制的定义\n7.1.1　 ip地址与路由控制\n7.1.2 　静态路由与动态路由\n7.1.3　 动态路由的基础\n7.2 　路由控制范围\n7.2.1 　接入互联网的各种组织机构\n7.2.2 　自治系统与路由协议\n7.2.3 　igp与egp\n7.3 　路由算法\n7.3.1　 距离向量算法\n7.3.2　 链路状态算法\n7.3.3　 主要路由协议\n7.4　 rip\n7.4.1 　广播路由控制信息\n7.4.2 　根据距离向量确定路由\n7.4.3 　使用子网掩码时的rip处理\n7.4.4 　rip中路由变更时的处理\n7.4.5 　rip2\n7.5　 ospf\n7.5.1　 ospf是链路状态型路由协议\n7.5.2　 ospf基础知识\n7.5.3　 ospf工作原理概述\n7.5.4　 将区域分层化进行细分管理\n7.6　 bgp\n7.6.1　 bgp与as号\n7.6.2　 bgp是路径向量协议\n7.7 　mpls\n7.7.1　 mpls的网络基本动作\n7.7.2　 mpls的优点\n第8章 应用协议\n8.1 　应用层协议概要\n8.2 　远程登录\n8.2.1 　telnet\n8.2.2 　ssh\n8.3 　文件传输\n8.4 　电子邮件\n8.4.1 　电子邮件的工作机制\n8.4.2 　邮件地址\n8.4.3 　mime\n8.4.4 　smtp\n8.4.5 　pop\n8.4.6 　imap\n8.5 　www\n8.5.1 　互联网的蓬勃发展\n8.5.2　 www基本概念\n8.5.3 　uri\n8.5.4 　html\n8.5.5　 http\n8.5.6 　javascript、cgi、cookie\n8.6 　网络管理\n8.6.1　 snmp\n8.6.2　 mib\n8.6.3　 rmon\n8.6.4　 snmp应用举例\n8.7 　其他应用层协议\n8.7.1 　多媒体通信实现技术\n8.7.2 　p2p\n8.7.3　 ldap\n第9章 网络安全\n9.1　 tcp/ip与网络安全\n9.2　 网络安全构成要素\n9.2.1　 防火墙\n9.2.2 　ids（入侵检测系统）\n9.2.3 　反病毒/个人防火墙\n9.3 　加密技术基础\n9.3.1　 对称密码体制与公钥密码体制\n9.3.2　 身份认证技术\n9.4 　安全协议\n9.4.1 　ipsec与vpn\n9.4.2 　tls/ssl与https\n9.4.3 　ieee802.1x\n附录\n附1　 互联网上便捷的资源\n附1.1 　国际\n附1.2 　日本\n附2 　ip地址分类（a、b、c类）相关基础知识\n附2.1　 a类\n附2.2　 b类\n附2.3 　c类\n附3 　物理层\n附3.1 　物理层相关基础知识\n附3.2 　0/1编码\n附4 　传输介质相关基础知识\n附4.1 　同轴电缆\n附4.2 　双绞线\n附4.3 　光纤电缆\n附4.4 　无线\n附5 　插页导图",
    "pages": "312",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s26676928.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s26676928.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s26676928.jpg"
    },
    "alt": "https://book.douban.com/subject/24737674/",
    "id": "24737674",
    "publisher": "人民邮电出版社",
    "isbn10": "7115318972",
    "isbn13": "9787115318978",
    "title": "图解TCP/IP : 第5版",
    "url": "https://api.douban.com/v2/book/24737674",
    "alt_title": "マスタリングTCP/IP 入門編 第5版",
    "author_intro": "作者简介：\n竹下隆史\nNet One Systems公司资深网络工程师。\n村山公保\n仓敷艺术科学大学产业科学技术学院信息学系教授。\n荒井透\n1958年生人。 Net One Systems公司资深网络工程师。\n苅田幸雄\n高能加速器研究所、计算科学中心研究员。\n译者简介：\n乌尼日其其格\nOracle资深中间件技术专家、资深技术顾问。精于问题诊断处理、擅长解决大型核心系统的性能故障，并拥有多项Oracle官方认证资质。",
    "summary": "这是一本图文并茂的网络管理技术书籍，旨在让广大读者理解TCP/IP的基本知识、掌握TCP/IP的基本技能。\n书中讲解了网络基础知识、TCP/IP基础知识、数据链路、IP协议、IP协议相关技术、TCP与UDP、路由协议、应用协议、网络安全等内容，引导读者了解和掌握TCP/IP，营造一个安全的、使用放心的网络环境。\n本书适合计算机网络的开发、管理人员阅读，也可作为大专院校相关专业的教学参考书。",
    "series": { "id": "34135", "title": "图解入门系列" },
    "price": "69.00元"
  },
  "9787115341082": {
    "rating": { "max": 10, "numRaters": 99, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["霍多罗夫 (Kristina Chodorow)"],
    "pubdate": "2014-1-1",
    "tags": [
      { "count": 78, "name": "数据库", "title": "数据库" },
      { "count": 70, "name": "mongodb", "title": "mongodb" },
      { "count": 55, "name": "NoSQL", "title": "NoSQL" },
      { "count": 44, "name": "MongoDB", "title": "MongoDB" },
      { "count": 21, "name": "计算机", "title": "计算机" },
      { "count": 19, "name": "Database", "title": "Database" },
      { "count": 11, "name": "编程", "title": "编程" },
      { "count": 8, "name": "互联网", "title": "互联网" }
    ],
    "origin_title": "MongoDB:the definitive guide, second edition",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28015838.jpg",
    "binding": "平装",
    "translator": ["邓强", "王明辉"],
    "catalog": "序　　XV\n前言　　XVII\n第一部分　MongoDB 介绍\n第1章　MongoDB 简介　　3\n1.1 　易于使用　　3\n1.2 　易于扩展　　4\n1.3 　丰富的功能　　4\n1.4 　卓越的性能　　5\n1.5 　小结　　5\n第2章　MongoDB 基础知识　　7\n2.1 　文档　　7\n2.2 　集合　　8\n2.2.1 　动态模式　　8\n2.2.2 　命名　　9\n2.3 　数据库　　10\n2.4 　启动MongoDB　　11\n2.5 　MongoDB shell 简介　　12\n2.5.1 　运行shell　　12\n2.5.2 　MongoDB 客户端　　13\n2.5.3 　shell 中的基本操作　　14\n2.6 　数据类型　　16\n2.6.1 　基本数据类型　　16\n2.6.2 　日期　　18\n2.6.3 　数组　　18\n2.6.4 　内嵌文档　　19\n2.6.5 　_id 和ObjectId　　20\n2.7 　使用MongoDB shell　　21\n2.7.1 　shell 小贴士　　22\n2.7.2 　使用shell 执行脚本　　23\n2.7.3 　创建.mongorc.js 文件　　25\n2.7.4 　定制shell 提示　　26\n2.7.5 　编辑复合变量　　26\n2.7.6 　集合命名注意事项　　27\n第3章　创建、更新和删除文档　　29\n3.1 　插入并保存文档　　29\n3.1.1 　批量插入　　29\n3.1.2 　插入校验　　30\n3.2 　删除文档　　31\n3.3 　更新文档　　32\n3.3.1 　文档替换　　32\n3.3.2 　使用修改器　　34\n3.3.3 　upsert　　45\n3.3.4 　更新多个文档　　47\n3.3.5 　返回被更新的文档　　48\n3.4 　写入安全机制　　50\n第4章　查询　　53\n4.1 　find 简介　　53\n4.1.1 　指定需要返回的键　　54\n4.1.2 　限制　　55\n4.2 　查询条件　　55\n4.2.1 　查询条件　　55\n4.2.2 　OR 查询　　56\n4.2.3 　$not　　57\n4.2.4 　条件语义　　57\n4.3 　特定类型的查询　　58\n4.3.1 　null　　58\n4.3.2 　正则表达式　　59\n4.3.3 　查询数组　　59\n4.3.4 　查询内嵌文档　　64\n4.4 　$where 查询　　65\n4.5 　游标　　67\n4.5.1 　limit、skip 和sort　　69\n4.5.2 　避免使用skip 略过大量结果　　70\n4.5.3 　高级查询选项　　72\n4.5.4 　获取一致结果　　73\n4.5.5 　游标生命周期　　75\n4.6 　数据库命令　　75\n第二部分　设计应用\n第5章　索引　　81\n5.1 　索引简介　　81\n5.1.1 　复合索引简介　　84\n5.1.2 　使用复合索引　　90\n5.1.3 　$ 操作符如何使用索引　　91\n5.1.4 　索引对象和数组　　96\n5.1.5 　索引基数　　98\n5.2 　使用explain() 和hint() 　　98\n5.3 　何时不应该使用索引　　103\n5.4 　索引类型　　104\n5.4.1 　唯一索引　　104\n5.4.2 　稀疏索引　　106\n5.5 　索引管理　　107\n5.5.1 　标识索引　　108\n5.5.2 　修改索引　　108\n第6章　特殊的索引和集合 　　111\n6.1 　固定集合　　 　111\n6.1.1 　创建固定集合　　113\n6.1.2 　自然排序　　113\n6.1.3 　循环游标　　115\n6.1.4 　没有_id 索引的集合　　115\n6.2 　TTL 索引　　116\n6.3 　全文本索引　　116\n6.3.1 　搜索语法　　119\n6.3.2 　优化全文本搜索　　120\n6.3.3 　在其他语言中搜索　　121\n6.4 　地理空间索引　　121\n6.4.1 　地理空间查询的类型　　122\n6.4.2 　复合地理空间索引　　123\n6.4.3　　2d 索引　　123\n6.5 　使用GridFS 存储文件　　125\n6.5.1 　GridFS 入门　　126\n6.5.2 　在MongoDB 驱动程序中使用GridFS　　126\n6.5.3 　揭开GridFS 的面纱　　127\n第7章　聚合　　129\n7.1 　聚合框架　　129\n7.2 　管道操作符　　131\n7.2.1 　$match　　132\n7.2.2 　$project　　132\n7.2.3 　$group　　137\n7.2.4 　$unwind　　140\n7.2.5 　$sort　　141\n7.2.6 　$limit　　142\n7.2.7 　$skip　　142\n7.2.8 　使用管道　　142\n7.3 　MapReduce　　143\n7.3.1 　示例1：找出集合中的所有键　　143\n7.3.2 　示例2：网页分类　　145\n7.3.3 　MongoDB 和MapReduce　　146\n7.4 　聚合命令　　148\n7.4.1 　count　　149\n7.4.2 　distinct　　149\n7.4.3 　group　　150\n第8章　应用程序设计　　155\n8.1 　范式化与反范式化　　155\n8.1.1 　数据表示的例子　　156\n8.1.2 　基数　　159\n8.1.3 　好友、粉丝，以及其他的麻烦事项　　160\n8.2 　优化数据操作　　162\n8.2.1 　优化文档增长　　162\n8.2.2 　删除旧数据　　164\n8.3 　数据库和集合的设计　　164\n8.4 　一致性管理　　165\n8.5 　模式迁移　　166\n8.6 　不适合使用MongoDB 的场景　　167\n第三部分　复制\n第9章　创建副本集　　171\n9.1 　复制简介　　171\n9.2 　建立副本集　　172\n9.3 　配置副本集　　176\n9.3.1 　rs 辅助函数　　178\n9.3.2 　网络注意事项　　178\n9.4 　修改副本集配置　　178\n9.5 　设计副本集　　180\n9.6 　成员配置选项　　184\n9.6.1 　选举仲裁者　　184\n9.6.2 　优先级　　185\n9.6.3 　隐藏成员　　186\n9.6.4 　延迟备份节点　　187\n9.6.5 　创建索引　　187\n第10章　副本集的组成　　189\n10.1 　同步　　189\n10.1.1 　初始化同步　　190\n10.1.2 　处理陈旧数据　　193\n10.2 　心跳　　193\n10.3 　选举　　195\n10.4 　回滚　　195\n第11章　从应用程序连接副本集　　201\n11.1 　客户端到副本集的连接　　201\n11.2 　等待写入复制　　202\n11.2.1 　可能导致错误的原因　　203\n11.2.2 　\"w\" 的其他值　　204\n11.3 　自定义复制保证规则　　204\n11.3.1 　保证复制到每个数据中心的一台服务器上　　204\n11.3.2 　保证写操作被复制到可见节点中的“大多数”　　206\n11.3.3 　创建其他规则　　206\n11.4 　将读请求发送到备份节点　　207\n11.4.1 　出于一致性考虑　　207\n11.4.2 　出于负载的考虑　　208\n11.4.3 　何时可以从备份节点读取数据　　208\n第12章　管理　　211\n12.1 　以单机模式启动成员　　211\n12.2 　副本集配置　　212\n12.2.1 　创建副本集　　212\n12.2.2 　修改副本集成员　　213\n12.2.3 　创建比较大的副本集　　213\n12.2.4 　强制重新配置　　214\n12.3 　修改成员状态　　215\n12.3.1 　把主节点变为备份节点　　215\n12.3.2 　阻止选举　　215\n12.3.3 　使用维护模式　　215\n12.4 　监控复制　　216\n12.4.1 　获取状态　　216\n12.4.2 　复制图谱　　218\n12.4.3 　复制循环　　220\n12.4.4 　禁用复制链　　220\n12.4.5 　计算延迟　　221\n12.4.6 　调整oplog 大小　　222\n12.4.7 　从延迟备份节点中恢复　　223\n12.4.8 　创建索引　　224\n12.4.9 　在预算有限的情况下进行复制　　225\n12.4.10 　主节点如何跟踪延迟　　226\n12.5 　主从模式　　227\n12.5.1 　从主从模式切换到副本集模式　　228\n12.5.2 　让副本集模仿主从模式的行为　　228\n第四部分　分片\n第13章　分片　　233\n13.1 　分片简介　　233\n13.2 　理解集群的组件　　234\n13.3 　快速建立一个简单的集群　　235\n第14章　配置分片　　243\n14.1 　何时分片　　243\n14.2 　启动服务器　　244\n14.2.1 　配置服务器　　244\n14.2.2 　mongos 进程　　245\n14.2.3 　将副本集转换为分片　　245\n14.2.4 　增加集群容量　　247\n14.2.5 　数据分片　　247\n14.3 　MongoDB 如何追踪集群数据　　248\n14.3.1 　块范围　　249\n14.3.2 　拆分块　　250\n14.4 　均衡器　　254\n第15章　选择片键　　257\n15.1 　检查使用情况　　257\n15.2 　数据分发　　258\n15.2.1 　升序片键　　258\n15.2.2 　随机分发的片键　　261\n15.2.3 　 基于位置的片键　　262\n15.3 　片键策略　　263\n15.3.1 　散列片键　　264\n15.3.2 　GridFS 的散列片键　　265\n15.3.3 　流水策略　　266\n15.3.4 　多热点　　267\n15.4 　片键规则和指导方针　　270\n15.4.1 　片键限制　　270\n15.4.2 　片键的势　　270\n15.5 　控制数据分发　　270\n15.5.1 　对多个数据库和集合使用一个集群　　270\n15.5.2 　手动分片　　272\n第16章　分片管理　　275\n16.1 　检查集群状态　　275\n16.1.1 　使用sh.status 查看集群摘要信息　　275\n16.1.2 　检查配置信息　　277\n16.2 　查看网络连接　　282\n16.2.1 　查看连接统计　　283\n16.2.2 　限制连接数量　　283\n16.3 　服务器管理　　285\n16.3.1 　添加服务器　　285\n16.3.2 　修改分片的服务器　　285\n16.3.3 　删除分片　　286\n16.3.4 　修改配置服务器　　288\n16.4 　数据均衡　　289\n16.4.1 　均衡器　　289\n16.4.2 　修改块大小　　290\n16.4.3 　移动块　　290\n16.4.4 　特大块　　292\n16.4.5 　刷新配置　　295\n第五部分　应用管理\n第17章　了解应用的动态　　299\n17.1 　了解正在进行的操作　　299\n17.1.1 　寻找有问题的操作　　301\n17.1.2 　终止操作的执行　　301\n17.1.3 　假象　　302\n17.1.4 　避免幽灵操作　　302\n17.2 　使用系统分析器　　303\n17.3 　计算空间消耗　　305\n17.3.1 　文档　　305\n17.3.2 　集合　　305\n17.3.3 　数据库　　306\n17.4 　使用mongotop 和monogostat 　　307\n第18章　数据管理　　311\n18.1 　配置身份验证　　311\n18.1.1 　身份验证基本原理　　312\n18.1.2 　配置身份验证　　313\n18.1.3 　身份验证的工作原理　　314\n18.2 　建立和删除索引　　315\n18.2.1 　在独立的服务器上建立索引　　315\n18.2.2 　在副本集上建立索引　　315\n18.2.3 　在分片集群上建立索引　　316\n18.2.4 　删除索引　　316\n18.2.5 　注意内存溢出杀手　　316\n18.3 　预热数据　　317\n18.3.1 　将数据库移至内存　　317\n18.3.2 　将集合移至内存　　318\n18.3.3 　自定义预热　　318\n18.4 　压缩数据　　320\n18.5 　移动集合　　321\n18.6 　预分配数据文件　　322\n第19章　持久性　　323\n19.1 　日记系统的用途　　323\n19.1.1 　批量提交写入操作　　324\n19.1.2 　设定提交时间间隔　　325\n19.2 　关闭日记系统　　325\n19.2.1 　替换数据文件　　325\n19.2.2 　修复数据文件　　326\n19.2.3 　关于mongod.lock 文件　　326\n19.2.4 　隐蔽的异常退出　　327\n19.3 　MongoDB 无法保证的事项　　327\n19.4 　检验数据损坏　　327\n19.5 　副本集中的持久性　　329\n第六部分　服务器管理\n第20章　启动和停止MongoDB　　333\n20.1 　从命令行启动　　333\n20.2 　停止MongoDB　　336\n20.3 　安全性　　337\n20.3.1 　数据加密　　338\n20.3.2 　SSL 安全连接　　338\n20.4 　日志　　338\n第21章　监控MongoDB　　341\n21.1 　监控内存使用状况　　341\n21.1.1 　有关电脑内存的介绍　　341\n21.1.2 　跟踪监测内存使用状况　　342\n21.1.3 　跟踪监测缺页中断　　343\n21.1.4 　减少索引树的脱靶次数　　345\n21.1.5 　IO 延迟　　345\n21.1.6 　跟踪监测后台刷新平均时间　　346\n21.2 　计算工作集的大小　　347\n21.3 　跟踪监测性能状况　　349\n21.4 　监控副本集　　352\n第22章　备份　　355\n22.1 　对服务器进行备份　　355\n22.1.1 　文件系统快照　　355\n22.1.2 　复制数据文件　　356\n22.1.3 　使用mongodump　　357\n22.2 　对副本集进行备份　　359\n22.3 　对分片集群进行备份　　360\n22.3.1 　备份和恢复整个集群　　360\n22.3.2 　备份和恢复单独的分片　　360\n22.4 　使用mongooplog 进行增量备份　　361\n第23章　部署MongoDB　　363\n23.1 　设计系统结构　　363\n23.1.1 　选择存储介质　　363\n23.1.2 　推荐的RAID 配置　　367\n23.1.3 　CPU　　368\n23.1.4 　选择操作系统　　368\n23.1.5 　交换空间　　369\n23.1.6 　文件系统　　369\n23.2 　虚拟化　　370\n23.2.1 　禁止内存过度分配　　370\n23.2.2 　神秘的内存　　370\n23.2.3 　处理网络磁盘的IO 问题　　371\n23.2.4 　使用非网络磁盘　　372\n23.3 　系统配置　　372\n23.3.1 　禁用NUMA　　372\n23.3.2 　更智能地预读取数据　　375\n23.3.3 　禁用大内存页面　　376\n23.3.4 　选择一种磁盘调度算法　　377\n23.3.5 　不要记录访问时间　　377\n23.3.6 　修改限制　　378\n23.4 　网络配置　　379\n23.5 　系统管理　　381\n23.5.1 　时钟同步　　381\n23.5.2 　OOM Killer　　381\n23.5.3 　关闭定期任务　　382\n附录A 　安装MongoDB　　383\n附录B 　深入MongoDB　　387",
    "ebook_url": "https://read.douban.com/ebook/12052055/",
    "pages": "390",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28015838.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28015838.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28015838.jpg"
    },
    "alt": "https://book.douban.com/subject/25798102/",
    "id": "25798102",
    "publisher": "人民邮电出版社",
    "isbn10": "7115341087",
    "isbn13": "9787115341082",
    "title": "MongoDB权威指南（第2版）",
    "url": "https://api.douban.com/v2/book/25798102",
    "alt_title": "MongoDB:the definitive guide, second edition",
    "author_intro": "作者简介：\nKristina Chodorow\n谷歌软件工程师，曾有5年是MongoDB项目的核心成员。她领导了MongoDB的副本集开发，并编写了PHP和Perl驱动程序。\n译者简介：\n邓强\n软件工程师，常年关注互联网行业，对互联网产品和技术兴趣浓厚，Apple粉、Google粉、Amazon粉。职业生涯的前几年一直从事金融行业软件系统开发，后来不顾一切投身互联网。目前在一个新成立的互联网创业小团队任职。Email：dengqiang@outlook.com。\n王明辉\n同济大学计算机系学生，经常使用MongoDB。知乎网常用id为纳米黑客。",
    "summary": "MongoDB如何帮你管理通过Web应用收集的海量数据呢？通过这本经典著作全新升级版的权威解读，你会了解面向文档数据库的诸多优点，会发现MongoDB如此稳定、性能优越甚至能够无限水平扩展背后的原因。\n本书是一本广受好评的MongoDB权威著作。新版本对上一版进行了全面扩充，可作为数据库开发人员的工作指南，也可作为系统管理人员的进阶指导，还可供项目中其他成员了解MongoDB使用。书中介绍了面向文档的存储方式及利用MongoDB的无模式数据模型处理文档、集合和多个数据库，讲述了如何执行基本的写操作以及各种复杂的条件查询，还介绍了索引、聚合工具以及其他高级查询技术，另外对监控、安全性和身份验证、备份和修复、水平扩展MongoDB数据库等内容也有所涉及。\n本书主要内容：\nMongoDB核心概念和术语\n在不同的安全等级和速度下执行基本的写操作\n利用限制、跳过等选项执行复杂的查询，并对查询结果进行排序\n基于MongoDB设计应用程序\n聚合数据，包括统计不同值的数量，找出不同值，给文档分组，以及使用MapReduce\n收集并解释有关集合和数据库的统计信息\n在MongoDB中设置副本集和自动故障转移\n使用分片横向扩展数据库，并学习这样做对应用的影响\n深入介绍监控、安全和身份验证、备份和恢复以及其他管理任务",
    "ebook_price": "31.99",
    "series": { "id": "28522", "title": "图灵程序设计丛书·数据库系列" },
    "price": "79.00元"
  },
  "9787115191120": {
    "rating": { "max": 10, "numRaters": 957, "average": "8.4", "min": 0 },
    "subtitle": "",
    "author": ["[英] Ben Forta"],
    "pubdate": "2009-1",
    "tags": [
      { "count": 602, "name": "数据库", "title": "数据库" },
      { "count": 410, "name": "mysql", "title": "mysql" },
      { "count": 390, "name": "MySQL", "title": "MySQL" },
      { "count": 219, "name": "SQL", "title": "SQL" },
      { "count": 217, "name": "计算机", "title": "计算机" },
      { "count": 127, "name": "Database", "title": "Database" },
      { "count": 122, "name": "编程", "title": "编程" },
      { "count": 101, "name": "入门", "title": "入门" }
    ],
    "origin_title": "MySQL Crash Course",
    "image": "https://img3.doubanio.com/view/subject/m/public/s5968156.jpg",
    "binding": "",
    "translator": ["刘晓霞", "钟鸣"],
    "catalog": "第1章 了解SQL\n1.1 数据库基础\n1.1.1 什么是数据库\n1.1.2 表\n1.1.3 列和数据类型\n1.1.4 行\n1.1.5 主键\n1.2 什么是SQL\n1.3 动手实践\n1.4 小结\n第2章 MySQL简介\n2.1 什么是MySQL\n2.1.1 客户机-服务器软件\n2.1.2 MySQL版本\n2.2 MySQL工具\n2.2.1 mysql命令行实用程序\n2.2.2 MySQL Administrator\n2.2.3 MySQL Query Browser\n2.3 小结\n第3章 使用MySQL\n3.1 连接\n3.2 选择数据库\n3.3 了解数据库和表\n3.4 小结\n第4章 检索数据\n4.1 SELECT语句\n4.2 检索单个列\n4.3 检索多个列\n4.4 检索所有列\n4.5 检索不同的行\n4.6 限制结果\n4.7 使用完全限定的表名\n4.8 小结\n第5章 排序检索数据\n5.1 排序数据\n5.2 按多个列排序\n5.3 指定排序方向\n5.4 小结\n第6章 过滤数据\n6.1 使用WHERE子句\n6.2 WHERE子句操作符\n6.2.1 检查单个值\n6.2.2 不匹配检查\n6.2.3 范围值检查\n6.2.4 空值检查\n6.3 小结\n第7章 数据过滤\n7.1 组合WHERE子句\n7.1.1 AND操作符\n7.1.2 OR操作符\n7.1.3 计算次序\n7.2 IN操作符\n7.3 NOT操作符\n7.4 小结\n第8章 用通配符进行过滤\n8.1 LIKE操作符\n8.1.1 百分号（%）通配符\n8.1.2 下划线（_）通配符\n8.2 使用通配符的技巧\n8.3 小结\n第9章 用正则表达式进行搜索\n9.1 正则表达式介绍\n9.2 使用MySQL正则表达式\n9.2.1 基本字符匹配\n9.2.2 进行OR匹配\n9.2.3 匹配几个字符之一\n9.2.4 匹配范围\n9.2.5 匹配特殊字符\n9.2.6 匹配字符类\n9.2.7 匹配多个实例\n9.2.8 定位符\n9.3 小结\n第10章 创建计算字段\n10.1 计算字段\n10.2 拼接字段\n10.3 执行算术计算\n10.4 小结\n第11章 使用数据处理函数\n11.1 函数\n11.2 使用函数\n11.2.1 文本处理函数\n11.2.2 日期和时间处理函数\n11.2.3 数值处理函数\n11.3 小结\n第12章 汇总数据\n12.1 聚集函数\n12.1.1 AVG（）函数\n12.1.2 COUNT（）函数\n12.1.3 MAX（）函数\n12.1.4 MIN（）函数\n12.1.5 SUM（）函数\n12.2 聚集不同值\n12.3 组合聚集函数\n12.4 小结\n第13章 分组数据\n13.1 数据分组\n13.2 创建分组\n13.3 过滤分组\n13.4 分组和排序\n13.5 SELECT子句顺序\n13.6 小结\n第14章 使用子查询\n14.1 子查询\n14.2 利用子查询进行过滤\n14.3 作为计算字段使用子查询\n14.4 小结\n第15章 联结表\n15.1 联结\n15.1.1 关系表\n15.1.2 为什么要使用联结\n15.2 创建联结\n15.2.1 WHERE子句的重要性\n15.2.2 内部联结\n15.2.3 联结多个表\n15.3 小结\n第16章 创建高级联结\n16.1 使用表别名\n16.2 使用不同类型的联结\n16.2.1 自联结\n16.2.2 自然联结\n16.2.3 外部联结\n16.3 使用带聚集函数的联结\n16.4 使用联结和联结条件\n16.5 小结\n第17章 组合查询\n17.1 组合查询\n17.2 创建组合查询\n17.2.1 使用UNION\n17.2.2 UNION规则\n17.2.3 包含或取消重复的行\n17.2.4 对组合查询结果排序\n17.3 小结\n第18章 全文本搜索\n18.1 理解全文本搜索\n18.2 使用全文本搜索\n18.2.1 启用全文本搜索支持\n18.2.2 进行全文本搜索\n18.2.3 使用查询扩展\n18.2.4 布尔文本搜索\n18.2.5 全文本搜索的使用说明\n18.3 小结\n第19章 插入数据\n19.1 数据插入\n19.2 插入完整的行\n19.3 插入多个行\n19.4 插入检索出的数据\n19.5 小结\n第20章 更新和删除数据\n20.1 更新数据\n20.2 删除数据\n20.3 更新和删除的指导原则\n20.4 小结\n第21章 创建和操纵表\n21.1 创建表\n21.1.1 表创建基础\n21.1.2 使用NULL值\n21.1.3 主键再介绍\n21.1.4 使用AUTO_ INCREMENT\n21.1.5 指定默认值\n21.1.6 引擎类型\n21.2 更新表\n21.3 删除表\n21.4 重命名表\n21.5 小结\n第22章 使用视图\n22.1 视图\n22.1.1 为什么使用视图\n22.1.2 视图的规则和限制\n22.2 使用视图\n22.2.1 利用视图简化复杂的联结\n22.2.2 用视图重新格式化检索出的数据\n22.2.3 用视图过滤不想要的数据\n22.2.4 使用视图与计算字段\n22.2.5 更新视图\n22.3 小结\n第23章 使用存储过程\n23.1 存储过程\n23.2 为什么要使用存储过程\n23.3 使用存储过程\n23.3.1 执行存储过程\n23.3.2 创建存储过程\n23.3.3 删除存储过程\n23.3.4 使用参数\n23.3.5 建立智能存储过程\n23.3.6 检查存储过程\n23.4 小结\n第24章 使用游标\n24.1 游标\n24.2 使用游标\n24.2.1 创建游标\n24.2.2 打开和关闭游标\n24.2.3 使用游标数据\n24.3 小结\n第25章 使用触发器\n25.1 触发器\n25.2 创建触发器\n25.3 删除触发器\n25.4 使用触发器\n25.4.1 INSERT触发器\n25.4.2 DELETE触发器\n25.4.3 UPDATE触发器\n25.4.4 关于触发器的进一步介绍\n25.5 小结\n第26章 管理事务处理\n26.1 事务处理\n26.2 控制事务处理\n26.2.1 使用ROLLBACK\n26.2.2 使用COMMIT\n26.2.3 使用保留点\n26.2.4 更改默认的提交行为\n26.3 小结\n第27章 全球化和本地化\n27.1 字符集和校对顺序\n27.2 使用字符集和校对顺序\n27.3 小结\n第28章 安全管理\n28.1 访问控制\n28.2 管理用户\n28.2.1 创建用户账号\n28.2.2 删除用户账号\n28.2.3 设置访问权限\n28.2.4 更改口令\n28.3 小结\n第29章 数据库维护\n29.1 备份数据\n29.2 进行数据库维护\n29.3 诊断启动问题\n29.4 查看日志文件\n29.5 小结\n第30章 改善性能\n30.1 改善性能\n30.2 小结\n附录A MySQL入门\n附录B 样例表\n附录C MySQL语句的语法\n附录D MySQL数据类型\n附录E MySQL保留字\n索引",
    "pages": "241",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s5968156.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s5968156.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s5968156.jpg"
    },
    "alt": "https://book.douban.com/subject/3354490/",
    "id": "3354490",
    "publisher": "人民邮电出版社",
    "isbn10": "7115191123",
    "isbn13": "9787115191120",
    "title": "MySQL必知必会",
    "url": "https://api.douban.com/v2/book/3354490",
    "alt_title": "MySQL Crash Course",
    "author_intro": "Ben Forta是世界知名的技术作家，也是Ad。be技术界最为知名的专家之一，目前担任Adobe公司的高级技术推广专家。他具有计算机行业20多年工作经验，多年来撰写了十几本技术图书，其中不少是世界畅销书，已被翻译为十几种文字。除本书外，他撰写的《正则表达式必知必会》也即将由人民邮电出版社出版。读者可以通过他的个人网站http：//www．forta．com了解更多信息。",
    "summary": "《MySQL必知必会》MySQL是世界上最受欢迎的数据库管理系统之一。书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过重点突出的章节，条理清晰、系统而扼要地讲述了读者应该掌握的知识，使他们不经意间立刻功力大增。",
    "series": { "id": "28522", "title": "图灵程序设计丛书·数据库系列" },
    "price": "39.00元"
  },
  "9787111557975": {
    "rating": { "max": 10, "numRaters": 155, "average": "9.0", "min": 0 },
    "subtitle": "",
    "author": ["付磊", "张益军"],
    "pubdate": "2017-3-1",
    "tags": [
      { "count": 214, "name": "Redis", "title": "Redis" },
      { "count": 73, "name": "redis", "title": "redis" },
      { "count": 69, "name": "数据库", "title": "数据库" },
      { "count": 54, "name": "运维", "title": "运维" },
      { "count": 50, "name": "计算机", "title": "计算机" },
      { "count": 35, "name": "开发", "title": "开发" },
      { "count": 35, "name": "redis集群", "title": "redis集群" },
      { "count": 27, "name": "redis集群管理", "title": "redis集群管理" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29335561.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "序　言\n前　言\n致　谢\n第1章　初识Redis 1\n1.1　盛赞Redis 1\n1.2　Redis特性 2\n1.3　Redis使用场景 5\n1.3.1　Redis可以做什么 5\n1.3.2　Redis不可以做什么 5\n1.4　用好Redis的建议 6\n1.5　正确安装并启动Redis 6\n1.5.1　安装Redis 7\n1.5.2　配置、启动、操作、关闭Redis 8\n1.6　Redis重大版本 11\n1.7　本章重点回顾 14\n第2章　API的理解和使用 15\n2.1　预备 15\n2.1.1　全局命令 15\n2.1.2　数据结构和内部编码 18\n2.1.3　单线程架构 19\n2.2　字符串 21\n2.2.1　命令 22\n2.2.2　内部编码 27\n2.2.3　典型使用场景 28\n2.3　哈希 31\n2.3.1　命令 32\n2.3.2　内部编码 35\n2.3.3　使用场景 36\n2.4　列表 38\n2.4.1　命令 38\n2.4.2　内部编码 43\n2.4.3　使用场景 44\n2.5　集合 46\n2.5.1　命令 46\n2.5.2　内部编码 50\n2.5.3　使用场景 51\n2.6　有序集合 52\n2.6.1　命令 53\n2.6.2　内部编码 59\n2.6.3　使用场景 59\n2.7　键管理 60\n2.7.1　单个键管理 60\n2.7.2　遍历键 67\n2.7.3　数据库管理 70\n2.8　本章重点回顾 73\n第3章　小功能大用处 74\n3.1　慢查询分析 74\n3.1.1　慢查询的两个配置参数 75\n3.1.2　最佳实践 77\n3.2　Redis Shell 78\n3.2.1　redis-cli详解 78\n3.2.2　redis-server详解 82\n3.2.3　redis-benchmark详解 83\n3.3　Pipeline 84\n3.3.1　Pipeline概念 84\n3.3.2　性能测试 85\n3.3.3　原生批量命令与Pipeline对比 86\n3.3.4　最佳实践 87\n3.4　事务与Lua 87\n3.4.1　事务 87\n3.4.2　Lua用法简述 90\n3.4.3　Redis与Lua 92\n3.4.4　案例 94\n3.4.5　Redis如何管理Lua脚本 96\n3.5　Bitmaps 98\n3.5.1　数据结构模型 98\n3.5.2　命令 98\n3.5.3　Bitmaps分析 101\n3.6　HyperLogLog 102\n3.7　发布订阅 105\n3.7.1　命令 106\n3.7.2　使用场景 108\n3.8　GEO 109\n3.9　本章重点回顾 112\n第4章　客户端 113\n4.1　客户端通信协议 113\n4.2　Java客户端Jedis 117\n4.2.1　获取Jedis 117\n4.2.2　Jedis的基本使用方法 118\n4.2.3　Jedis连接池的使用方法 122\n4.2.4　Redis中Pipeline的使用方法 125\n4.2.5　Jedis的Lua脚本 126\n4.3　Python客户端redis-py 128\n4.3.1　获取redis-py 128\n4.3.2　redis-py的基本使用方法 128\n4.3.3　redis-py中Pipeline的使用方法 130\n4.3.4　redis-py中的Lua脚本使用方法 130\n4.4　客户端管理 131\n4.4.1　客户端API 132\n4.4.2　客户端相关配置 145\n4.4.3　客户端统计片段 145\n4.5　客户端常见异常 146\n4.6　客户端案例分析 149\n4.6.1　Redis内存陡增 149\n4.6.2　客户端周期性的超时 151\n4.7　本章重点回顾 153\n第5章　持久化 154\n5.1　RDB 154\n5.1.1　触发机制 154\n5.1.2　流程说明 155\n5.1.3　RDB文件的处理 156\n5.1.4　RDB的优缺点 156\n5.2　AOF 157\n5.2.1　使用AOF 157\n5.2.2　命令写入 157\n5.2.3　文件同步 158\n5.2.4　重写机制 159\n5.2.5　重启加载 161\n5.2.6　文件校验 162\n5.3　问题定位与优化 162\n5.3.1　fork操作 162\n5.3.2　子进程开销监控和优化 163\n5.3.3　AOF追加阻塞 165\n5.4　多实例部署 166\n5.5　本章重点回顾 167\n第6章　复制 168\n6.1　配置 168\n6.1.1　建立复制 168\n6.1.2　断开复制 170\n6.1.3　安全性 170\n6.1.4　只读 170\n6.1.5　传输延迟 171\n6.2　拓扑 171\n6.3　原理 172\n6.3.1　复制过程 172\n6.3.2　数据同步 175\n6.3.3　全量复制 178\n6.3.4　部分复制 181\n6.3.5　心跳 183\n6.3.6　异步复制 184\n6.4　开发与运维中的问题 184\n6.4.1　读写分离 184\n6.4.2　主从配置不一致 186\n6.4.3　规避全量复制 186\n6.4.4　规避复制风暴 187\n6.5　本章重点回顾 188\n第7章　Redis的噩梦：阻塞 189\n7.1　发现阻塞 189\n7.2　内在原因 191\n7.2.1　API或数据结构使用不合理 191\n7.2.2　CPU饱和 193\n7.2.3　持久化阻塞 194\n7.3　外在原因 195\n7.3.1　CPU竞争 195\n7.3.2　内存交换 195\n7.3.3　网络问题 196\n7.4　本章重点回顾 199\n第8章　理解内存 200\n8.1　内存消耗 200\n8.1.1　内存使用统计 200\n8.1.2　内存消耗划分 201\n8.1.3　子进程内存消耗 203\n8.2　内存管理 204\n8.2.1　设置内存上限 204\n8.2.2　动态调整内存上限 204\n8.2.3　内存回收策略 205\n8.3　内存优化 209\n8.3.1　redisObject对象 209\n8.3.2　缩减键值对象 210\n8.3.3　共享对象池 211\n8.3.4　字符串优化 213\n8.3.5　编码优化 216\n8.3.6　控制键的数量 223\n8.4　本章重点回顾 225\n第9章　哨兵 226\n9.1　基本概念 226\n9.1.1　主从复制的问题 227\n9.1.2　高可用 227\n9.1.3　Redis Sentinel的高可用性 229\n9.2　安装和部署 232\n9.2.1　部署拓扑结构 232\n9.2.2　部署Redis数据节点 233\n9.2.3　部署Sentinel节点 234\n9.2.4　配置优化 236\n9.2.5　部署技巧 243\n9.3　API 244\n9.4　客户端连接 249\n9.4.1　Redis Sentinel的客户端 249\n9.4.2　Redis Sentinel客户端基本实现原理 249\n9.4.3　Java操作Redis Sentinel 251\n9.5　实现原理 254\n9.5.1　三个定时监控任务 254\n9.5.2　主观下线和客观下线 256\n9.5.3　领导者Sentinel节点选举 258\n9.5.4　故障转移 261\n9.6　开发与运维中的问题 262\n9.6.1　故障转移日志分析 262\n9.6.2　节点运维 268\n9.6.3　高可用读写分离 271\n9.7　本章重点回顾 272\n第10章　集群 274\n10.1　数据分布 274\n10.1.1　数据分布理论 274\n10.1.2　Redis数据分区 277\n10.1.3　集群功能限制 278\n10.2　搭建集群 278\n10.2.1　准备节点 278\n10.2.2　节点握手 280\n10.2.3　分配槽 282\n10.2.4　用redis-trib.rb搭建集群 284\n10.3　节点通信 287\n10.3.1　通信流程 287\n10.3.2　Gossip消息 287\n10.3.3　节点选择 290\n10.4　集群伸缩 291\n10.4.1　伸缩原理 291\n10.4.2　扩容集群 293\n10.4.3　收缩集群 301\n10.5　请求路由 305\n10.5.1　请求重定向 305\n10.5.2　Smart客户端 309\n10.5.3　ASK重定向 318\n10.6　故障转移 323\n10.6.1　故障发现 323\n10.6.2　故障恢复 329\n10.6.3　故障转移时间 334\n10.6.4　故障转移演练 334\n10.7　集群运维 336\n10.7.1　集群完整性 336\n10.7.2　带宽消耗 337\n10.7.3　Pub/Sub广播问题 337\n10.7.4　集群倾斜 338\n10.7.5　集群读写分离 339\n10.7.6　手动故障转移 341\n10.7.7　数据迁移 344\n10.8　本章重点回顾 344\n第11章　缓存设计 346\n11.1　缓存的收益和成本 346\n11.2　缓存更新策略 347\n11.3　缓存粒度控制 349\n11.4　穿透优化 350\n11.5　无底洞优化 352\n11.6　雪崩优化 359\n11.7　热点key重建优化 360\n11.8　本章重点回顾 364\n第12章　开发运维的“陷阱” 365\n12.1　Linux配置优化 365\n12.1.1　内存分配控制 365\n12.1.2　swappiness 367\n12.1.3　THP 369\n12.1.4　OOM killer 370\n12.1.5　使用NTP 371\n12.1.6　ulimit 371\n12.1.7　TCP backlog 372\n12.2　flushall/flushdb误操作 372\n12.2.1　缓存与存储 373\n12.2.2　借助AOF机制恢复 373\n12.2.3　RDB有什么变化 374\n12.2.4　从节点有什么变化 374\n12.2.5　快速恢复数据 374\n12.3　安全的Redis 375\n12.3.1　Redis密码机制 377\n12.3.2　伪装危险命令 378\n12.3.3　防火墙 380\n12.3.4　bind 380\n12.3.5　定期备份数据 381\n12.3.6　不使用默认端口 381\n12.3.7　使用非root用户启动 381\n12.4　处理bigkey 382\n12.4.1　bigkey的危害 382\n12.4.2　如何发现 382\n12.4.3　如何删除 383\n12.4.4　最佳实践思路 386\n12.5　寻找热点key 386\n12.6　本章重点回顾 391\n第13章　Redis监控运维云平台CacheCloud 392\n13.1　CacheCloud是什么 392\n13.1.1　现有问题 393\n13.1.2　CacheCloud基本功能 393\n13.2　快速部署 395\n13.2.1　CacheCloud环境需求 395\n13.2.2　CacheCloud快速开始 395\n13.3　机器部署 397\n13.3.1　部署脚本 398\n13.3.2　添加机器 399\n13.4　接入应用 400\n13.4.1　总体流程 401\n13.4.2　账户申请和审批 401\n13.4.3　应用申请和审批 402\n13.4.4　客户端接入 405\n13.5　用户功能 407\n13.5.1　应用统计信息 408\n13.5.2　实例列表 409\n13.5.3　应用详情 409\n13.5.4　命令曲线 409\n13.5.5　CacheCloud Redis Shell控制台 410\n13.5.6　慢查询 410\n13.5.7　应用拓扑 411\n13.6　运维功能 413\n13.6.1　应用运维 413\n13.6.2　接入已存在的Redis节点 415\n13.6.3　Redis配置模板 416\n13.6.4　迁移工具 417\n13.6.5　监控报警 420\n13.6.6　系统配置管理 422\n13.7　客户端上报 423\n13.7.1　客户端上报整体设计 424\n13.7.2　Jedis核心代码修改 424\n13.7.3　带上报功能的客户端 426\n13.7.4　CacheCloud客户端统计 427\n13.8　本章重点回顾 429\n第14章　Redis配置统计字典 430\n14.1　info系统状态说明 430\n14.1.1　命令说明 430\n14.1.2　详细说明 431\n14.2　standalone配置说明和分析 436\n14.2.1　总体配置 436\n14.2.2　最大内存及策略 437\n14.2.3　AOF相关配置 437\n14.2.4　RDB相关配置 438\n14.2.5　慢查询配置 438\n14.2.6　数据结构优化配置 439\n14.2.7　复制相关配置 439\n14.2.8　客户端相关配置 440\n14.2.9　安全相关配置 440\n14.3　Sentinel配置说明和分析 440\n14.4　Cluster配置说明和分析 441",
    "ebook_url": "https://read.douban.com/ebook/30898272/",
    "pages": "",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29335561.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29335561.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29335561.jpg"
    },
    "alt": "https://book.douban.com/subject/26971561/",
    "id": "26971561",
    "publisher": "机械工业出版社",
    "isbn10": "7111557972",
    "isbn13": "9787111557975",
    "title": "Redis开发与运维",
    "url": "https://api.douban.com/v2/book/26971561",
    "alt_title": "",
    "author_intro": "付磊 搜狐视频高级研发工程师，CacheCloud项目联合创始人。拥有多年Redis开发运维经验，为公司多个核心业务提供Redis服务，同时热衷于技术传播和分享，撰写了大量关于Redis开发运维的技术文章。微博号carlosfl，博客地址是http://carlosfu.iteye.com。\n张益军 搜狐视频资深研发工程师，CacheCloud项目联合创始人，曾就职于美团、阿里巴巴等公司。搜狐视频投放组负责人，目前从事投放平台、反作弊等系统的架构设计和优化工作。研究兴趣包括海量峰值访问、分布式存储等。微博号益军YJ, 博客地址是http://hot66hot.iteye.com。",
    "summary": "本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。",
    "ebook_price": "30.00",
    "series": { "id": "25452", "title": "数据库技术丛书" },
    "price": "89.00"
  },
  "9787111464747": {
    "rating": { "max": 10, "numRaters": 656, "average": "8.5", "min": 0 },
    "subtitle": "",
    "author": ["黄健宏"],
    "pubdate": "2014-6",
    "tags": [
      { "count": 718, "name": "Redis", "title": "Redis" },
      { "count": 399, "name": "数据库", "title": "数据库" },
      { "count": 205, "name": "计算机", "title": "计算机" },
      { "count": 197, "name": "源码分析", "title": "源码分析" },
      { "count": 122, "name": "redis", "title": "redis" },
      { "count": 119, "name": "编程", "title": "编程" },
      { "count": 101, "name": "NoSQL", "title": "NoSQL" },
      { "count": 73, "name": "database", "title": "database" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27297117.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章 引言\t1\n1.1 Redis版本说明\t1\n1.2 章节编排\t1\n1.3 推荐的阅读方法\t4\n1.4 行文规则\t4\n1.5 配套网站\t5\n第一部分 数据结构与对象\n第2章 简单动态字符串\t8\n2.1 SDS的定义\t9\n2.2 SDS与C字符串的区别\t10\n2.3 SDS API\t17\n2.4 重点回顾\t18\n2.5 参考资料\t18\n第3章 链表\t19\n3.1 链表和链表节点的实现\t20\n3.2 链表和链表节点的API\t21\n3.3 重点回顾\t22\n第4章 字典\t23\n4.1 字典的实现\t24\n4.2 哈希算法\t27\n4.3 解决键冲突\t28\n4.4 rehash \t29\n4.5 渐进式rehash\t32\n4.6 字典API\t36\n4.7 重点回顾\t37\n第5章 跳跃表\t38\n5.1 跳跃表的实现\t39\n5.2 跳跃表API\t44\n5.3 重点回顾\t45\n第6章 整数集合\t46\n6.1 整数集合的实现\t46\n6.2 升级\t48\n6.3 升级的好处\t50\n6.4 降级\t51\n6.5 整数集合API\t51\n6.6 重点回顾\t51\n第7章 压缩列表\t52\n7.1 压缩列表的构成\t52\n7.2 压缩列表节点的构成\t54\n7.3 连锁更新\t57\n7.4 压缩列表API\t59\n7.5 重点回顾\t59\n第8章 对象\t60\n8.1 对象的类型与编码\t60\n8.2 字符串对象\t64\n8.3 列表对象\t68\n8.4 哈希对象\t71\n8.5 集合对象\t75\n8.6 有序集合对象\t77\n8.7 类型检查与命令多态\t81\n8.8 内存回收\t84\n8.9 对象共享\t85\n8.10 对象的空转时长\t87\n8.11 重点回顾\t88\n第二部分 单机数据库的实现\n第9章 数据库\t90\n9.1 服务器中的数据库\t90\n9.2 切换数据库\t91\n9.3 数据库键空间\t93\n9.4 设置键的生存时间或过期时间\t99\n9.5 过期键删除策略\t107\n9.6 Redis的过期键删除策略\t108\n9.7 AOF、RDB和复制功能对过期键的处理\t111\n9.8 数据库通知\t113\n9.9 重点回顾\t117\n第10章 RDB持久化\t118\n10.1 RDB 文件的创建与载入\t119\n10.2 自动间隔性保存\t121\n10.3 RDB 文件结构\t125\n10.4 分析RDB文件\t133\n10.5 重点回顾\t137\n10.6 参考资料\t137\n第11章 AOF持久化\t138\n11.1 AOF持久化的实现\t139\n11.2 AOF文件的载入与数据还原\t142\n11.3 AOF重写\t143\n11.4 重点回顾\t150\n第12章 事件\t151\n12.1 文件事件\t151\n12.2 时间事件\t156\n12.3 事件的调度与执行\t159\n12.4 重点回顾\t161\n12.5 参考资料\t161\n第13章 客户端\t162\n13.1 客户端属性\t163\n13.2 客户端的创建与关闭\t172\n13.3 重点回顾\t174\n第14章 服务器\t176\n14.1 命令请求的执行过程\t176\n14.2 serverCron函数\t184\n14.3 初始化服务器\t192\n14.4 重点回顾\t196\n第三部分 多机数据库的实现\n第15章 复制\t198\n15.1 旧版复制功能的实现\t199\n15.2 旧版复制功能的缺陷\t201\n15.3 新版复制功能的实现\t203\n15.4 部分重同步的实现\t204\n15.5 PSYNC 命令的实现\t209\n15.6 复制的实现\t211\n15.7 心跳检测\t216\n15.8 重点回顾\t218\n第16章 Sentinel\t219\n16.1 启动并初始化Sentinel \t220\n16.2 获取主服务器信息\t227\n16.3 获取从服务器信息\t229\n16.4 向主服务器和从服务器发送信息\t230\n16.5 接收来自主服务器和从服务器的频道信息\t231\n16.6 检测主观下线状态\t234\n16.7 检查客观下线状态\t236\n16.8 选举领头Sentinel \t238\n16.9 故障转移\t240\n16.10 重点回顾\t243\n16.11 参考资料\t244\n第17章 集群\t245\n17.1 节点\t245\n17.2 槽指派\t251\n17.3 在集群中执行命令\t258\n17.4 重新分片\t265\n17.5 ASK错误\t267\n17.6 复制与故障转移\t273\n17.7 消息\t281\n17.8 重点回顾\t288\n第四部分 独立功能的实现\n第18章 发布与订阅\t290\n18.1 频道的订阅与退订\t292\n18.2 模式的订阅与退订\t295\n18.3 发送消息\t298\n18.4 查看订阅信息\t300\n18.5 重点回顾\t303\n18.6 参考资料\t304\n第19章 事务\t305\n19.1 事务的实现\t306\n19.2 WATCH 命令的实现\t310\n19.3 事务的ACID 性质\t314\n19.4 重点回顾\t319\n19.5 参考资料\t320\n第20章 Lua脚本\t321\n20.1 创建并修改Lua 环境\t322\n20.2 Lua 环境协作组件\t327\n20.3 EVAL命令的实现\t329\n20.4 EVALSHA 命令的实现\t332\n20.5 脚本管理命令的实现\t333\n20.6 脚本复制\t336\n20.7 重点回顾\t342\n20.8 参考资料\t343\n第21章 排序\t344\n21.1 SORT <key> 命令的实现\t345\n21.2 ALPHA 选项的实现\t347\n21.3 ASC 选项和DESC 选项的实现\t348\n21.4 BY选项的实现\t350\n21.5 带有ALPHA 选项的BY 选项的实现\t352\n21.6 LIMIT 选项的实现\t353\n21.7 GET选项的实现\t355\n21.8 STORE 选项的实现\t358\n21.9 多个选项的执行顺序\t359\n21.10 重点回顾\t361\n第22章 二进制位数组\t362\n22.1 位数组的表示\t363\n22.2 GETBIT命令的实现\t365\n22.3 SETBIT 命令的实现\t366\n22.4 BITCOUNT 命令的实现\t369\n22.5 BITOP 命令的实现\t376\n22.6 重点回顾\t377\n22.7 参考资料\t377\n第23章 慢查询日志\t378\n23.1 慢查询记录的保存\t380\n23.2 慢查询日志的阅览和删除\t382\n23.3 添加新日志\t383\n23.4 重点回顾\t385\n第24章 监视器\t386\n24.1 成为监视器\t387\n24.2 向监视器发送命令信息\t387\n24.3 重点回顾\t388",
    "ebook_url": "https://read.douban.com/ebook/7519526/",
    "pages": "388",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27297117.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27297117.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27297117.jpg"
    },
    "alt": "https://book.douban.com/subject/25900156/",
    "id": "25900156",
    "publisher": "机械工业出版社",
    "isbn10": "7111464745",
    "isbn13": "9787111464747",
    "title": "Redis设计与实现",
    "url": "https://api.douban.com/v2/book/25900156",
    "alt_title": "",
    "author_intro": "黄健宏 软件开发者，他喜欢函数式编程，热爱开源软件。出于对数据库的强烈兴趣，他开始阅读和分析 Redis 源代码，并对 Redis 2.6 和 Redis 3.0 的源代码进行了详细注释。他翻译并维护着 Redis 中文文档网站 www.RedisDoc .com ，编写 了 OORedis 库。除此之外，他还是《Redis in Action》一书的译者。\n作者的豆瓣主页：douban.com/people/i_m_huangz/",
    "summary": "【官方网站】\n本书的官方网站 www.RedisBook.com 提供了书本试读、相关源码下载和勘误回报等服务，欢迎读者浏览和使用。\n【编辑推荐】\n系统而全面地描述了 Redis 内部运行机制\n图示丰富，描述清晰，并给出大量参考信息，是NoSQL数据库开发人员案头必备\n包括大部分Redis单机特征，以及所有多机特性\n【读者评价】\n这本书描述的知识点很丰富，覆盖很全，里面提到特性较多，有不少我们也没用过 :) 每个命令内部的机制的介绍很不错，很多估计也是首次有详细文档介绍。\n——杨卫华（@TimYang）新浪微博技术总监\n近几年Redis以其高性能、高灵活性的优点，变得越来越流行。但很多人在使用Redis时，仅仅还是停留在比较表层的功能性认识，缺乏对内部机制原理的深入理解。本书是huangz同学长期对Redis源码的阅读心得结晶，书中对Redis的各个方面都进行了详细且深入的讲解，将复杂的原理用最简单的方式为大家解构和讲解，强烈推荐给每一位Redis的使用者阅读。\n—— iammutex，NoSQLFan站长，乐视网技术经理\nRedis 是近些年来特别火爆的 NoSQL 之一。纵观中外各种书籍还没有一本能对 Redis 内部进行深入剖析，《Redis 设计与实现》可谓开此先河。常和作者在网上交流，知道作者为这本书付出了大量的心血。这本书行文流畅，思路清晰，详细地介绍了 Redis 源码的方方面面。无论是想学习 NoSQL、网络编程的初学者，还是源码控的进阶者，本书都会有很大的帮助。\n—— 阮若夷，支付宝高级专家\n【内容简介】\n本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。\n本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。本书作者专门维护了www.redisbook.com网站，提供带有详细注释的Redis源代码，以及本书相关的更新内容。",
    "ebook_price": "30.00",
    "series": { "id": "25452", "title": "数据库技术丛书" },
    "price": "79.00"
  },
  "9787115261274": {
    "rating": { "max": 10, "numRaters": 225, "average": "8.4", "min": 0 },
    "subtitle": "",
    "author": ["[美] Bill Karwin"],
    "pubdate": "2011-9",
    "tags": [
      { "count": 412, "name": "SQL", "title": "SQL" },
      { "count": 334, "name": "数据库", "title": "数据库" },
      { "count": 126, "name": "数据库设计", "title": "数据库设计" },
      { "count": 73, "name": "计算机", "title": "计算机" },
      { "count": 69, "name": "反模式", "title": "反模式" },
      { "count": 61, "name": "编程", "title": "编程" },
      { "count": 44, "name": "DataBase", "title": "DataBase" },
      { "count": 38, "name": "计算机科学", "title": "计算机科学" }
    ],
    "origin_title": "SQL Antipatterns: Avoiding the Pitfalls of Database Programming",
    "image": "https://img1.doubanio.com/view/subject/m/public/s8846357.jpg",
    "binding": "平装",
    "translator": ["谭振林", "Push Chen"],
    "catalog": "第1 章 引言　　1\n1.1 谁需要这本书　　2\n1.2 本书内容　　2\n1.2.1 本书结构　　3\n1.2.2 反模式分解　　4\n1.3 本书未涉及的内容　　4\n1.4 规约　　5\n1.5 范例数据库　　6\n1.6 致谢　　8\n第一部分 逻辑型数据库设计反模式\n第2 章 乱穿马路　　10\n2.1 目标：存储多值属性　　11\n2.2 反模式：格式化的逗号分隔列表　　11\n2.2.1 查询指定账号的产品　　11\n2.2.2 查询指定产品的账号　　12\n2.2.3 执行聚合查询　　12\n2.2.4 更新指定产品的账号　　12\n2.2.5 验证产品ID 　　13\n2.2.6 选择合适的分隔符　　13\n2.2.7 列表长度限制　　13\n2.3 如何识别反模式　　14\n2.4 合理使用反模式　　14\n2.5 解决方案：创建一张交叉表　　14\n2.5.1 通过账号查询产品和反过来查询　　15\n2.5.2 执行聚合查询　　16\n2.5.3 更新指定产品的相关联系人　　16\n2.5.4 验证产品ID 　　16\n2.5.5 选择分隔符　　17\n2.5.6 列表长度限制　　 17\n2.5.7 其他使用交叉表的好处　　17\n第3 章 单纯的树　　18\n3.1 目标：分层存储与查询　　18\n3.2 反模式：总是依赖父节点　　 19\n3.2.1 使用邻接表查询树　　 20\n3.2.2 使用邻接表维护树　　 21\n3.3 如何识别反模式　　22\n3.4 合理使用反模式　　23\n3.5 解决方案：使用其他树模型　　 24\n3.5.1 路径枚举　　24\n3.5.2 嵌套集　　26\n3.5.3 闭包表　　29\n3.5.4 你该使用哪种设计　　 33\n第4 章 需要ID　　 34\n4.1 目标：建立主键规范　　 35\n4.2 反模式：以不变应万变　　36\n4.2.1 冗余键值　　 36\n4.2.2 允许重复项　　 37\n4.2.3 意义不明的关键字　　 38\n4.2.4 使用USING 关键字　　 38\n4.2.5 使用组合键之难　　39\n4.3 如何识别反模式　　 39\n4.4 合理使用反模式　　40\n4.5 解决方案：裁剪设计　　 40\n4.5.1 直截了当地描述设计　　40\n4.5.2 打破传统　　 41\n4.5.3 拥抱自然键和组合键　　41\n第5 章 不用钥匙的入口　　43\n5.1 目标：简化数据库架构　　43\n5.2 反模式：无视约束　　44\n5.2.1 假设无瑕代码　　44\n5.2.2 检查错误　　45\n5.2.3 “那不是我的错！”　　45\n5.2.4 进退维谷　　　46\n5.3 如何识别反模式　　46\n5.4 合理使用反模式　　47\n5.5 解决方案：声明约束　　47\n5.5.1 支持同步修改　　48\n5.5.2 系统开销过度？不见得　　48\n第6 章 实体—属性—值　　50\n6.1 目标：支持可变的属性　　50\n6.2 反模式：使用泛型属性表　　51\n6.2.1 查询属性　　53\n6.2.2 支持数据完整性　　53\n6.2.3 无法声明强制属性　　53\n6.2.4 无法使用SQL 的数据类型　　53\n6.2.5 无法确保引用完整性　　54\n6.2.6 无法配置属性名　　55\n6.2.7 重组列　　55\n6.3 如何识别反模式　　56\n6.4 合理使用反模式　　56\n6.5 解决方案：模型化子类型　　57\n6.5.1 单表继承　　57\n6.5.2 实体表继承　　58\n6.5.3 类表继承　　60\n6.5.4 半结构化数据模型　　61\n6.5.5 后处理　　61\n第7 章 多态关联　　64\n7.1 目标：引用多个父表　　65\n7.2 反模式：使用双用途外键　　65\n7.2.1 定义多态关联　　65\n7.2.2 使用多态关联进行查询　　66\n7.2.3 非面向对象范例　　67\n7.3 如何识别反模式　　68\n7.4 合理使用反模式　　69\n7.5 解决方案：让关系变得简单　　 69\n7.5.1 反向引用　　69\n7.5.2 创建交叉表　　 69\n7.5.3 设立交通灯　　 70\n7.5.4 双向查找　　71\n7.5.5 合并跑道　　71\n7.5.6 创建共用的超级表　　 72\n第8 章 多列属性　　 75\n8.1 目标：存储多值属性　　 75\n8.2 反模式：创建多个列　　 76\n8.2.1 查询数据　　76\n8.2.2 添加及删除值　　 77\n8.2.3 确保唯一性　　 78\n8.2.4 处理不断增长的值集　　78\n8.3 如何识别反模式　　79\n8.4 合理使用反模式　　79\n8.5 解决方案：创建从属表　　80\n第9 章 元数据分裂　　　82\n9.1 目标：支持可扩展性　　 83\n9.2 反模式：克隆表与克隆列　　 83\n9.2.1 不断产生的新表　　 84\n9.2.2 管理数据完整性　　 84\n9.2.3 同步数据　　 85\n9.2.4 确保唯一性　　 85\n9.2.5 跨表查询　　 86\n9.2.6 同步元数据　　 86\n9.2.7 管理引用完整性　　 86\n9.2.8 标识元数据分裂列　　 87\n9.3 如何识别反模式　　87\n9.4 合理使用反模式　　88\n9.5 解决方案：分区及标准化　　 89\n9.5.1 使用水平分区　　 89\n9.5.2 使用垂直分区　　 89\n9.5.3 解决元数据分裂列　　 91\n第二部分 物理数据库设计反模式\n第10 章 取整错误　　 94\n10.1 目标：使用小数取代整数　　 94\n10.2 反模式：使用FLOAT 类型　　95\n10.2.1 舍入的必要性　　95\n10.2.2 在SQL 中使用FLOAT　　96\n10.3 如何识别反模式　　98\n10.4 合理使用反模式　　98\n10.5 解决方案：使用NUMERIC 类型　　98\n第11 章 每日新花样　　100\n11.1 目标：限定列的有效值　　100\n11.2 反模式：在列定义上指定可选值　　101\n11.2.1 中间的是哪个　　102\n11.2.2 添加新口味　　103\n11.2.3 老的口味永不消失　　103\n11.2.4 可移植性低下　　103\n11.3 如何识别反模式　　104\n11.4 合理使用反模式　　104\n11.5 解决方案：在数据中指定值　　104\n11.5.1 查询候选值集合　　105\n11.5.2 更新检查表中的值　　105\n11.5.3 支持废弃数据　　105\n11.5.4 良好的可移植性　　106\n第12 章 幽灵文件　　107\n12.1 目标：存储图片或其他多媒体大文件　　107\n12.2 反模式：假设你必须使用文件系统　　108\n12.2.1 文件不支持DELETE　　109\n12.2.2 文件不支持事务隔离　　109\n12.2.3 文件不支持回滚操作　　109\n12.2.4 文件不支持数据库备份工具　　110\n12.2.5 文件不支持SQL 的访问权限设置　　110\n12.2.6 文件不是SQL 数据类型　　110\n12.3 如何识别反模式　　111\n12.4 合理使用反模式　　111\n12.5 解决方案：在需要时使用BLOB 类型　　112\n第13 章 乱用索引　　114\n13.1 目标：优化性能　　115\n13.2 反模式：无规划地使用索引　　115\n13.2.1 无索引　　115\n13.2.2 索引过多　　116\n13.2.3 索引也无能为力　　117\n13.3 如何识别反模式　　118\n13.4 合理使用反模式　　119\n13.5 解决方案：MENTOR 你的索引　　119\n13.5.1 测量　　120\n13.5.2 解释　　121\n13.5.3 挑选　　122\n13.5.4 测试　　123\n13.5.5 优化　　123\n13.5.6 重建　　123\n第三部分 查询反模式\n第14 章 对未知的恐惧　　126\n14.1 目标：辨别悬空值　　127\n14.2 反模式：将NULL 作为普通的值，反之亦然　　127\n14.2.1 在表达式中使用NULL 　　127\n14.2.2 搜索允许为空的列　　128\n14.2.3 在查询参数中使用NULL 　　128\n14.2.4 避免上述问题　　128\n14.3 如何识别反模式　　130\n14.4 合理使用反模式　　130\n14.5 解决方案：将NULL 视为特殊值　　131\n14.5.1 在标量表达式中使用NULL 　　131\n14.5.2 在布尔表达式中使用NULL 　　132\n14.5.3 检索NULL 值　　132\n14.5.4 声明NOT NULL 的列　　133\n14.5.5 动态默认值　　134\n第15 章 模棱两可的分组　　135\n15.1 目标：获取每组的最大值　　135\n15.2 反模式：引用非分组列　　136\n15.2.1 单值规则　　136\n15.2.2 我想要的查询　　137\n15.3 如何识别反模式　　138\n15.4 合理使用反模式　　139\n15.5 解决方案：无歧义地使用列　　140\n15.5.1 只查询功能依赖的列　　140\n15.5.2 使用关联子查询　　140\n15.5.3 使用衍生表　　140\n15.5.4 使用JOIN　　141\n15.5.5 对额外的列使用聚合函数　　142\n15.5.6 连接同组所有值　　142\n第16 章 随机选择　　144\n16.1 目标：获取样本记录　　144\n16.2 反模式：随机排序　　145\n16.3 如何识别反模式　　146\n16.4 合理使用反模式　　146\n16.5 解决方案：没有具体的顺序　　146\n16.5.1 从1 到最大值之间随机选择　　146\n16.5.2 选择下一个最大值　　147\n16.5.3 获取所有的键值，随机选择一个　　147\n16.5.4 使用偏移量选择随机行　　148\n16.5.5 专有解决方案　　149\n第17 章 可怜人的搜索引擎　　150\n17.1 目标：全文搜索　　150\n17.2 反模式：模式匹配断言　　151\n17.3 如何识别反模式　　152\n17.4 合理使用反模式　　152\n17.5 解决方案：使用正确的工具　　152\n17.5.1 数据库扩展　　153\n17.5.2 第三方搜索引擎　　157\n第18 章 意大利面条式查询　　162\n18.1 目标：减少SQL 查询数量　　162\n18.2 反模式：使用一步操作解决复杂问题　　163\n18.2.1 副作用　　163\n18.2.2 那好像还不够???? 　　164\n18.3 如何识别反模式　　165\n18.4 合理使用反模式　　165\n18.5 解决方案：分而治之　　166\n18.5.1 一步一个脚印　　166\n18.5.2 寻找UNION 标记　　167\n18.5.3 解决老板的问题　　167\n18.5.4 使用SQL 自动生成SQL 　　168\n第19 章 隐式的列　　 170\n19.1 目标：减少输入　　 171\n19.2 反模式：捷径会让你迷失方向　　 171\n19.2.1 破坏代码重构　　171\n19.2.2 隐藏的开销　　172\n19.2.3 你请求，你获得　　172\n19.3 如何识别反模式　　 173\n19.4 合理使用反模式　　 173\n19.5 解决方案：明确列出列名　　174\n19.5.1 预防错误　　174\n19.5.2 你不需要它　　 175\n19.5.3 无论如何你都需要放弃使用通配符　　 175\n第四部分 应用程序开发反模式\n第20 章 明文密码　　　178\n20.1 目标：恢复或重置密码　　 178\n20.2 反模式：使用明文存储密码　　 179\n20.2.1 存储密码　　179\n20.2.2 验证密码　　180\n20.2.3 在E-mail 中发送密码　　180\n20.3 如何识别反模式　　 181\n20.4 合理使用反模式　　 181\n20.5 解决方案：先哈希，后存储　　 182\n20.5.1 理解哈希函数　　182\n20.5.2 在SQL 中使用哈希　　 183\n20.5.3 给哈希加料　　183\n20.5.4 在SQL 中隐藏密码　　 185\n20.5.5 重置密码，而非恢复密码　　 186\n第21 章 SQL 注入　　188\n21.1 目标：编写SQL 动态查询　　189\n21.2 反模式：将未经验证的输入作为代码执行　　189\n21.2.1 意外无处不在　　 190\n21.2.2 对Web 安全的严重威胁　　 190\n21.2.3 寻找治愈良方　　 191\n21.3 如何识别反模式　　 195\n21.4 合理使用反模式　　 196\n21.5 解决方案：不信任任何人　　196\n21.5.1 过滤输入内容　　196\n21.5.2 参数化动态内容　　197\n21.5.3 给动态输入的值加引号　　197\n21.5.4 将用户与代码隔离　　198\n21.5.5 找个可靠的人来帮你审查代码　　200\n第22 章 伪键洁癖　　202\n22.1 目标：整理数据　　202\n22.2 反模式：填充角落　　203\n22.2.1 不按照顺序分配编号　　203\n22.2.2 为现有行重新编号　　204\n22.2.3 制造数据差异　　204\n22.3 如何识别反模式　　205\n22.4 合理使用反模式　　205\n22.5 解决方案：克服心里障碍　　205\n22.5.1 定义行号　　205\n22.5.2 使用GUID　　206\n22.5.3 最主要的问题　　207\n第23 章 非礼勿视　　209\n23.1 目标：写更少的代码　　210\n23.2 反模式：无米之炊　　210\n23.2.1 没有诊断的诊断　　210\n23.2.2 字里行间　　211\n23.3 如何识别反模式　　212\n23.4 合理使用反模式　　213\n23.5 解决方案：优雅地从错误中恢复　　213\n23.5.1 保持节奏　　213\n23.5.2 回溯你的脚步　　214\n第24 章 外交豁免权　　215\n24.1 目标：采用最佳实践　　215\n24.2 反模式：将SQL 视为二等公民　　216\n24.3 如何识别反模式　　216\n24.4 合理使用反模式　　217\n24.5 解决方案：建立一个质量至上的文化　　217\n24.5.1 陈列A：编写文档　　218\n24.5.2 寻找证据：源代码版本控制　　220\n24.5.3 举证：测试　　222\n24.5.4 例证：同时处理多个分支　　223\n第25 章 魔豆　　225\n25.1 目标：简化MVC 的模型　　226\n25.2 反模式：模型仅仅是活动记录　　227\n25.2.1 活动记录模式连接程序模型和数据库结构　　228\n25.2.2 活动记录模式暴露了CRUD系列函数　　228\n25.2.3 活动记录模式支持弱域模型　　229\n25.2.4 魔豆难以进行单元测试　　231\n25.3 如何识别反模式　　232\n25.4 合理使用反模式　　232\n25.5 解决方案：模型包含活动记录　　232\n25.5.1 领会模型的意义　　233\n25.5.2 将领域模型应用到实际工作中　　234\n25.5.3 测试简单对象　　236\n25.5.4 回到地球　　237\n第五部分 附录\n附录A 规范化规则　　240\n附录B 参考书目　　252",
    "pages": "253",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s8846357.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s8846357.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s8846357.jpg"
    },
    "alt": "https://book.douban.com/subject/6800774/",
    "id": "6800774",
    "publisher": "人民邮电出版社",
    "isbn10": "711526127X",
    "isbn13": "9787115261274",
    "title": "SQL反模式",
    "url": "https://api.douban.com/v2/book/6800774",
    "alt_title": "SQL Antipatterns: Avoiding the Pitfalls of Database Programming",
    "author_intro": "Bill Karwin作为软件工程师、咨询师和管理者，他在20年间开发并支持了各种各样的应用、程序库以及服务器，如PHP 5的Zend Framework, Interbase关系型数据库，以及Enhydra Java应用服务器等。他一直无私地分享他的专业知识，来帮助其他程序员提高效率、获得成功。他曾以各种方式回答了上千个关于SQL的疑问，其中不乏一些 严重但又经常被忽略的问题。",
    "summary": "《SQL反模式》是一本广受好评的SQL图书。它介绍了如何避免在SQL的使用和开发中陷入一些常见却经常被忽略的误区。它通过讲述各种具体的案例，以及开发人员和使用人员在面对这些案例时经常采用的错误解决方案，来介绍如何识别、利用这些陷阱，以及面对问题时正确的解决手段。另外，《SQL反模式》还涉及了SQL的各级范式和针对它们的正确理解。\n《SQL反模式》适合SQL数据库开发人员与管理人员阅读。",
    "series": { "id": "28522", "title": "图灵程序设计丛书·数据库系列" },
    "price": "59.00元"
  },
  "9787121198854": {
    "rating": { "max": 10, "numRaters": 455, "average": "9.4", "min": 0 },
    "subtitle": "第3版",
    "author": [
      "施瓦茨 (Baron Schwartz)",
      "扎伊采夫 (Peter Zaitsev)",
      "特卡琴科 (Vadim Tkachenko)"
    ],
    "pubdate": "2013-5-1",
    "tags": [
      { "count": 850, "name": "MySQL", "title": "MySQL" },
      { "count": 569, "name": "数据库", "title": "数据库" },
      { "count": 280, "name": "高性能MySQL", "title": "高性能MySQL" },
      { "count": 195, "name": "计算机", "title": "计算机" },
      { "count": 119, "name": "mysql", "title": "mysql" },
      { "count": 105, "name": "编程", "title": "编程" },
      { "count": 94, "name": "计算机科学", "title": "计算机科学" },
      { "count": 66, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "High Performance MySQL,3rd",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27783358.jpg",
    "binding": "平装",
    "translator": ["宁海元", "周振兴", "彭立勋", "翟卫祥,刘辉"],
    "catalog": "推荐序 xxiii\n前言 xxv\n第1 章 mysql 架构与历史 1\n1.1 mysql 逻辑架构 1\n1.1.1 连接管理与安全性2\n1.1.2 优化与执行 3\n1.2 并发控制 3\n1.2.1 读写锁 4\n1.2.2 锁粒度 4\n1.3 事务6\n1.3.1 隔离级别 8\n1.3.2 死锁 9\n1.3.3 事务日志 10\n1.3.4 mysql 中的事务 10\n1.4 多版本并发控制 12\n1.5 mysql 的存储引擎 13\n1.5.1 innodb 存储引擎 16\n1.5.2 myisam 存储引擎 17\n1.5.3 mysql 内建的其他存储引擎 19\n.1.5.4 第三方存储引擎 22\n1.5.5 选择合适的引擎 24\n1.5.6 转换表的引擎 27\n1.6 mysql 时间线（timeline） 29\n1.7 mysql 的开发模式 32\n1.8 总结 33\n第2 章 mysql 基准测试 35\n2.1 为什么需要基准测试 35\n2.2 基准测试的策略 37\n2.2.1 测试何种指标 38\n2.3 基准测试方法 40\n2.3.1 设计和规划基准测试 41\n2.3.2 基准测试应该运行多长时间 42\n2.3.3 获取系统性能和状态 43\n2.3.4 获得准确的测试结果 44\n2.3.5 运行基准测试并分析结果 46\n2.3.6 绘图的重要性 47\n2.4 基准测试工具 49\n2.4.1 集成式测试工具 49\n2.4.2 单组件式测试工具 50\n2.5 基准测试案例 52\n2.5.1 http_load 53\n2.5.2 mysql 基准测试套件 54\n2.5.3 sysbench 55\n2.5.4 数据库测试套件中的dbt2 tpc-c 测试 60\n2.5.5 percona 的tpcc-mysql 测试工具 63\n2.6 总结 65\n第3 章 服务器性能剖析 67\n3.1 性能优化简介 67\n3.1.1 通过性能剖析进行优化 69\n3.1.2 理解性能剖析 71\n3.2 对应用程序进行性能剖析 72\n3.2.1 测量php 应用程序 74\n3.3 剖析mysql 查询 77\n3.3.1 剖析服务器负载 77\n3.3.2 剖析单条查询 81\n3.3.3 使用性能剖析 87\n3.4 诊断间歇性问题 88\n3.4.1 单条查询问题还是服务器问题 89\n3.4.2 捕获诊断数据 93\n3.4.3 一个诊断案例 98\n3.5 其他剖析工具 106\n3.5.1 使用user_statistics 表 106\n3.5.2 使用strace 107\n3.6 总结 108\n第4 章 schema 与数据类型优化 111\n4.1 选择优化的数据类型 111\n4.1.1 整数类型 113\n4.1.2 实数类型 113\n4.1.3 字符串类型 114\n4.1.4 日期和时间类型 121\n4.1.5 位数据类型 123\n4.1.6 选择标识符（identifier） 125\n4.1.7 特殊类型数据 127\n4.2 mysql schema 设计中的陷阱 127\n4.3 范式和反范式 129\n4.3.1 范式的优点和缺点 130\n4.3.2 反范式的优点和缺点 130\n4.3.3 混用范式化和反范式化 131\n4.4 缓存表和汇总表 132\n4.4.1 物化视图 134\n4.4.2 计数器表 135\n4.5 加快alter table 操作的速度 136\n4.5.1 只修改.frm 文件 137\n4.5.2 快速创建myisam 索引 139\n4.6 总结 140\n第5 章 创建高性能的索引 141\n5.1 索引基础 141\n5.1.1 索引的类型 142\n5.2 索引的优点 152\n5.3 高性能的索引策略 153\n5.3.1 独立的列 153\n5.3.2 前缀索引和索引选择性 153\n5.3.3 多列索引 157\n5.3.4 选择合适的索引列顺序 159\n5.3.5 聚簇索引 162\n5.3.6 覆盖索引 171\n5.3.7 使用索引扫描来做排序 175\n5.3.8 压缩（前缀压缩）索引 177\n5.3.9 冗余和重复索引 178\n5.3.10 未使用的索引 181\n5.3.11 索引和锁 181\n5.4 索引案例学习 183\n5.4.1 支持多种过滤条件 183\n5.4.2 避免多个范围条件 185\n5.4.3 优化排序 186\n5.5 维护索引和表 187\n5.5.1 找到并修复损坏的表 187\n5.5.2 更新索引统计信息 188\n5.5.3 减少索引和数据的碎片 190\n5.6 总结 192\n第6 章 查询性能优化 195\n6.1 为什么查询速度会慢 195\n6.2 慢查询基础：优化数据访问 196\n6.2.1 是否向数据库请求了不需要的数据 196\n6.2.2 mysql 是否在扫描额外的记录 198\n6.3 重构查询的方式 201\n6.3.1 一个复杂查询还是多个简单查询 201\n6.3.2 切分查询 202\n6.3.3 分解关联查询 203\n6.4 查询执行的基础 204\n6.4.1 mysql 客户端/ 服务器通信协议 205\n6.4.2 查询缓存 208\n6.4.3 查询优化处理 208\n6.4.4 查询执行引擎 222\n6.4.5 返回结果给客户端 223\n6.5 mysql 查询优化器的局限性 223\n6.5.1 关联子查询 223\n6.5.2 union 的限制 228\n6.5.3 索引合并优化 228\n6.5.4 等值传递 229\n6.5.5 并行执行 229\n6.5.6 哈希关联 229\n6.5.7 松散索引扫描 229\n6.5.8 最大值和最小值优化 231\n6.5.9 在同一个表上查询和更新 232\n6.6 查询优化器的提示（hint） 232\n6.7 优化特定类型的查询 236\n6.7.1 优化count() 查询 236\n6.7.2 优化关联查询 239\n6.7.3 优化子查询 239\n6.7.4 优化group by 和distinct 239\n6.7.5 优化limit 分页 241\n6.7.6 优化sql_calc_found_rows 243\n6.7.7 优化union 查询 243\n6.7.8 静态查询分析 244\n6.7.9 使用用户自定义变量 244\n6.8 案例学习 251\n6.8.1 使用mysql 构建一个队列表 251\n6.8.2 计算两点之间的距离 254\n6.8.3 使用用户自定义函数 257\n6.9 总结 258\n第7 章 mysql 高级特性 259\n7.1 分区表 259\n7.1.1 分区表的原理 260\n7.1.2 分区表的类型 261\n7.1.3 如何使用分区表 262\n7.1.4 什么情况下会出问题 263\n7.1.5 查询优化 266\n7.1.6 合并表 267\n7.2 视图 270\n7.2.1 可更新视图 272\n7.2.2 视图对性能的影响 273\n7.2.3 视图的限制 274\n7.3 外键约束 275\n7.4 在mysql 内部存储代码 276\n7.4.1 存储过程和函数 278\n7.4.2 触发器 279\n7.4.3 事件 281\n7.4.4 在存储程序中保留注释 283\n7.5 游标 283\n7.6 绑定变量 284\n7.6.1 绑定变量的优化 286\n7.6.2 sql 接口的绑定变量 286\n7.6.3 绑定变量的限制 288\n7.7 用户自定义函数 289\n7.8 插件 290\n7.9 字符集和校对 291\n7.9.1 mysql 如何使用字符集 292\n7.9.2 选择字符集和校对规则 295\n7.9.3 字符集和校对规则如何影响查询 296\n7.10 全文索引 299\n7.10.1 自然语言的全文索引 300\n7.10.2 布尔全文索引 302\n7.10.3 mysql5.1 中全文索引的变化 303\n7.10.4 全文索引的限制和替代方案 304\n7.10.5 全文索引的配置和优化 306\n7.11 分布式（xa）事务 307\n7.11.1 内部xa 事务 307\n7.11.2 外部xa 事务 308\n7.12 查询缓存 309\n7.12.1 mysql 如何判断缓存命中 309\n7.12.2 查询缓存如何使用内存 311\n7.12.3 什么情况下查询缓存能发挥作用 313\n7.12.4 如何配置和维护查询缓存 316\n7.12.5 innodb 和查询缓存 319\n7.12.6 通用查询缓存优化 320\n7.12.7 查询缓存的替代方案 321\n7.13 总结 321\n第8 章 优化服务器设置 325\n8.1 mysql 配置的工作原理 326\n8.1.1 语法、作用域和动态性 327\n8.1.2 设置变量的副作用 328\n8.1.3 入门 331\n8.1.4 通过基准测试迭代优化 332\n8.2 什么不该做 333\n8.3 创建mysql 配置文件 335\n8.3.1 检查mysql 服务器状态变量 339\n8.4 配置内存使用 340\n8.4.1 mysql 可以使用多少内存？ 340\n8.4.2 每个连接需要的内存 341\n8.4.3 为操作系统保留内存 341\n8.4.4 为缓存分配内存 342\n8.4.5 innodb 缓冲池（buffer pool） 342\n8.4.6 myisam 键缓存（key caches） 344\n8.4.7 线程缓存 346\n8.4.8 表缓存（table cache） 347\n8.4.9 innodb 数据字典（data dictionary） 348\n8.5 配置mysql 的i/o 行为 349\n8.5.1 innodb i/o 配置 349\n8.5.2 myisam 的i/o 配置 361\n8.6 配置mysql 并发 363\n8.6.1 innodb 并发配置 364\n8.6.2 myisam 并发配置 365\n8.7 基于工作负载的配置 366\n8.7.1 优化blob 和text 的场景 367\n8.7.2 优化排序（filesorts） 368\n8.8 完成基本配置 369\n8.9 安全和稳定的设置 371\n8.10 高级innodb 设置 374\n8.11 总结 376\n第9 章 操作系统和硬件优化 377\n9.1 什么限制了mysql 的性能 377\n9.2 如何为mysql 选择cpu 378\n9.2.1 哪个更好：更快的cpu 还是更多的cpu 378\n9.2.2 cpu 架构 380\n9.2.3 扩展到多个cpu 和核心 381\n9.3 平衡内存和磁盘资源 382\n9.3.1 随机i/o 和顺序i/o 383\n9.3.2 缓存，读和写 384\n9.3.3 工作集是什么 385\n9.3.4 找到有效的内存/ 磁盘比例 386\n9.3.5 选择硬盘 387\n9.4 固态存储 389\n9.4.1 闪存概述 390\n9.4.2 闪存技术 391\n9.4.3 闪存的基准测试 392\n9.4.4 固态硬盘驱动器（ssd） 393\n9.4.5 pcie 存储设备 395\n9.4.6 其他类型的固态存储 396\n9.4.7 什么时候应该使用闪存 396\n9.4.8 使用flashcache 397\n9.4.9 优化固态存储上的mysql 399\n9.5 为备库选择硬件 402\n9.6 raid 性能优化 403\n9.6.1 raid 的故障转移、恢复和镜像 405\n9.6.2 平衡硬件raid 和软件raid 406\n9.6.3 raid 配置和缓存 407\n9.7 san 和nas 410\n9.7.1 san 基准测试 411\n9.7.2 使用基于nfs 或smb 的san 412\n9.7.3 mysql 在san 上的性能 412\n9.7.4 应该用san 吗 413\n9.8 使用多磁盘卷 414\n9.9 网络配置 416\n9.10 选择操作系统 418\n9.11 选择文件系统 419\n9.12 选择磁盘队列调度策略 421\n9.13 线程 422\n9.14 内存交换区 422\n9.15 操作系统状态 424\n9.15.1 如何阅读vmstat 的输出 425\n9.15.2 如何阅读iostat 的输出 426\n9.15.3 其他有用的工具 428\n9.15.4 cpu 密集型的机器 428\n9.15.5 i/o 密集型的机器 429\n9.15.6 发生内存交换的机器 430\n9.15.7 空闲的机器 430\n9.16 总结 431\n第10 章 复制 433\n10.1 复制概述 433\n10.1.1 复制解决的问题 434\n10.1.2 复制如何工作 435\n10.2 配置复制 436\n10.2.1 创建复制账号 437\n10.2.2 配置主库和备库 437\n10.2.3 启动复制 439\n10.2.4 从另一个服务器开始复制 441\n10.2.5 推荐的复制配置 443\n10.3 复制的原理 445\n10.3.1 基于语句的复制 445\n10.3.2 基于行的复制 446\n10.3.3 基于行或基于语句：哪种更优 446\n10.3.4 复制文件 448\n10.3.5 发送复制事件到其他备库 449\n10.3.6 复制过滤器 450\n10.4 复制拓扑 452\n10.4.1 一主库多备库 452\n10.4.2 主动- 主动模式下的主- 主复制 453\n10.4.3 主动- 被动模式下的主- 主复制 455\n10.4.4 拥有备库的主- 主结构 456\n10.4.5 环形复制 457\n10.4.6 主库、分发主库以及备库 458\n10.4.7 树或金字塔形 460\n10.4.8 定制的复制方案 460\n10.5 复制和容量规划 465\n10.5.1 为什么复制无法扩展写操作 466\n10.5.2 备库什么时候开始延迟 466\n10.5.3 规划冗余容量 467\n10.6 复制管理和维护 468\n10.6.1 监控复制 468\n10.6.2 测量备库延迟 469\n10.6.3 确定主备是否一致 469\n10.6.4 从主库重新同步备库 470\n10.6.5 改变主库 471\n10.6.6 在一个主- 主配置中交换角色 476\n10.7 复制的问题和解决方案 477\n10.7.1 数据损坏或丢失的错误 477\n10.7.2 使用非事务型表 480\n10.7.3 混合事务型和非事务型表 480\n10.7.4 不确定语句 481\n10.7.5 主库和备库使用不同的存储引擎 481\n10.7.6 备库发生数据改变 481\n10.7.7 不唯一的服务器id 482\n10.7.8 未定义的服务器id 482\n10.7.9 对未复制数据的依赖性 482\n10.7.10 丢失的临时表 483\n10.7.11 不复制所有的更新 484\n10.7.12 innodb 加锁读引起的锁争用 484\n10.7.13 在主- 主复制结构中写入两台主库 486\n10.7.14 过大的复制延迟 488\n10.7.15 来自主库的过大的包 491\n10.7.16 受限制的复制带宽 491\n10.7.17 磁盘空间不足 492\n10.7.18 复制的局限性 492\n10.8 复制有多快 492\n10.9 mysql 复制的高级特性 494\n10.10 其他复制技术 496\n10.11 总结 498\n第11 章 可扩展的mysql 501\n11.1 什么是可扩展性 501\n11.1.1 正式的可扩展性定义 503\n11.2 扩展mysql 507\n11.2.1 规划可扩展性 507\n11.2.2 为扩展赢得时间 508\n11.2.3 向上扩展 509\n11.2.4 向外扩展 510\n11.2.5 通过多实例扩展 525\n11.2.6 通过集群扩展 526\n11.2.7 向内扩展 530\n11.3 负载均衡 532\n11.3.1 直接连接 534\n11.3.2 引入中间件 537\n11.3.3 一主多备间的负载均衡 540\n11.4 总结 541\n第12 章 高可用性 543\n12.1 什么是高可用性 543\n12.2 导致宕机的原因 544\n12.3 如何实现高可用性 545\n12.3.1 提升平均失效时间（mtbf） 545\n12.3.2 降低平均恢复时间（mttr） 547\n12.4 避免单点失效 548\n12.4.1 共享存储或磁盘复制 549\n12.4.2 mysql 同步复制 551\n12.4.3 基于复制的冗余 555\n12.5 故障转移和故障恢复 556\n12.5.1 提升备库或切换角色 558\n12.5.2 虚拟ip 地址或ip 接管 558\n12.5.3 中间件解决方案 559\n12.5.4 在应用中处理故障转移 560\n12.6 总结 560\n第13 章 云端的mysql 563\n13.1 云的优点、缺点和相关误解 564\n13.2 mysql 在云端的经济价值 566\n13.3 云中的mysql 的可扩展性和高可用性 567\n13.4 四种基础资源 568\n13.5 mysql 在云主机上的性能 569\n13.5.1 在云端的mysql 基准测试 571\n13.6 mysql 数据库即服务（dbaas） 573\n13.6.1 amazon rds 573\n13.6.2 其他dbaas 解决方案 574\n13.7 总结 575\n第14 章 应用层优化 577\n14.1 常见问题 577\n14.2 web 服务器问题 579\n14.2.1 寻找最优并发度 581\n14.3 缓存 582\n14.3.1 应用层以下的缓存 583\n14.3.2 应用层缓存 584\n14.3.3 缓存控制策略 586\n14.3.4 缓存对象分层 587\n14.3.5 预生成内容 588\n14.3.6 作为基础组件的缓存 589\n14.3.7 使用handlersocket 和memcached 589\n14.4 拓展mysql 590\n14.5 mysql 的替代品 590\n14.6 总结 591\n第15 章 备份与恢复 593\n15.1 为什么要备份 594\n15.2 定义恢复需求 595\n15.3 设计mysql 备份方案 596\n15.3.1 在线备份还是离线备份 597\n15.3.2 逻辑备份还是物理备份 598\n15.3.3 备份什么 601\n15.3.4 存储引擎和一致性 603\n15.4 管理和备份二进制日志 605\n15.4.1 二进制日志格式 606\n15.4.2 安全地清除老的二进制日志 607\n15.5 备份数据 607\n15.5.1 生成逻辑备份 607\n15.5.2 文件系统快照 610\n15.6 从备份中恢复 617\n15.6.1 恢复物理备份 618\n15.6.2 还原逻辑备份 619\n15.6.3 基于时间点的恢复 622\n15.6.4 更高级的恢复技术 624\n15.6.5 innodb 崩溃恢复 625\n15.7 备份和恢复工具 628\n15.7.1 mysql enterprise backup 628\n15.7.2 percona xtrabackup 628\n15.7.3 mylvmbackup 629\n15.7.4 zmanda recovery manager 629\n15.7.5 mydumper 629\n15.7.6 mysqldump 629\n15.8 备份脚本化 631\n15.9 总结 633\n第16 章 mysql 用户工具 635\n16.1 接口工具 635\n16.2 命令行工具集 636\n16.3 sql 实用集 637\n16.4 监测工具 637\n16.4.1 开源的监控工具 638\n16.4.2 商业监控系统 640\n16.4.3 innotop 的命令行监控 642\n16.5 总结 646\n附录a mysql 分支与变种 649\n附录b mysql 服务器状态 655\n附录c 大文件传输 683\n附录d explain 687\n附录e 锁的调试 703\n附录f 在mysql 上使用sphinx 713\n索引 739",
    "ebook_url": "https://read.douban.com/ebook/35648568/",
    "pages": "764",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27783358.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27783358.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27783358.jpg"
    },
    "alt": "https://book.douban.com/subject/23008813/",
    "id": "23008813",
    "publisher": "电子工业出版社",
    "isbn10": "7121198851",
    "isbn13": "9787121198854",
    "title": "高性能MySQL",
    "url": "https://api.douban.com/v2/book/23008813",
    "alt_title": "High Performance MySQL,3rd",
    "author_intro": "关于作者\nBaron Schwartz 是一位软件工程师，居住在弗吉尼亚州的Charlottesville，网络常用名是Xaprb，这是按照QWERTY 键盘的顺序在Dvorak 键盘上打出来的名字。在不忙于解决有趣的编程挑战时，Baron 会和他的妻子Lynn 以及小狗Carbon 一起享受闲暇的时光。他有一个软件工程方面的博客，地址是http://www.xaprb.com/blog/\nPeter Zaitsev 曾经是MySQL AB 公司高性能组的经理，目前在运作mysqlperformance\nblog.com 网站。他擅长于帮助那些每天有数以百万计访问量的网站的管理员解决问题，这些网站通常需要几百台机器来处理TB 级的数据。他常常为了解决一个问题而不停地升级硬件和软件（比如查询优化）。Peter 还经常在各种会议上演讲。\nVadim Tkachenko 曾经是MySQL AB 公司的性能工程师。作为一名在多线程编程和同步方面的专家，他的主要工作是基准测试、性能剖析，以及找出系统的性能瓶颈。他还在性能监控和调优方面做了一些工作，使得MySQL 在多核机器上有更好的可扩展性。\n================================================================\n译者简介\n宁海元 有超过十年的数据库管理经验，从最初到SQL Server 2000到Oracle到MySQL，擅长数据库高可用架构，性能优化和故障诊断。2007年加入淘宝，带领淘宝DBA团队支撑了淘宝业务的快速增长，完成了数据库的垂直拆分、水平拆分，迁移到MySQL体系等主要工作。目前专注于无线数据领域。网络常用名NinGoo，个人博客：http://www.ningoo.net\n周振兴 毕业于北京师范大学数学系，09年加入淘宝数据库团队负责MySQL运维管理工作，有丰富的MySQL性能优化、Troubleshooting经验，对MySQL主要模块的实现和原理有深入的研究，经历淘宝MySQL实例从30到3000的发展，对系统架构、高可用环境规划都有深入理解。个人博客：http://orczhou.com\n彭立勋 2010年大学毕业后加入阿里巴巴运维部。作为一名MySQL DBA，在运维MySQL的过程中，对MySQL和InnoDB的一些功能和缺陷就进行了补充，编写了多主复制和数据闪回等补丁。目前在阿里集团核心系统研发部数据库组，专注于MySQL数据库相关的开发工作。后来一些补丁被MySQL之父Mony看中，成为MariaDB提交组（Maria-captains）成员，并且把多主复制，线程内存监控等补丁合并到了MariaDB 10.0版本。\n翟卫祥 毕业于武汉大学，研究生阶段从事数据库相关研究。毕业后就职于阿里巴巴集团数据库技术团队至今，主要负责阿里内部MySQL代码分支维护，包括MySQL Bug Fix及新特性开发。对MySQL内核有一定的研究。\n刘辉 2008年毕业于西安电子科技大学计算机系，硕士学位。2011年加入阿里巴巴集团数据库技术团队，花名希羽，MySQL内核开发工程师。",
    "summary": "《高性能mysql(第3版)》是mysql 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了最新mysql 5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16 章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql 和mysql相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。\n《高性能mysql(第3版)》不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。",
    "ebook_price": "96.00",
    "price": "128.00元"
  },
  "9787115264725": {
    "rating": { "max": 10, "numRaters": 338, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["(印)拉克什曼"],
    "pubdate": "2011-11",
    "tags": [
      { "count": 311, "name": "shell", "title": "shell" },
      { "count": 204, "name": "linux", "title": "linux" },
      { "count": 153, "name": "Linux", "title": "Linux" },
      { "count": 105, "name": "Shell", "title": "Shell" },
      { "count": 76, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 73, "name": "计算机", "title": "计算机" },
      { "count": 69, "name": "编程", "title": "编程" },
      { "count": 34, "name": "Programming", "title": "Programming" }
    ],
    "origin_title": "Linux Shell Scripting Cookbook",
    "image": "https://img1.doubanio.com/view/subject/m/public/s22702207.jpg",
    "binding": "平装",
    "translator": ["门佳"],
    "catalog": "第1 章  小试牛刀　　1\n1.1  简介　　1\n1.2  终端打印　　3\n1.2.1  实战演练　　3\n1.2.2  补充内容　　4\n1.3  玩转变量和环境变量　　5\n1.3.1  预备知识　　5\n1.3.2  实战演练　　6\n1.3.3  补充内容　　7\n1.4  通过shell 进行数学运算　　8\n1.4.1  预备知识　　9\n1.4.2  实战演练　　9\n1.5  玩转文件描述符和重定向　　10\n1.5.1  预备知识　　10\n1.5.2  实战演练　　11\n1.5.3  补充内容　　13\n1.6  数组和关联数组　　15\n1.6.1  预备知识　　15\n1.6.2  实战演练　　15\n1.6.3  补充内容　　16\n1.7  使用别名　　17\n1.7.1  预备知识　　17\n1.7.2  实战演练　　17\n1.7.3  补充内容　　18\n1.8  获取终端信息　　18\n1.8.1  预备知识　　18\n1.8.2  实战演练　　18\n1.9  获取、设置日期和延时　　19\n1.9.1  预备知识　　19\n1.9.2  实战演练　　19\n1.9.3  补充内容　　21\n1.10  调试脚本　　22\n1.10.1  预备知识　　22\n1.10.2  实战演练　　22\n1.10.3  补充内容　　23\n1.11  函数和参数　　23\n1.11.1  实战演练　　23\n1.11.2  补充内容　　24\n1.12  读取命令序列输出　　25\n1.12.1  预备知识　　26\n1.12.2  实战演练　　26\n1.12.3  补充内容　　26\n1.13  以不按回车键的方式读取字符“n”　　27\n1.13.1  预备知识　　27\n1.13.2  实战演练　　27\n1.14  字段分隔符和迭代器　　28\n1.14.1  预备知识　　28\n1.14.2  实战演练　　29\n1.15  比较与测试　　30\n1.15.1  预备知识　　30\n1.15.2  实战演练　　30\n第2 章  命令之乐　　34\n2.1  简介　　34\n2.2  用cat 进行拼接　　34\n2.2.1  预备知识　　34\n2.2.2  实战演练　　35\n2.2.3  工作原理　　35\n2.2.4  补充内容　　35\n2.3  录制与回放终端会话　　37\n2.3.1  预备知识　　37\n2.3.2  实战演练　　37\n2.3.3  工作原理　　37\n2.4  文件查找与文件列表　　38\n2.4.1  预备知识　　38\n2.4.2  实战演练　　38\n2.4.3  补充内容　　39\n2.5  玩转xargs　　45\n2.5.1  预备知识　　45\n2.5.2  实战演练　　45\n2.5.3  工作原理　　46\n2.5.4  补充内容　　46\n2.6  用tr 进行转换　　49\n2.6.1  预备知识　　49\n2.6.2  实战演练　　49\n2.6.3  工作原理　　49\n2.6.4  补充内容　　50\n2.7  校验和与核实　　52\n2.7.1  预备知识　　52\n2.7.2  实战演练　　52\n2.7.3  工作原理　　52\n2.7.4  补充内容　　53\n2.8  排序、单一与重复　　53\n2.8.1  预备知识　　54\n2.8.2  实战演练　　54\n2.8.3  工作原理　　54\n2.8.4  补充内容　　55\n2.9  临时文件命名与随机数　　58\n2.9.1  实战演练　　58\n2.9.2  工作原理　　58\n2.10  分割文件和数据　　59\n2.10.1  工作原理　　59\n2.10.2  补充内容　　59\n2.11  根据扩展名切分文件名　　61\n2.11.1  实战演练　　61\n2.11.2  工作原理　　61\n2.12  批量重命名和移动　　63\n2.12.1  预备知识　　63\n2.12.2  实战演练　　63\n2.12.3  工作原理　　64\n2.13  拼写检查与词典操作　　65\n2.13.1  实战演练　　65\n2.13.2  工作原理　　65\n2.14  交互输入自动化　　 66\n2.14.1  预备知识　　 66\n2.14.2  实战演练　　 66\n2.14.3  工作原理　　 67\n2.14.4  补充内容　　 67\n第3 章  以文件之名　　 69\n3.1  简介　　 69\n3.2  生成任意大小的文件　　 69\n3.3  文本文件的交集与差集　　70\n3.3.1  预备知识　　71\n3.3.2  实战演练　　71\n3.4  查找并删除重复文件　　 73\n3.4.1  预备知识　　73\n3.4.2  实战演练　　73\n3.4.3  工作原理　　 74\n3.4.4  参考　　 75\n3.5  创建长路径目录　　75\n3.5.1  预备知识　　75\n3.5.2  实战演练　　76\n3.6  文件权限、所有权和粘滞位　　76\n3.6.1  预备知识　　76\n3.6.2  实战演练　　78\n3.6.3  补充内容　　79\n3.7  创建不可修改文件　　80\n3.7.1  预备知识　　80\n3.7.2  实战演练　　80\n3.8  批量生成空白文件　　80\n3.8.1  预备知识　　81\n3.8.2  实战演练　　81\n3.9  查找符号链接及其指向目标　　81\n3.9.1  预备知识　　 81\n3.9.2  实战演练　　81\n3.10  列举文件类型统计信息　　82\n3.10.1  预备知识　　 83\n3.10.2  实战演练　　 83\n3.10.3  工作原理　　 84\n3.11  环回文件与挂载　　84\n3.11.1  预备知识　　85\n3.11.2  实战演练　　85\n3.11.3  补充内容　　86\n3.12  生成ISO 文件及混合ISO 　　87\n3.12.1  预备知识　　87\n3.12.2  实战演练　　87\n3.12.3  补充内容　　87\n3.13  查找文件差异并进行修补　　89\n3.13.1  实战演练　　89\n3.13.2  补充内容　　90\n3.14  head 与tail —— 打印文件的前10 行和后10 行　　90\n3.15  只列出目录的其他方法　　92\n3.15.1  预备知识　　93\n3.15.2  实战演练　　93\n3.16  在命令行中用pushd 和popd快速定位　　93\n3.16.1  预备知识　　93\n3.16.2  实战演练　　93\n3.16.3  补充内容　　94\n3.17  统计文件的行数、单词数和字符数　　95\n3.17.1  预备知识　　95\n3.17.2  实战演练　　95\n3.17.3  补充知识　　95\n3.18  打印目录树　　96\n3.18.1  预备知识　　96\n3.18.2  实战演练　　96\n3.18.3  补充内容　　97\n第4 章  让文本飞　　98\n4.1  简介　　98\n4.2  正则表达式入门　　99\n4.2.1  预备知识　　99\n4.2.2  实战演练　　99\n4.2.3  工作原理　　100\n4.2.4  补充内容　　101\n4.3  用grep 在文件中搜索文本　　101\n4.3.1  预备知识　　101\n4.3.2  实战演练　　101\n4.3.3  补充内容　　103\n4.4  用cut 按列切分文件　　107\n4.4.1  预备知识　　107\n4.4.2  实战演练　　107\n4.4.3  补充内容　　108\n4.5  统计特定文件中的词频　　109\n4.5.1  预备知识　　109\n4.5.2  实战演练　　109\n4.5.3  工作原理　　110\n4.5.4  参考　　110\n4.6  sed 入门　　110\n4.6.1  实战演练　　111\n4.6.2  补充内容　　111\n4.7  awk 入门　　113\n4.7.1  实战演练　　113\n4.7.2  工作原理　　113\n4.7.3  补充内容　　114\n4.8  替换文本或文件中的字符串　　117\n4.8.1  预备知识　　117\n4.8.2  实战演练　　118\n4.8.3  补充内容　　118\n4.8.4  参考　　118\n4.9  压缩或解压缩JavaScript　　119\n4.9.1  预备知识　　119\n4.9.2  工作原理　　119\n4.9.3  工作原理　　120\n4.9.4  参考　　121\n4.10  对文件中的行、单词和字符进行迭代　　121\n4.10.1  预备知识　　121\n4.10.2  实战演练　　121\n4.10.3  工作原理　　122\n4.10.4  参考　　122\n4.11  按列合并文件　　122\n4.11.1  工作原理　　122\n4.11.2  参考　　123\n4.12  打印文件或行中的第n 个单词或列　　123\n4.12.1  预备知识　　123\n4.12.2  实战演练　　123\n4.12.3  参考　　124\n4.13  打印不同行或样式之间的文本　　124\n4.13.1  预备知识　　124\n4.13.2  实战演练　　124\n4.13.3  参考　　125\n4.14  用脚本检验回文字符串　　125\n4.14.1  预备知识　　125\n4.14.2  工作原理　　125\n4.14.3  工作原理　　126\n4.14.4  补充内容　　127\n4.14.5  参考　　128\n4.15  以逆序形式打印行　　128\n4.15.1  预备知识　　128\n4.15.2  实战演练　　128\n4.15.3  工作原理　　129\n4.15.4  参考　　129\n4.16  解析文本中的电子邮件地址和URL 　　129\n4.16.1  预备知识　　129\n4.16.2  实战演练　　129\n4.16.3  工作原理　　130\n4.16.4  参考　　130\n4.17  打印文件中某个样式之前或之后的n 行　　130\n4.17.1  预备知识　　131\n4.17.2  实战演练　　131\n4.17.3  参考　　132\n4.18  在文件中移除包含某个单词的句子　　132\n4.18.1  预备知识　　132\n4.18.2  实战演练　　132\n4.18.3  工作原理　　133\n4.18.4  参考　　133\n4.19  用awk 实现head、tail 和tac 　　133\n4.19.1  预备知识　　133\n4.19.2  实战演练　　133\n4.19.3  工作原理　　134\n4.19.4  参考　　134\n4.20  文本切片与参数操作　　134\n4.20.1  实战演练　　134\n4.20.2  参考　　135\n第5 章  一团乱麻？没这回事　　136\n5.1  入门　　136\n5.2  网站下载　　136\n5.2.1  预备知识　　136\n5.2.2  实战演练　　136\n5.2.3  补充内容　　137\n5.3  以格式化纯文本形式下载网页　　 138\n5.4  cURL 入门　　139\n5.4.1  预备知识　　139\n5.4.2  实战演练　　139\n5.4.3  补充内容　　140\n5.4.4  参考　　142\n5.5  从命令行访问Gmail 　　142\n5.5.1  实战演练　　142\n5.5.2  工作原理　　143\n5.5.3  参考　　144\n5.6  解析网站数据　　 144\n5.6.1  实战演练　　144\n5.6.2  工作原理　　144\n5.6.3  参考　　145\n5.7  制作图片抓取器及下载工具　　145\n5.7.1  实战演练　　145\n5.7.2  工作原理　　146\n5.7.3  参考　　147\n5.8  网页相册生成器　　147\n5.8.1  预备知识　　147\n5.8.2  实战演练　　147\n5.8.3  工作原理　　148\n5.8.4  参考　　149\n5.9  Twitter 命令行客户端　　 149\n5.9.1  预备知识　　149\n5.9.2  实战演练　　149\n5.9.3  工作原理　　150\n5.9.4  参考　　150\n5.10  基于Web 后端的定义查询工具　　151\n5.10.1  预备知识　　151\n5.10.2  实战演练　　151\n5.10.3  工作原理　　152\n5.10.4  参考　　152\n5.11  查找网站中的无效链接　　152\n5.11.1  预备知识　　152\n5.11.2  实战演练　　153\n5.11.3  工作原理　　153\n5.11.4  参考　　153\n5.12  跟踪网站变更　　154\n5.12.1  预备知识　　154\n5.12.2  实战演练　　154\n5.12.3  工作原理　　155\n5.12.4  参考　　155\n5.13  以POST 方式发送网页并读取响应　　155\n5.13.1  预备知识　　156\n5.13.2  实战演练　　156\n5.13.3  补充内容　　157\n5.13.4  参考　　157\n第6 章  B 计划　　158\n6.1  简介　　158\n6.2  用tar 归档　　158\n6.2.1  预备知识　　158\n6.2.2  实战演练　　159\n6.2.3  补充知识　　159\n6.2.4  参考　　163\n6.3  用cpio 归档　　163\n6.4  用gunzip 或gzip 压缩　　164\n6.4.1  实战演练　　164\n6.4.2  补充内容　　164\n6.4.3  参考　　166\n6.5  用bunzip 或bzip 压缩　　166\n6.5.1  实战演练　　166\n6.5.2  补充内容　　167\n6.5.3  参考　　168\n6.6  用lzma 压缩　　168\n6.6.1  实战演练　　168\n6.6.2  补充内容　　169\n6.6.3  参考　　169\n6.7  用zip 归档和压缩　　169\n6.8  超高压缩率的squashfs 文件系统　　170\n6.8.1  预备知识　　171\n6.8.2  实战演练　　171\n6.8.3  补充内容　　171\n6.9  加密工具与散列　　172\n6.10  用raync 备份系统快照　　174\n6.10.1  实战演练　　174\n6.10.2  补充内容　　175\n6.11  用Git 备份版本控制　　176\n6.11.1  预备知识　　176\n6.11.2  实战演练　　176\n6.12  用dd 克隆磁盘　　178\n6.12.1  预备知识　　179\n6.12.2  实战演练　　179\n6.12.3  补充内容　　180\n6.12.4  参考　　180\n第7 章  无网不利　　181\n7.1  简介　　181\n7.2  联网知识入门　　181\n7.2.1  新手上路　　181\n7.2.2  实战演练　　182\n7.2.3  补充内容　　182\n7.2.4  参考　　186\n7.3  使用ping　　186\n7.3.1  实战演练　　186\n7.3.2  补充内容　　187\n7.4  列出网络上所有的活动主机　　188\n7.4.1  新手上路　　188\n7.4.2  实战演练　　188\n7.4.3  工作原理　　189\n7.4.4  补充内容　　191\n7.4.5  参考　　191\n7.5  传输文件　　191\n7.5.1  新手上路　　191\n7.5.2  实战演练　　191\n7.5.3  补充内容　　192\n7.5.4  参考　　194\n7.6  用脚本设置以太网与无线LAN　　194\n7.6.1  新手上路　　194\n7.6.2  实战演练　　194\n7.6.3  工作原理　　196\n7.6.4  参考　　196\n7.7  用SSH 实现无密码自动登录　　196\n7.8  用SSH 在远程主机上运行命令　　198\n7.8.1  新手上路　　198\n7.8.2  实战演练　　198\n7.8.3  补充内容　　200\n7.8.4  参考　　200\n7.9  在本地挂载点上挂载远程驱动器　　201\n7.9.1  新手上路　　201\n7.9.2  实战演练　　201\n7.9.3  参考　　201\n7.10  在网络上发送多播式窗口消息　　201\n7.10.1  新手上路　　201\n7.10.2  实战演练　　201\n7.10.3  工作原理　　202\n7.10.4  参考　　203\n7.11  网络流量与端口分析　　203\n7.11.1  新手上路　　203\n7.11.2  实战演练　　203\n7.11.3  补充内容　　204\n第8 章  当个好管家　　205\n8.1  简介　　205\n8.2  统计磁盘的使用情况　　205\n8.2.1  新手上路　　206\n8.2.2  实战演练　　206\n8.2.3  补充内容　　206\n8.3  计算命令执行时间　　210\n8.4  与当前登录用户、启动日志及启动故障的相关信息　　212\n8.4.1  新手上路　　212\n8.4.2  实战演练　　212\n8.5  打印出10 条最常使用的命令　　214\n8.5.1  新手上路　　214\n8.5.2  实战演练　　214\n8.5.3  工作原理　　215\n8.6  列出1 小时内占用CPU 最多的10 个进程　　215\n8.6.1  新手上路　　215\n8.6.2  实战演练　　215\n8.6.3  工作原理　　216\n8.6.4  参考　　 217\n8.7  用watch 监视命令输出　　 217\n8.7.1  实战演练　　 217\n8.7.2  补充内容　　 217\n8.8  对文件及目录访问进行记录　　 218\n8.8.1  新手上路　　 218\n8.8.2  实战演练　　 218\n8.8.3  工作原理　　 218\n8.9  用logrotate 管理日志文件　　 219\n8.9.1  新手上路　　 219\n8.9.2  实战演练　　 219\n8.10  用syslog 记录日志　　 220\n8.10.1  新手上路　　 220\n8.10.2  实战演练　　 221\n8.10.3  参考　　 221\n8.11  通过监视用户登录找出入侵者　　221\n8.11.1  新手上路　　222\n8.11.2  实战演练　　222\n8.11.3  工作原理　　223\n8.12  监视远程磁盘的健康情况　　224\n8.12.1  新手上路　　224\n8.12.2  实战演练　　224\n8.12.3  工作原理　　225\n8.12.4  参考　　 226\n8.13  找出系统中用户的活动时段　　226\n8.13.1  新手上路　　226\n8.13.2  实战演练　　226\n8.13.3  工作原理　　227\n第9 章  管理重任　　228\n9.1  简介　　 228\n9.2  收集进程信息　　 228\n9.2.1  新手上路　　228\n9.2.2  实战演练　　229\n9.2.3  补充内容　　231\n9.2.4  参考　　234\n9.3  杀死进程以及发送或响应信号　　 234\n9.3.1  新手上路　　235\n9.3.2  实战演练　　235\n9.3.3  补充内容　　235\n9.4  which、whereis、file、whatis 与平均负载　　237\n9.5  向用户终端发送消息　　238\n9.5.1  新手上路　　239\n9.5.2  实战演练　　239\n9.5.3  工作原理　　240\n9.6  收集系统信息　　240\n9.7  用/proc 收集信息　　241\n9.8  用cron 进行调度　　242\n9.8.1  新手上路　　242\n9.8.2  实战演练　　242\n9.8.3  补充内容　　243\n9.9  从Bash 中读写MySQL 数据库　　244\n9.9.1  新手上路　　244\n9.9.2  实战演练　　244\n9.9.3  工作原理　　247\n9.10  用户��理脚本　　248\n9.10.1  实战演练　　248\n9.10.2  工作原理　　249\n9.11  图像文件的批量缩放及格式转换　　251\n9.11.1  新手上路　　251\n9.11.2  实战演练　　251\n9.11.3  工作原理　　253\n9.11.4  参考　　254",
    "pages": "254",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s22702207.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s22702207.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s22702207.jpg"
    },
    "alt": "https://book.douban.com/subject/6889456/",
    "id": "6889456",
    "publisher": "人民邮电出版社",
    "isbn10": "7115264724",
    "isbn13": "9787115264725",
    "title": "Linux Shell脚本攻略",
    "url": "https://api.douban.com/v2/book/6889456",
    "alt_title": "Linux Shell Scripting Cookbook",
    "author_intro": "Sarath Lakshman，年轻的Linux天才程序员、开源软件及GNU／Linux活跃分子，写作本书时年仅20岁。他在印度出生并成长，目前是印度科钦科技大学模范工程学院的学生。2004年，他就开发了名为Slynux的GNU／Linux发布版。另外，他还为Linux Foryou月刊撰写文章。在Fedora、Pardus Linux、PiTiVi、Ubuntu以及Google Summerof Code等项目中，他都作出了显著的贡献。",
    "summary": "《Linux Shell脚本攻略》通过细致剖析实际应用中的110多个案例，使许多看似复杂的Linux shell脚本任务迎刃而解。《Linux Shell脚本攻略》会帮助读者利用少量命令的组合完成诸如文本处理、文件管理、备份等复杂的数据管理工作。它将告诉你如何利用shell命令快速开发常规任务，综合应用grep、find、sed和awk等常用命令，凭借短短几个命令行从Web挖掘数据的shell脚本，利用归档工具运行并自动化各种任务，诸如自动备份和存储；帮助你理解文件系统、文件类型以及文件管理；用shell创建以及维护文件或目录归档、压缩格式和加密技术；通过srlell脚本设置以太网和无线LAN；使用登录技术监控网络上的各种动态。",
    "price": "49.00元"
  },
  "9787115429674": {
    "rating": { "max": 10, "numRaters": 107, "average": "9.1", "min": 0 },
    "subtitle": "",
    "author": ["[美]布鲁姆，布雷斯纳汉"],
    "pubdate": "2016-8-1",
    "tags": [
      { "count": 158, "name": "Linux", "title": "Linux" },
      { "count": 102, "name": "shell", "title": "shell" },
      { "count": 65, "name": "计算机", "title": "计算机" },
      { "count": 61, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 52, "name": "Shell", "title": "Shell" },
      { "count": 51, "name": "linux", "title": "linux" },
      { "count": 41, "name": "编程", "title": "编程" },
      { "count": 18, "name": "程序设计", "title": "程序设计" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29584559.jpg",
    "binding": "平装",
    "translator": ["门佳", "武海峰"],
    "catalog": "第一部分　Linux 命令行\n第1章　初识Linux shell　　2\n1.1　什么是Linux　　2\n1.1.1　深入探究Linux内核　　3\n1.1.2　GNU工具　　6\n1.1.3　Linux桌面环境　　8\n1.2　Linux发行版　　12\n1.2.1　核心Linux发行版　　13\n1.2.2　特定用途的Linux发行版　　13\n1.2.3　Linux LiveCD　　14\n1.3　小结　　15\n第2章　走进shell　　16\n2.1　进入命令行　　16\n2.1.1　控制台终端　　17\n2.1.2　图形化终端　　17\n2.2　通过Linux控制台终端访问CLI　　18\n2.3　通过图形化终端仿真访问CLI　　20\n2.4　使用GNOME Terminal仿真器　　21\n2.4.1　访问GNOME Terminal　　21\n2.4.2　菜单栏　　22\n2.5　使用Konsole Terminal仿真器　　25\n2.5.1　访问Konsole Terminal　　25\n2.5.2　菜单栏　　26\n2.6　使用xterm终端仿真器　　29\n2.6.1　访问xterm　　30\n2.6.2　命令行参数　　30\n2.7　小结　　32\n第3章　基本的bash shell命令　　33\n3.1　启动shell　　33\n3.2　shell提示符　　34\n3.3　bash手册　　34\n3.4　浏览文件系统　　37\n3.4.1　Linux文件系统　　37\n3.4.2　遍历目录　　40\n3.5　文件和目录列表　　42\n3.5.1　基本列表功能　　42\n3.5.2　显示长列表　　44\n3.5.3　过滤输出列表　　45\n3.6　处理文件　　46\n3.6.1　创建文件　　47\n3.6.2　复制文件　　47\n3.6.3　制表键自动补全　　50\n3.6.4　链接文件　　50\n3.6.5　重命名文件　　52\n3.6.6　删除文件　　54\n3.7　处理目录　　55\n3.7.1　创建目录　　55\n3.7.2　删除目录　　55\n3.8　查看文件内容　　58\n3.8.1　查看文件类型　　58\n3.8.2　查看整个文件　　59\n3.8.3　查看部分文件　　61\n3.9　小结　　63\n第4章　更多的bash shell命令　　64\n4.1　监测程序　　64\n4.1.1　探查进程　　64\n4.1.2　实时监测进程　　70\n4.1.3　结束进程　　72\n4.2　监测磁盘空间　　73\n4.2.1　挂载存储媒体　　73\n4.2.2　使用df命令　　76\n4.2.3　使用du命令　　77\n4.3　处理数据文件　　78\n4.3.1　排序数据　　78\n4.3.2　搜索数据　　81\n4.3.3　压缩数据　　83\n4.3.4　归档数据　　84\n4.4　小结　　85\n第5章　理解shell　　86\n5.1　shell的类型　　86\n5.2　shell的父子关系　　88\n5.2.1　进程列表　　91\n5.2.2　别出心裁的子shell用法　　93\n5.3　理解shell的内建命令　　96\n5.3.1　外部命令　　96\n5.3.2　内建命令　　97\n5.4　小结　　101\n第6章　使用Linux环境变量　　103\n6.1　什么是环境变量　　103\n6.1.1　全局环境变量　　104\n6.1.2　局部环境变量　　105\n6.2　设置用户定义变量　　106\n6.2.1　设置局部用户定义变量　　106\n6.2.2　设置全局环境变量　　107\n6.3　删除环境变量　　109\n6.4　默认的shell环境变量　　110\n6.5　设置PATH环境变量　　113\n6.6　定位系统环境变量　　114\n6.6.1　登录shell　　115\n6.6.2　交互式shell进程　　119\n6.6.3　非交互式shell　　120\n6.6.4　环境变量持久化　　121\n6.7　数组变量　　121\n6.8　小结　　122\n第7章　理解Linux文件权限　　124\n7.1　Linux的安全性　　124\n7.1.1　/etc/passwd文件　　124\n7.1.2　/etc/shadow文件　　126\n7.1.3　添加新用户　　127\n7.1.4　删除用户　　129\n7.1.5　修改用户　　130\n7.2　使用Linux组　　132\n7.2.1　/etc/group文件　　133\n7.2.2　创建新组　　133\n7.2.3　修改组　　134\n7.3　理解文件权限　　135\n7.3.1　使用文件权限符　　135\n7.3.2　默认文件权限　　136\n7.4　改变安全性设置　　138\n7.4.1　改变权限　　138\n7.4.2　改变所属关系　　139\n7.5　共享文件　　140\n7.6　小结　　142\n第8章　管理文件系统　　143\n8.1　探索Linux文件系统　　143\n8.1.1　基本的Linux文件系统　　143\n8.1.2　日志文件系统　　145\n8.1.3　写时复制文件系统　　147\n8.2　操作文件系统　　147\n8.2.1　创建分区　　147\n8.2.2　创建文件系统　　151\n8.2.3　文件系统的检查与修复　　153\n8.3　逻辑卷管理　　154\n8.3.1　逻辑卷管理布局　　154\n8.3.2　Linux中的LVM　　155\n8.3.3　使用Linux LVM　　156\n8.4　小结　　162\n第9章　安装软件程序　　163\n9.1　包管理基础　　163\n9.2　基于Debian的系统　　164\n9.2.1　用aptitude管理软件包　　164\n9.2.2　用aptitude安装软件包　　166\n9.2.3　用aptitude更新软件　　168\n9.2.4　用aptitude卸载软件　　169\n9.2.5　aptitude仓库　　169\n9.3　基于Red Hat的系统　　171\n9.3.1　列出已安装包　　171\n9.3.2　用yum安装软件　　173\n9.3.3　用yum更新软件　　174\n9.3.4　用yum卸载软件　　174\n9.3.5　处理损坏的包依赖关系　　175\n9.3.6　 yum软件仓库　　176\n9.4　从源码安装　　177\n9.5　小结　　180\n第10章　使用编辑器　　181\n10.1　vim编辑器　　181\n10.1.1　检查vim软件包　　181\n10.1.2　vim基础　　183\n10.1.3　编辑数据　　185\n10.1.4　复制和粘贴　　185\n10.1.5　查找和替换　　186\n10.2　nano编辑器　　187\n10.3　emacs编辑器　　188\n10.3.1　检查emacs软件包　　189\n10.3.2　在控制台中使用emacs　　190\n10.3.3　在GUI环境中使用emacs　　195\n10.4　KDE系编辑器　　196\n10.4.1　KWrite编辑器　　196\n10.4.2　Kate编辑器　　200\n10.5　GNOME编辑器　　202\n10.5.1　启动gedit　　203\n10.5.2　基本的gedit功能　　203\n10.5.3　设定偏好设置　　204\n10.6　小结　　206\n第二部分　shell脚本编程基础\n第11章　构建基本脚本　　210\n11.1　使用多个命令　　210\n11.2　创建shell脚本文件　　211\n11.3　显示消息　　212\n11.4　使用变量　　214\n11.4.1　环境变量　　214\n11.4.2　用户变量　　215\n11.4.3　命令替换　　216\n11.5　重定向输入和输出　　218\n11.5.1　输出重定向　　218\n11.5.2　输入重定向　　219\n11.6　管道　　220\n11.7　执行数学运算　　222\n11.7.1　expr命令　　223\n11.7.2　使用方括号　　224\n11.7.3　浮点解决方案　　225\n11.8　退出脚本　　228\n11.8.1　查看退出状态码　　228\n11.8.2　exit命令　　229\n11.9　小结　　231\n第12章　使用结构化命令　　232\n12.1　使用if-then语句　　232\n12.2　if-then-else语句　　235\n12.3　嵌套if　　235\n12.4　test命令　　238\n12.4.1　数值比较　　240\n12.4.2　字符串比较　　242\n12.4.3　文件比较　　246\n12.5　复合条件测试　　254\n12.6　if-then的高级特性　　255\n12.6.1　使用双括号　　255\n12.6.2　使用双方括号　　256\n12.7　case命令　　257\n12.8　小结　　258\n第13章　更多的结构化命令　　260\n13.1　for命令　　260\n13.1.1　读取列表中的值　　261\n13.1.2　读取列表中的复杂值　　262\n13.1.3　从变量读取列表　　263\n13.1.4　从命令读取值　　264\n13.1.5　更改字段分隔符　　265\n13.1.6　用通配符读取目录　　266\n13.2　C语言风格的for命令　　268\n13.2.1　C语言的for命令　　268\n13.2.2　使用多个变量　　269\n13.3　while命令　　270\n13.3.1　while的基本格式　　270\n13.3.2　使用多个测试命令　　271\n13.4　until命令　　272\n13.5　嵌套循环　　274\n13.6　循环处理文件数据　　276\n13.7　控制循环　　277\n13.7.1　break命令　　277\n13.7.2　continue命令　　280\n13.8　处理循环的输出　　282\n13.9　实例　　283\n13.9.1　查找可执行文件　　284\n13.9.2　创建多个用户账户　　285\n13.10　小结　　286\n第14章　处理用户输入　　287\n14.1　命令行参数　　287\n14.1.1　读取参数　　287\n14.1.2　读取脚本名　　289\n14.1.3　测试参数　　291\n14.2　特殊参数变量　　292\n14.2.1　参数统计　　292\n14.2.2　抓取所有的数据　　294\n14.3　移动变量　　295\n14.4　处理选项　　296\n14.4.1　查找选项　　297\n14.4.2　使用getopt命令　　300\n14.4.3　使用更高级的getopts　　302\n14.5　将选项标准化　　305\n14.6　获得用户输入　　306\n14.6.1　基本的读取　　306\n14.6.2　超时　　307\n14.6.3　隐藏方式读取　　308\n14.6.4　从文件中读取　　309\n14.7　小结　　309\n第15章　呈现数据　　311\n15.1　理解输入和输出　　311\n15.1.1　标准文件描述符　　311\n15.1.2　重定向错误　　313\n15.2　在脚本中重定向输出　　315\n15.2.1　临时重定向　　315\n15.2.2　永久重定向　　316\n15.3　在脚本中重定向输入　　317\n15.4　创建自己的重定向　　317\n15.4.1　创建输出文件描述符　　318\n15.4.2　重定向文件描述符　　318\n15.4.3　创建输入文件描述符　　319\n15.4.4　创建读写文件描述符　　320\n15.4.5　关闭文件描述符　　321\n15.5　列出打开的文件描述符　　322\n15.6　阻止命令输出　　323\n15.7　创建临时文件　　324\n15.7.1　创建本地临时文件　　324\n15.7.2　在/tmp目录创建临时文件　　325\n15.7.3　创建临时目录　　326\n15.8　记录消息　　327\n15.9　实例　　328\n15.10　小结　　330\n第16章　控制脚本　　331\n16.1　处理信号　　331\n16.1.1　重温Linux信号　　331\n16.1.2　生成信号　　332\n16.1.3　捕获信号　　334\n16.1.4　捕获脚本退出　　335\n16.1.5　修改或移除捕获　　335\n16.2　以后台模式运行脚本　　338\n16.2.1　后台运行脚本　　338\n16.2.2　运行多个后台作业　　340\n16.3　在非控制台下运行脚本　　341\n16.4　作业控制　　342\n16.4.1　查看作业　　342\n16.4.2　重启停止的作业　　344\n16.5　调整谦让度　　345\n16.5.1　nice命令　　345\n16.5.2　renice命令　　346\n16.6　定时运行作业　　346\n16.6.1　用at命令来计划执行作业　　347\n16.6.2　安排需要定期执行的脚本　　349\n16.6.3　使用新shell启动脚本　　352\n16.7　小结　　353\n第三部分　高级shell脚本编程\n第17章　创建函数　　356\n17.1　基本的脚本函数　　356\n17.1.1　创建函数　　357\n17.1.2　使用函数　　357\n17.2　返回值　　359\n17.2.1　默认退出状态码　　359\n17.2.2　使用return命令　　360\n17.2.3　使用函数输出　　361\n17.3　在函数中使用变量　　362\n17.3.1　向函数传递参数　　362\n17.3.2　在函数中处理变量　　364\n17.4　数组变量和函数　　366\n17.4.1　向函数传数组参数　　366\n17.4.2　从函数返回数组　　368\n17.5　函数递归　　369\n17.6　创建库　　370\n17.7　在命令行上使用函数　　371\n17.7.1　在命令行上创建函数　　372\n17.7.2　在.bashrc文件中定义函数　　372\n17.8　实例　　374\n17.8.1　下载及安装　　374\n17.8.2　构建库　　374\n17.8.3　shtool库函数　　376\n17.8.4　使用库　　376\n17.9　小结　　377\n第18章　图形化桌面环境中的脚本编程　　378\n18.1　创建文本菜单　　378\n18.1.1　创建菜单布局　　379\n18.1.2　创建菜单函数　　380\n18.1.3　添加菜单逻辑　　380\n18.1.4　整合shell脚本菜单　　381\n18.1.5　使用select命令　　382\n18.2　制作窗口　　384\n18.2.1　dialog包　　384\n18.2.2　dialog选项　　389\n18.2.3　在脚本中使用dialog命令　　391\n18.3　使用图形　　393\n18.3.1　KDE环境　　393\n18.3.2　GNOME环境　　396\n18.4　小结　　400\n第19章　初识sed和gawk　　401\n19.1　文本处理　　401\n19.1.1　sed编辑器　　401\n19.1.2　gawk程序　　404\n19.2　sed编辑器基础　　410\n19.2.1　更多的替换选项　　410\n19.2.2　使用地址　　411\n19.2.3　删除行　　414\n19.2.4　插入和附加文本　　415\n19.2.5　修改行　　417\n19.2.6　转换命令　　418\n19.2.7　回顾打印　　419\n19.2.8　使用sed处理文件　　421\n19.3　小结　　423\n第20章　正则表达式　　424\n20.1　什么是正则表达式　　424\n20.1.1　定义　　424\n20.1.2　正则表达式的类型　　425\n20.2　定义BRE模式　　426\n20.2.1　纯文本　　426\n20.2.2　特殊字符　　427\n20.2.3　锚字符　　428\n20.2.4　点号字符　　430\n20.2.5　字符组　　430\n20.2.6　排除型字符组　　432\n20.2.7　区间　　433\n20.2.8　特殊的字符组　　434\n20.2.9　星号　　434\n20.3　扩展正则表达式　　436\n20.3.1　问号　　436\n20.3.2　加号　　437\n20.3.3　使用花括号　　437\n20.3.4　管道符号　　438\n20.3.5　表达式分组　　439\n20.4　正则表达式实战　　439\n20.4.1　目录文件计数　　440\n20.4.2　验证电话号码　　441\n20.4.3　解析邮件地址　　443\n20.5　小结　　444\n第21章　sed进阶　　445\n21.1　多行命令　　445\n21.1.1　next命令　　446\n21.1.2　多行删除命令　　449\n21.1.3　多行打印命令　　449\n21.2　保持空间　　450\n21.3　排除命令　　451\n21.4　改变流　　454\n21.4.1　分支　　454\n21.4.2　测试　　455\n21.5　模式替代　　456\n21.5.1　&符号　　457\n21.5.2　替代单独的单词　　457\n21.6　在脚本中使用sed　　458\n21.6.1　使用包装脚本　　458\n21.6.2　重定向sed的输出　　459\n21.7　创建sed实用工具　　460\n21.7.1　加倍行间距　　460\n21.7.2　对可能含有空白行的文件加倍行间距　　460\n21.7.3　给文件中的行编号　　461\n21.7.4　打印末尾行　　462\n21.7.5　删除行　　463\n21.7.6　删除HTML标签　　466\n21.8　小结　　467\n第22章　gawk进阶　　469\n22.1　使用变量　　469\n22.1.1　内建变量　　469\n22.1.2　自定义变量　　474\n22.2　处理数组　　476\n22.2.1　定义数组变量　　476\n22.2.2　遍历数组变量　　477\n22.2.3　删除数组变量　　478\n22.3　使用模式　　478\n22.3.1　正则表达式　　478\n22.3.2　匹配操作符　　479\n22.3.3　数学表达式　　480\n22.4　结构化命令　　480\n22.4.1　if语句　　480\n22.4.2　while语句　　482\n22.4.3　do-while语句　　483\n22.4.4　for语句　　484\n22.5　格式化打印　　484\n22.6　内建函数　　487\n22.6.1　数学函数　　487\n22.6.2　字符串函数　　488\n22.6.3　时间函数　　490\n22.7　自定义函数　　490\n22.7.1　定义函数　　490\n22.7.2　使用自定义函数　　491\n22.7.3　创建函数库　　491\n22.8　实例　　492\n22.9　小结　　493\n第23章　使用其他shell　　495\n23.1　什么是dash shell　　495\n23.2　dash shell的特性　　496\n23.2.1　dash命令行参数　　496\n23.2.2　dash环境变量　　497\n23.2.3　dash内建命令　　499\n23.3　dash脚本编程　　500\n23.3.1　创建dash脚本　　500\n23.3.2　不能使用的功能　　500\n23.4　zsh shell　　502\n23.5　zsh shell的组成　　503\n23.5.1　shell选项　　503\n23.5.2　内建命令　　504\n23.6　zsh脚本编程　　508\n23.6.1　数学运算　　508\n23.6.2　结构化命令　　509\n23.6.3　函数　　510\n23.7　小结　　510\n第四部分　创建实用的脚本\n第24章　编写简单的脚本实用工具　　514\n24.1　归档　　514\n24.2　管理用户账户　　523\n24.2.1　需要的功能　　523\n24.2.2　创建脚本　　530\n24.2.3　运行脚本　　535\n24.3　监测磁盘空间　　537\n24.3.1　需要的功能　　537\n24.3.2　创建脚本　　540\n24.3.3　运行脚本　　541\n24.4　小结　　542\n第25章　创建与数据库、Web及电子\n邮件相关的脚本　　543\n25.1　MySQL数据库　　543\n25.1.1　使用MySQL　　543\n25.1.2　在脚本中使用数据库　　552\n25.2　使用Web　　555\n25.2.1　安装Lynx　　556\n25.2.2　lynx命令行　　557\n25.2.3　Lynx配置文件　　558\n25.2.4　从Lynx中获取数据　　559\n25.3　使用电子邮件　　561\n25.4　小结　　564\n第26章　一些小有意思的脚本　　565\n26.1　发送消息　　565\n26.1.1　功能分析　　565\n26.1.2　创建脚本　　568\n26.2　获取格言　　573\n26.2.1　功能分析　　574\n26.2.2　创建脚本　　577\n26.3　编造借口　　583\n26.3.1　功能分析　　583\n26.3.2　创建脚本　　586\n26.4　小结　　587\n附录A　bash命令快速指南　　589\n附录B　sed和gawk快速指南　　597",
    "pages": "605",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29584559.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29584559.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29584559.jpg"
    },
    "alt": "https://book.douban.com/subject/26854226/",
    "id": "26854226",
    "publisher": "人民邮电出版社",
    "isbn10": "7115429677",
    "isbn13": "9787115429674",
    "title": "Linux命令行与shell脚本编程大全 第3版",
    "url": "https://api.douban.com/v2/book/26854226",
    "alt_title": "",
    "author_intro": "作者简介：\nRicahard Blum\n已在IT行业打拼20余年，担任过UNIX、Linux、Novell和Windows Server的系统及网络管理员，在Linux和开源软件领域著作颇丰。他还是一名网络课程讲师，美国多所大学和学院都采用他的Linux基础课程。\nChristine Bresnahan\n系统管理员，已经在IT行业工作了30余年，通过CompTIA Linux+、LPIC-1、Linux Essentials认证。目前在印第安纳波利斯市常春藤技术社区学院担任兼职教授，讲授Linux系统管理、Linux安全和Windows安全、Python编程等课程。\n译者简介：\n门佳\n资深GNU/Linux用户，喜欢溯本求源，挖掘技术背后的细节。作为技术爱好者，对编译技术、Linux系统编程、Perl、网络协议分析、Web开发等均有涉猎，译有《Linux Shell脚本攻略》《TCP Sockets编程》《精通JavaScript》等书。\n武海峰\n美团大众点评EP团队创建者和负责人，关注移动互联应用和安全，热爱开源软件和GNU/Linux。坚信只有同时对用户使用场景和底层实现技术有深入理解才能成为可靠的Gatekeeper。目前正致力于提升新美大的研发质量和交付速度。",
    "summary": "这是一本关于Linux命令行与shell脚本编程的全方位教程，主要包括四大部分：Linux命令行，shell脚本编程基础，高级shell脚本编程，如何创建实用的shell脚本。本书针对Linux系统的最新特性进行了全面更新，不仅涵盖了详尽的动手教程和现实世界中的实用信息，还提供了与所学内容相关的参考信息和背景资料。通过本书的学习，你将轻松写出自己的shell脚本。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "CNY 109.00"
  },
  "9787564115197": {
    "rating": { "max": 10, "numRaters": 95, "average": "8.0", "min": 0 },
    "subtitle": "LINUX系统编程",
    "author": ["Robert Love"],
    "pubdate": "2009-7",
    "tags": [
      { "count": 141, "name": "Linux", "title": "Linux" },
      { "count": 78, "name": "系统编程", "title": "系统编程" },
      { "count": 64, "name": "编程", "title": "编程" },
      { "count": 48, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 40, "name": "操作系统", "title": "操作系统" },
      { "count": 38, "name": "计算机", "title": "计算机" },
      { "count": 30, "name": "linux", "title": "linux" },
      { "count": 26, "name": "Programming", "title": "Programming" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s26696540.jpg",
    "binding": "",
    "translator": ["O'Reilly Taiwan公司"],
    "catalog": "序\n前言\n第一章 介绍与基本概念\n系统编程\nAPI与ABI\n标准\nLinux编程的概念\n向系统编程迈进\n第二章 文件I／O\n打开文件\n以read()进行读取操作\n以write()进行写入操作\n同步化I／O\n关闭文件\n使用lseek()查找文件位置\n针对特定位置的读取与写入\n截短文件\n多任务式I／O\n内核内部\n结束语\n第三章 缓冲式I／O\n用户缓冲式I／O\n标准I／O\n打开文件\n经文件描述符打开流\n关闭流\n从流中读取\n使用缓冲式I／O的简单程序\n查找一个流\n刷新一个流\n错误与EOF\n取得相应的文件描述符\n控制与缓冲机制\n线程安全\n标准I／O的缺陷\n结束语\n第四章 高级文件I／O\n分散一聚集I／O\n事件轮询接口\n将文件映射至内存\n对一般文件I／0的用法提供建议\n同步化、同步及异步操作\nI／O调度程序与I／O性能\n结束语\n第五章 进程管理\n进程ID\n运行一个新进程\n终止一个进程\n等待已终止的子进程\n用户与组\n会话与进程组\n守护进程\n结束语\n第六章 高级进程管理\n进程的调度\n让出处理器\n进程优先级\n实时系统\n资源限制\n第七章 文件和目录管理\n文件与其元数据\n目录\n链接\n文件的复制以及移动\n设备节点\n带外通信\n第八章 内存管理\n进程地址空间\n分配动态内存\n管理数据段\n匿名内存映射\n高级内存分配\n调试内存分配\n基于堆栈的分配\n选择内存分配机制\n操作内存\n锁定内存\n投机取巧的分配策略\n第九章 信号\n信号的概念\n基本的信号管理\n发送一个信号\n可重人性\n信号集\n阻挡信号\n高级信号管理\n以payload送出信号\n结束语\n第十章 时间\n时间的数据结构\nPOSIX时钟\n取得当前时间\n设定当前时间\n操作时间\n调整系统时钟\n休眠与等待\n定时器\n附录GCC对C语言的扩展\n参考书目",
    "pages": "382",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s26696540.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s26696540.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s26696540.jpg"
    },
    "alt": "https://book.douban.com/subject/3907181/",
    "id": "3907181",
    "publisher": "东南大学出版社",
    "isbn10": "756411519X",
    "isbn13": "9787564115197",
    "title": "LINUX系统编程",
    "url": "https://api.douban.com/v2/book/3907181",
    "alt_title": "",
    "author_intro": "",
    "summary": "《LINUX系统编程》讲述了：在某些时刻，几乎所有的程序员都要与其程序所处操作系统中的系统调用和程序库打交道。《LINUX系统编程》主要讨论如何编写Linux系统软件——代码位于底层，并且直接跟内核及核心系统程序库对话。《Linux系统编程》描述了使用标准接口包括使用Linux独有的高级接口时，在功能和性能之间如何进行权衡取舍的策略。\n该书同样也是一本内行人士编写灵活高效代码的学习指南。作为内核黑客和《LINUX系统编程》的作者，Robert Love不仅阐释了系统接口应该如何工作，还介绍了它们实际上是如何工作的，以及怎样安全有效地使用它们。《Linux系统编程》包含了帮助你在任何层面编写更佳代码的实用技巧。\n《LINUX系统编程》主题包括：\n读写文件以及其他文件I／O操作，包括Linux内核如何实现和管理文件I／O，内存映射与优化\n技术进程管理的系统调用，包括实时进程\n文件与目录——创建、移动、复制、删除和管理\n内存管理——内存分配接口，管理内存，以及优化内存访问\n信号及其在Unix系统中的角色，以及基本和高级信号接口\n时间、休眠和时钟管理，从基础开始讲述，并且涵盖POSIX时钟和高精度计时器拥有《Linux系统编程》，你将从理论和应用的角度深入了解Linux，可以最大限度地利用系统的潜能。",
    "price": "56.00元"
  },
  "9787115352118": {
    "rating": { "max": 10, "numRaters": 232, "average": "9.5", "min": 0 },
    "subtitle": "",
    "author": ["史蒂文斯 (W.Richard Stevens)", "拉戈 (Stephen A.Rago)"],
    "pubdate": "2014-6-1",
    "tags": [
      { "count": 214, "name": "Unix", "title": "Unix" },
      { "count": 201, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 198, "name": "编程", "title": "编程" },
      { "count": 119, "name": "计算机", "title": "计算机" },
      { "count": 90, "name": "计算机科学", "title": "计算机科学" },
      { "count": 88, "name": "程序设计", "title": "程序设计" },
      { "count": 85, "name": "Linux", "title": "Linux" },
      { "count": 74, "name": "C", "title": "C" }
    ],
    "origin_title": "Advanced Programming in the UNIX Environment, Third Edition",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28284137.jpg",
    "binding": "平装",
    "translator": ["戚正伟", "张亚英", "尤晋元"],
    "catalog": "第1章 UNIX基础知识\n1.1 引言\n1.2 UNIX体系结构\n1.3 登录\n1.4 文件和目录\n1.5 输入和输出\n1.6 程序和进程\n1.7 出错处理\n1.8 用户标识\n1.9 信号\n1.10 时间值\n1.11 系统调用和库函数\n1.12 小结\n习题\n第2章 UNIX标准及实现\n2.1 引言\n2.2 UNIX标准化\n2.2.1 ISO C\n2.2.2 IEEE POSIX\n2.2.3 Single UNIX Specification\n2.2.4 FIPS\n2.3 UNIX系统实现\n2.3.1 SVR4\n2.3.2 4.4BSD\n2.3.3 FreeBSD\n2.3.4 Linux\n2.3.5 Mac OS X\n2.3.6 Solaris\n2.3.7 其他UNIX系统\n2.4 标准和实现的关系\n2.5 限制\n2.5.1 ISO C限制\n2.5.2 POSIX限制\n2.5.3 XSI限制\n2.5.4 函数sysconf、pathconf和fpathconf\n2.5.5 不确定的运行时限制\n2.6 选项\n2.7 功能测试宏\n2.8 基本系统数据类型\n2.9 标准之间的冲突\n2.10 小结\n习题\n第3章 文件I/O\n3.1 引言\n3.2 文件描述符\n3.3 函数open和openat\n3.4 函数creat\n3.5 函数close\n3.6 函数lseek\n3.7 函数read\n3.8 函数write\n3.9 I/O的效率\n3.10 文件共享\n3.11 原子操作\n3.12 函数dup和dup2\n3.13 函数sync、fsync和fdatasync\n3.14 函数fcntl\n3.15 函数ioctl\n3.16 /dev/fd\n3.17 小结\n习题\n第4章 文件和目录\n4.1 引言\n4.2 函数stat、fstat、fstatat和lstat\n4.3 文件类型\n4.4 设置用户ID和设置组ID\n4.5 文件访问权限\n4.6 新文件和目录的所有权\n4.7 函数access和faccessat\n4.8 函数umask\n4.9 函数chmod、fchmod和fchmodat\n4.10 粘着位\n4.11 函数chown、fchown、fchownat和lchown\n4.12 文件长度\n4.13 文件截断\n4.14 文件系统\n4.15 函数link、linkat、unlink、unlinkat和remove\n4.16 函数rename和renameat\n4.17 符号链接\n4.18 创建和读取符号链接\n4.19 文件的时间\n4.20 函数futimens、utimensat和utimes\n4.21 函数mkdir、mkdirat和rmdir\n4.22 读目录\n4.23 函数chdir、fchdir和getcwd\n4.24 设备特殊文件\n4.25 文件访问权限位小结\n4.26 小结\n习题\n第5章 标准I/O库\n5.1 引言\n5.2 流和FILE对象\n5.3 标准输入、标准输出和标准错误\n5.4 缓冲\n5.5 打开流\n5.6 读和写流\n5.7 每次一行I/O\n5.8 标准I/O的效率\n5.9 二进制I/O\n5.10 定位流\n5.11 格式化I/O\n5.12 实现细节\n5.13 临时文件\n5.14 内存流\n5.15 标准I/O的替代软件\n5.16 小结\n习题\n第6章 系统数据文件和信息\n6.1 引言\n6.2 口令文件\n6.3 阴影口令\n6.4 组文件\n6.5 附属组ID\n6.6 实现区别\n6.7 其他数据文件\n6.8 登录账户记录\n6.9 系统标识\n6.10 时间和日期例程\n6.11 小结\n习题\n第7章 进程环境\n7.1 引言\n7.2 main函数\n7.3 进程终止\n7.4 命令行参数\n7.5 环境表\n7.6 C程序的存储空间布局\n7.7 共享库\n7.8 存储空间分配\n7.9 环境变量\n7.10 函数setjmp和longjmp\n7.11 函数getrlimit和setrlimit\n7.12 小结\n习题\n第8章 进程控制\n8.1 引言\n8.2 进程标识\n8.3 函数fork\n8.4 函数vfork\n8.5 函数exit\n8.6 函数wait和waitpid\n8.7 函数waitid\n8.8 函数wait3和wait4\n8.9 竞争条件\n8.10 函数exec\n8.11 更改用户ID和更改组ID\n8.12 解释器文件\n8.13 函数system\n8.14 进程会计\n8.15 用户标识\n8.16 进程调度\n8.17 进程时间\n8.18 小结\n习题\n第9章 进程关系\n9.1 引言\n9.2 终端登录\n9.3 网络登录\n9.4 进程组\n9.5 会话\n9.6 控制终端\n9.7 函数tcgetpgrp、tcsetpgrp和tcgetsid\n9.8 作业控制\n9.9 shell执行程序\n9.10 孤儿进程组\n9.11 FreeBSD实现\n9.12 小结\n习题\n第10章 信号\n10.1 引言\n10.2 信号概念\n10.3 函数signal\n10.4 不可靠的信号\n10.5 中断的系统调用\n10.6 可重入函数\n10.7 SIGCLD语义\n10.8 可靠信号术语和语义\n10.9 函数kill和raise\n10.10 函数alarm和pause\n10.11 信号集\n10.12 函数sigprocmask\n10.13 函数sigpending\n10.14 函数sigaction\n10.15 函数sigsetjmp和siglongjmp\n10.16 函数sigsuspend\n10.17 函数abort\n10.18 函数system\n10.19 函数sleep、nanosleep和clock_nanosleep\n10.20 函数sigqueue\n10.21 作业控制信号\n10.22 信号名和编号\n10.23 小结\n习题\n第11章 线程\n11.1 引言\n11.2 线程概念\n11.3 线程标识\n11.4 线程创建\n11.5 线程终止\n11.6 线程同步\n11.6.1 互斥量\n11.6.2 避免死锁\n11.6.3 函数pthread_mutex_timedlock\n11.6.4 读写锁\n11.6.5 带有超时的读写锁\n11.6.6 条件变量\n11.6.7 自旋锁\n11.6.8 屏障\n11.7 小结\n习题\n第12章 线程控制\n12.1 引言\n12.2 线程限制\n12.3 线程属性\n12.4 同步属性\n12.4.1 互斥量属性\n12.4.2 读写锁属性\n12.4.3 条件变量属性\n12.4.4 屏障属性\n12.5 重入\n12.6 线程特定数据\n12.7 取消选项\n12.8 线程和信号\n12.9 线程和fork\n12.10 线程和I/O\n12.11 小结\n习题\n第13章 守护进程\n13.1 引言\n13.2 守护进程的特征\n13.3 编程规则\n13.4 出错记录\n13.5 单实例守护进程\n13.6 守护进程的惯例\n13.7 客户进程-服务器进程模型\n13.8 小结\n习题\n第14章 高级I/O\n14.1 引言\n14.2 非阻塞I/O\n14.3 记录锁\n14.4 I/O多路转接\n14.4.1 函数select和pselect\n14.4.2 函数poll\n14.5 异步I/O\n14.5.1 System V异步I/O\n14.5.2 BSD异步I/O\n14.5.3 POSIX异步I/O\n14.6 函数readv和writev\n14.7 函数readn和writen\n14.8 存储映射I/O\n14.9 小结",
    "pages": "812",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28284137.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28284137.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28284137.jpg"
    },
    "alt": "https://book.douban.com/subject/25900403/",
    "id": "25900403",
    "publisher": "人民邮电出版社",
    "isbn10": "7115352119",
    "isbn13": "9787115352118",
    "title": "UNIX环境高级编程（第3版）",
    "url": "https://api.douban.com/v2/book/25900403",
    "alt_title": "Advanced Programming in the UNIX Environment, Third Edition",
    "author_intro": "作者介绍\nW. Richard Stevens，国际知名的UNIX和网络专家，备受赞誉的技术作家。生前著有多部经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP/IP详解》（三卷本）和本书第1版。\nStephen A. Rago，资深UNIX程序员，目前任NEC美国实验室存储系统集团研究员。之前是贝尔实验室的UNIX系统V版本4的开发人员之一。著有《UNIX系统V网络编程》，并曾担任本书第1版的技术审校和第2版的共同作者。\n译者介绍\n戚正伟，博士，上海交通大学软件学院副教授，微软亚洲研究院（2008）和美国CMU大学（2011-2012）访问学者。研究方向为系统软件和程序分析，著有《New Blue Pill深入理解硬件虚拟机》和《嵌入式GIS开发及应用》等书。\n张亚英，博士，同济大学电子与信息工程学院计算机系副教授，研究方向为分布与移动计算、嵌入式系统以及系统软件等。\n尤晋元，上海交通大学计算机科学及工程系教授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究。在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。",
    "summary": "《UNIX环境高级编程（第3版）》是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的第3版。在本书第2版出版后的8年中，UNIX行业发生了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了众多应用实例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。\n《UNIX环境高级编程（第3版）》内容权威，概念清晰，阐述精辟，对于所有层次UNIX/Linux程序员都是一本不可或缺的参考书。\n适读人群 ：所有层次UNIX/Linux程序员\n20多年来，严谨的C程序员都是依靠一本书来深入了解驱动UNIX和Linux内核的编程接口的实用知识的，这本书就是W. Richard Stevens所著的《UNIX高级环境编程》。现在，Stevens的同事Steve Rago彻底更新了这本经典著作。新的第3版支持当今领先的系统平台，反映了最新技术进展和最佳实践，并且符合最新的Single UNIX Specification第4版（SUSv4）。\nRago保留了使本书前版成为经典之作的精髓和方法。他在Stevens原著的基础上，从基础的文件、目录和进程讲起，并给诸如信号处理和终端I/O之类的先进技术保留较大的篇幅。他还深入讨论了线程和多线程编程、使用套接字接口驱动进程间通信（IPC）等方面的内容。\n这一版涵盖了70多个最新版POSIX.1标准的新增接口，包括POSIX异步I/O、旋转锁、屏障（barrier）和POSIX信号量。此外，这一版删除了许多过时的接口，保留了一些广泛使用的接口。书中几乎所有实例都已经在目前最主流的4个平台上测试过，包括Solaris 10、Mac OS X 10.6.8（Darwin 10.8.0）、FressBSD 8.0、Ubuntu 12.04（基于Linux 3.2内核）。\n与前两版一样，读者仍可以通过实例学习，这些实例包括了1万多行可下载的ISO C源代码，书中通过简明但完整的程序阐述了400多个系统调用和函数，清楚地说明它们的用法、参数和返回值。为了使读者能融会贯通，书中还提供了几个贯穿整章的案例，每个案例都根据现在的技术环境进行了全面更新。\n《UNIX环境高级编程（第3版）》帮助了几代程序员写出强大、高性能、可靠的代码。第3版根据当今主流系统进行更新，更具实用价值。\n精彩书评：\n本书第1版连同Stevens所著的系列网络技术书籍，被公认为优秀的、匠心独具的名著，成为极其畅销的作品……总之，这是一本弥足珍贵的经典著作的更新版。\n——Dennis Ritchie，图灵奖得主，UNIX操作系统和C语言之父\n对任何一个严谨的、专业的UNIX系统程序员而言，本书都是不可或缺的权威参考书。Rago更新和扩展了Stevens的经典著作，并保持了原书的风貌。书中利用清晰的实例演示了API的使用过程，还提到了许多在不同UNIX系统实现上编程时需要注意的陷阱，并指出如何使用相关的标准（如POSIX 1003.1 2004版和Single UNIX Specification第3版）来避免这些错误。\n——Andrew Josey， The Open Group标准部门主管，POSIX 1003.1标准工作组主席\n绝对的UNIX编程经典之一。\n——Eric S. Raymond，《UNIX编程艺术》作者\nStephen Rago的更新版本对于使用众多UNIX及相关操作系统环境的广大专业用户来说是一个迟来的喜讯。这一版不仅删除了过时的接口，吸纳了较新的开发接口，还根据UNIX及类UNIX操作系统环境的几种主流实现发布的新版本全面更新了所有主题、实例和应用的背景。难能可贵的是，这一版本还保持了经典的第1版的风格和品位。\n——Mukesh Kacker，Pronto Networks公司联合创始人和前任CTO\n本书对于任何在UNIX系统上编写程序的开发人员来说都是非常重要的参考书。当我想要了解或者重新回顾各种系统接口时，这本书是首选的求助工具。Stephen Rago成功地修订了本书，使其与新的操作系统（如GNU/Linux和苹果的OS X）相容，并保持了第1版易读和实用的特质。它将永远摆放在我桌上随手可及的位置。\n——Benjamin Kuperman博士，斯沃斯莫尔学院\n这是每一位严谨的UNIX C程序员必备的书籍。它深入、全面、清晰的解释是无可匹敌的。\n——UniForum Monthly\n从W. Richard Stevens的这本书中可以找到更多易于理解的、详尽的UNIX系统内部细节。这本书包含了大量实际的例子，对系统编程工作非常有益。\n——RS/Magazine",
    "price": "128.00元"
  },
  "9787115394927": {
    "rating": { "max": 10, "numRaters": 67, "average": "8.1", "min": 0 },
    "subtitle": "",
    "author": ["[美] Brian Ward"],
    "pubdate": "2015-7",
    "tags": [
      { "count": 48, "name": "Linux", "title": "Linux" },
      { "count": 19, "name": "计算机", "title": "计算机" },
      { "count": 19, "name": "操作系统", "title": "操作系统" },
      { "count": 18, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 9, "name": "计算机技术", "title": "计算机技术" },
      { "count": 6, "name": "编程", "title": "编程" },
      { "count": 6, "name": "技术", "title": "技术" },
      { "count": 4, "name": "tt", "title": "tt" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28231090.jpg",
    "binding": "平装",
    "translator": ["姜南", "袁志鹏"],
    "catalog": "第1章　概述　　1\n1.1　Linux操作系统中的抽象级别和层次　　2\n1.2　硬件系统：理解主内存　　3\n1.3　内核　　3\n1.3.1　进程管理　　4\n1.3.2　内存管理　　5\n1.3.3　设备驱动程序和设备管理　　5\n1.3.4　系统调用和系统支持　　5\n1.4　用户空间　　6\n1.5　用户　　7\n1.6　前瞻　　8\n第2章　基础命令和目录结构　　9\n2.1　Bourne shell: /bin/sh　　9\n2.2　shell的使用　　10\n2.2.1　shell窗口　　10\n2.2.2　cat命令　　11\n2.2.3　标准输入输出　　11\n2.3　基础命令　　11\n2.3.1　ls命令　　12\n2.3.2　cp命令　　12\n2.3.3　mv命令　　12\n2.3.4　touch命令　　13\n2.3.5　rm命令　　13\n2.3.6　echo命令　　13\n2.4　浏览目录　　13\n2.4.1　cd命令　　14\n2.4.2　mkdir命令　　14\n2.4.3　rmdir命令　　14\n2.4.4　shell通配符　　14\n2.5　中间命令　　15\n2.5.1　grep命令　　15\n2.5.2　less命令　　16\n2.5.3　pwd命令　　16\n2.5.4　diff命令　　16\n2.5.5　file命令　　17\n2.5.6　find和locate命令　　17\n2.5.7　head和tail命令　　17\n2.5.8　sort命令　　17\n2.6　更改密码和shell　　18\n2.7　dot文件　　18\n2.8　环境变量和shell变量　　18\n2.9　命令路径　　19\n2.10　特殊字符　　19\n2.11　命令行编辑　　20\n2.12　文本编辑器　　21\n2.13　获取在线帮助　　21\n2.14　shell输入输出　　23\n2.14.1　标准错误输出　　23\n2.14.2　标准输入重定向　　24\n2.15　理解错误信息　　24\n2.15.1　解析Unix的错误信息　　24\n2.15.2　常见错误　　25\n2.16　查看和操纵进程　　26\n2.16.1　命令选项　　26\n2.16.2　终止进程　　27\n2.16.3　任务控制　　27\n2.16.4　后台进程　　28\n2.17　文件模式和权限　　28\n2.17.1　更改文件权限　　29\n2.17.2　符号链接　　30\n2.17.3　创建符号链接　　30\n2.18　归档和压缩文件　　31\n2.18.1　gzip命令　　31\n2.18.2　tar命令　　31\n2.18.3　压缩归档文件（.tar.gz）　　32\n2.18.4　zcat命令　　32\n2.18.5　其他的压缩命令　　33\n2.19　Linux目录结构基础　　33\n2.19.1　root目录下的其他目录　　34\n2.19.2　/usr目录　　35\n2.19.3　内核位置　　35\n2.20　以超级用户的身份运行命令　　35\n2.20.1　sudo命令　　35\n2.20.2　/etc/sudoers　　35\n2.21 前瞻　　36\n第3章　设备管理　　37\n3.1　设备文件　　37\n3.2　sysfs设备路径　　38\n3.3　dd命令和设备　　39\n3.4　设备名总结　　40\n3.4.1　硬盘：/dev/sd*　　40\n3.4.2　CD和DVD：/dev/sr*　　41\n3.4.3　PATA 硬盘：/dev/hd*　　41\n3.4.4　终端设备/dev/tty/*、/dev/pts/*和/dev/tty　　41\n3.4.5　串行端口：/dev/ttyS*　　42\n3.4.6　并行端口：/dev/lp0 和/dev/lp1　　42\n3.4.7　音频设备：/dev/snd/*、/dev/dsp、/dev/audio 和其他　　43\n3.4.8　创建设备文件　　43\n3.5　udev　　44\n3.5.1　devtmpfs　　44\n3.5.2　udevd的操作和配置　　44\n3.5.3　udevadm　　46\n3.5.4　设备监控　　47\n3.6　详解SCSI和Linux内核　　47\n3.6.1　USB存储设备和SCSI　　50\n3.6.2　SCSI和ATA　　50\n3.6.3　通用SCSI设备　　51\n3.6.4　访问设备的多种方法　　51\n第4章　硬盘和文件系统　　53\n4.1　为磁盘设备分区　　55\n4.1.1　查看分区表　　55\n4.1.2　更改分区表　　56\n4.1.3　磁盘和分区的构造　　57\n4.1.4　固态硬盘　　58\n4.2　文件系统　　59\n4.2.1　文件系统类型　　59\n4.2.2　创建文件系统　　60\n4.2.3　挂载文件系统　　60\n4.2.4　文件系统UUID 　　62\n4.2.5　磁盘缓冲、缓存和文件系统　　 62\n4.2.6　文件系统挂载选项　　63\n4.2.7　重新挂载文件系统　　64\n4.2.8　/etc/fstab文件系统表　　64\n4.2.9　/etc/fstab的替代者　　65\n4.2.10　文件系统容量　　65\n4.2.11　检查和修复文件系统.66\n4.2.12　特殊用途的文件系统.68\n4.3　交换空间　　68\n4.3.1　使用磁盘分区作为交换空间　　 69\n4.3.2　使用文件作为交换空间　　 69\n4.3.3　你需要多大的交换空间　　 69\n4.4　前瞻：磁盘和用户空间　　70\n4.5　深入传统文件系统　　70\n4.5.1　查看inode细节　　72\n4.5.2　在用户空间中使用文件系统　　 73\n4.5.3　文件系统的演进　　73\n第5章　Linux内核的启动　　75\n5.1　启动消息　　75\n5.2　内核初始化和启动选项　　76\n5.3　内核参数　　77\n5.4　引导装载程序　　78\n5.4.1　引导装载程序任务　　78\n5.4.2　引导装载程序概述　　79\n5.5　GRUB 简介　　79\n5.5.1　使用GRUB命令行浏览设备和分区　　81\n5.5.2　GRUB配置信息　　83\n5.5.3　安装GRUB　　84\n5.6　UEFI 安全启动的问题　　86\n5.7　链式加载其他操作系统　　86\n5.8　引导装载程序细节　　86\n5.8.1　MBR启动　　87\n5.8.2　UEFI启动　　87\n5.8.3　GRUB工作原理　　87\n第6章　用户空间的启动　　89\n6.1　init介绍　　89\n6.2　System V运行级别　　90\n6.3　识别你的init　　91\n6.4　systemd　　91\n6.4.1　单元和单元类型　　91\n6.4.2　systemd中的依赖关系　　92\n6.4.3　systemd配置　　94\n6.4.4　systemd操作　　96\n6.4.5　在systemd中添加单元　　98\n6.4.6　systemd进程跟踪和同步　　99\n6.4.7　systemd的按需和资源并行启动　　99\n6.4.8　systemd的System V兼容性　　103\n6.4.9　systemd辅助程序　　103\n6.5　Upstart　　104\n6.5.1　Upstart初始化过程　　104\n6.5.2　Upstart任务　　105\n6.5.3　Upstart配置　　107\n6.5.4　Upstart操作　　110\n6.5.5　Upstart日志　　111\n6.5.6　Upstart运行级别和System V兼容性　　111\n6.6　System V init　　112\n6.6.1　System V init启动命令顺序　　113\n6.6.2　System V init链接池　　114\n6.6.3　run-parts　　115\n6.6.4　System V init控制　　115\n6.7　关闭系统　　116\n6.8　initramfs　　117\n6.9　紧急启动和单用户模式　　118\n第7章　系统配置：日志、系统时间、批处理任务和用户　　119\n7.1　/etc目录结构　　119\n7.2　系统日志　　120\n7.2.1　系统日志　　120\n7.2.2　配置文件　　120\n7.3　用户管理文件　　122\n7.3.1　/etc/passwd文件　　122\n7.3.2　特殊用户　　123\n7.3.3　/etc/shadow文件　　124\n7.3.4　用户和密码管理　　124\n7.3.5　用户组　　124\n7.4　getty和login　　125\n7.5　设置时间　　125\n7.5.1　内核时间和时区　　126\n7.5.2　网络时间　　127\n7.6　使用cron来调度日常任务　　127\n7.6.1　安装crontab文件　　128\n7.6.2　系统crontab文件　　128\n7.6.3　cron的未来　　129\n7.7　使用at进行一次性任务调度　　129\n7.8　了解用户ID和用户切换　　129\n7.9　用户标识和认证　　131\n7.10　PAM　　132\n7.10.1　PAM配置　　133\n7.10.2　关于PAM的一些注解　　135\n7.10.3　PAM和密码　　136\n7.11　前瞻　　136\n第8章　进程与资源利用详解　　137\n8.1　进程跟踪　　137\n8.2　使用lsof 查看打开的文件　　138\n8.2.1　lsof输出　　138\n8.2.2　lsof的使用　　139\n8.3　跟踪程序执行和系统调用　　139\n8.3.1　strace命令　　139\n8.3.2　ltrace命令　　141\n8.4　线程　　141\n8.4.1　单线程进程和多线程进程　　141\n8.4.2　查看线程　　142\n8.5　资源监控简介　　143\n8.6　测量CPU时间　　143\n8.7　调整进程优先级　　144\n8.8　平均负载　　145\n8.8.1　uptime的使用　　145\n8.8.2　高负载　　145\n8.9　内存　　146\n8.9.1　内存工作原理　　146\n8.9.2　内存页面错误　　146\n8.10　使用vmstat监控CPU和内存性能　　147\n8.11　I/O监控　　149\n8.11.1　使用iostat　　149\n8.11.2　使用iotop查看进程的I/O使用和监控　　150\n8.12　使用pidstat监控进程　　151\n8.13　更深入的主题　　151\n第9章　网络与配置　　153\n9.1　网络基础　　153\n9.2　网络层次　　154\n9.3　网际层　　155\n9.3.1　查看自己计算机的IP 地址　　156\n9.3.2　子网　　157\n9.3.3　共用子网掩码与无类域内路由选择　　157\n9.4　路由和内核路由表　　158\n9.5　基本ICMP和DNS工具　　159\n9.5.1　ping　　159\n9.5.2　traceroute　　160\n9.5.3　DNS与host　　160\n9.6　物理层与以太网　　161\n9.7　理解内核网络接口　　161\n9.8　配置网络接口　　162\n9.9　开机启动的网络配置　　163\n9.10　手动和开机启动的网络配置带来的问题　　163\n9.11　一些网络配置管理器　　164\n9.11.1　NetworkManager的操作　　164\n9.11.2　与NetworkManager交互　　164\n9.11.3　NetworkManager的配置　　165\n9.12　解析主机名　　166\n9.12.1　/etc/hosts　　167\n9.12.2　resolv.conf 文件　　167\n9.12.3　缓存和零配置DNS　　167\n9.12.4　/etc/nsswitch.conf文件　　168\n9.13　Localhost　　168\n9.14　传输层：TCP、UDP和Service　　169\n9.14.1　TCP 端口与连接　　169\n9.14.2　建立TCP连接　　169\n9.14.3　端口的数字和/etc/services 　　170\n9.14.4　TCP的特点　　171\n9.14.5　UDP　　171\n9.15　普通本地网络　　172\n9.16　理解DHCP　　173\n9.16.1　Linux的DHCP客户端　　 173\n9.16.2　Linux的DHCP服务器　　 173\n9.17　将Linux配置成路由器　　174\n9.18　私有网络　　175\n9.19　网络地址转换（IP伪装） 　　176\n9.20　路由器与Linux　　177\n9.21 防火墙　　177\n9.21.1　Linux防火墙基础　　178\n9.21.2　设置防火墙规则　　179\n9.21.3　防火墙策略　　181\n9.22 以太网、IP和ARP　　182\n9.23 无线以太网　　183\n9.23.1　iw　　184\n9.23.2　无线网络安全　　184\n9.24 小结　　185\n第10章　网络应用与服务　　186\n10.1　服务的基本概念　　186\n10.2　网络服务器　　188\n10.3　SSH　　189\n10.3.1　SSHD服务器　　190\n10.3.2　SSH客户端　　191\n10.4　守护进程inetd和xinetd　　193\n10.5　诊断工具　　193\n10.5.1　lsof194\n10.5.2　tcpdump　　195\n10.5.3　netcat　　196\n10.5.4　扫描端口　　197\n10.6　远程程序调用　　198\n10.7　网络安全　　198\n10.7.1　典型漏洞　　199\n10.7.2　安全资源　　199\n10.8　前瞻　　200\n10.9　套接字：进程与网络的通信方式　　 200\n10.10　Unix域套接字　　201\n10.10.1　对开发者的好处.201\n10.10.2　列出Unix域套接字　　 202\n第11章　shell脚本　　203\n11.1　shell脚本基础　　203\n11.2　引号与字面量　　204\n11.2.1　字面量　　205\n11.2.2　单引号　　205\n11.2.3　双引号　　205\n11.2.4　单引号的字面义　　206\n11.3　特殊变量　　206\n11.3.1　单个参数：$1，$2，…… 　　207\n11.3.2　参数的数量：$#　　207\n11.3.3　所有参数：$@　　207\n11.3.4　脚本名：$0　　208\n11.3.5　进程号：$$　　208\n11.3.6　退出码：$?　　208\n11.4　退出码　　208\n11.5　条件判断　　209\n11.5.1　防范空参数　　209\n11.5.2　使用其他命令来测试　　210\n11.5.3　elif　　210\n11.5.4　逻辑结构&&和||　　210\n11.5.5　测试条件　　211\n11.5.6　用case进行字符串匹配　　213\n11.6　循环　　214\n11.6.1　for循环　　214\n11.6.2　while循环　　214\n11.7　命令替换　　215\n11.8　管理临时文件　　216\n11.9　here文档　　216\n11.10　重要的shell脚本工具　　217\n11.10.1　basename　　217\n11.10.2　awk　　218\n11.10.3　sed　　218\n11.10.4　xargs　　219\n11.10.5　expr　　219\n11.10.6　exec　　219\n11.11　子shell　　220\n11.12　在脚本中包含其他文件　　220\n11.13　读取用户输入　　221\n11.14　什么时候（不）应该使用shell脚本　　221\n第12章　在网络上传输文件　　222\n12.1　快速复制　　222\n12.2　rsync　　222\n12.2.1　rsync基础　　223\n12.2.2　准确复制目录结构　　224\n12.2.3　以斜杠结尾　　224\n12.2.4　排除文件与目录　　226\n12.2.5　合并、检查及冗长模式　　226\n12.2.6　压缩　　227\n12.2.7　限制带宽　　227\n12.2.8　传文件到你的计算机　　227\n12.2.9　更多有关rsync的话题　　227\n12.3　文件共享　　228\n12.4　用Samba分享文件　　228\n12.4.1　配置服务器　　228\n12.4.2　服务器访问控制　　229\n12.4.3　密码　　229\n12.4.4　启动服务器　　231\n12.4.5　诊断和日志文件　　231\n12.4.6　配置文件共享　　231\n12.4.7　home目录　　232\n12.4.8　共享打印机　　232\n12.4.9　使用Samba客户端　　232\n12.4.10　作为客户去访问文件　　233\n12.5　NFS 客户端　　234\n12.6　有关网络文件服务的选择与局限的更多内容　　234\n第13章　用户环境　　235\n13.1　创建启动文件的规则　　235\n13.2　何时需要修改启动文件　　236\n13.3　shell启动文件的元素　　236\n13.3.1　命令路径　　236\n13.3.2　帮助手册的路径　　237\n13.3.3　提示符　　237\n13.3.4　别名　　238\n13.3.5　权限掩码　　238\n13.4　启动文件的顺序及例子　　238\n13.4.1　bash shell　　239\n13.4.2　tcsh shell　　241\n13.5　用户默认设置　　241\n13.5.1　shell默认设置　　242\n13.5.2　编辑器　　242\n13.5.3　翻页器　　242\n13.6　启动文件的一些陷阱　　242\n13.7　前瞻　　243\n第14章　Linux 桌面概览　　244\n14.1　桌面组件　　244\n14.1.1　窗口管理器　　245\n14.1.2　工具包　　245\n14.1.3　桌面环境　　245\n14.1.4　应用　　245\n14.2　近观X Window系统　　245\n14.2.1　显示管理器　　246\n14.2.2　网络透明性　　246\n14.3　探索X客户端　　247\n14.3.1　X事件　　247\n14.3.2　理解X输入以及偏好设定　　248\n14.4　X的未来　　250\n14.5　D-Bus　　250\n14.5.1　系统和会话实例　　251\n14.5.2　监视D-Bus消息　　251\n14.6　打印　　251\n14.6.1　CUPS　　252\n14.6.2　格式转换与打印过滤器　　252\n14.7　其他有关桌面的话题　　253\n第15章　开发工具　　254\n15.1　C 编译器　　254\n15.1.1　多个源码文件　　255\n15.1.2　头（include）文件和目录　　256\n15.1.3　连接库　　257\n15.1.4　共享库　　258\n15.2　make　　261\n15.2.1　一个Makefile实例　　261\n15.2.2　内置规则　　262\n15.2.3　最终的程序构建　　262\n15.2.4　保持更新　　263\n15.2.5　命令行参数与选项263\n15.2.6　标准宏和变量　　264\n15.2.7　常规的目标　　264\n15.2.8　组织一个Makefile.265\n15.3　调试器　　266\n15.4　Lex和Yacc.267\n15.5　脚本语言　　267\n15.5.1　Python　　268\n15.5.2　Perl　　268\n15.5.3　其他脚本语言　　268\n15.6　Java　　269\n15.7　展望：编译包　　270\n第16章　从C代码编译出软件.271\n16.1　软件的���建系统　　271\n16.2　解开C源码包　　272\n16.3　GNU autoconf　　273\n16.3.1　一个autoconf的例子　　 274\n16.3.2　使用打包工具来安装　　 275\n16.3.3　configure脚本的选项　　 275\n16.3.4　环境变量　　276\n16.3.5　autoconf的目标　　277\n16.3.6　autoconf的日志文件　　 277\n16.3.7　pkg-config 　　277\n16.4　实践安装　　278\n16.5　打补丁　　279\n16.6　编译和安装的问题排查　　280\n16.7　前瞻　　282\n第17章　在基础上搭建　　284\n17.1　Web服务器与应用　　284\n17.2　数据库　　285\n17.3　虚拟化　　285\n17.4　分布式计算与实时计算　　286\n17.5　嵌入式系统　　286\n17.6　结束语　　287",
    "pages": "304",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28231090.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28231090.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28231090.jpg"
    },
    "alt": "https://book.douban.com/subject/26546893/",
    "id": "26546893",
    "publisher": "人民邮电出版社",
    "isbn10": "711539492X",
    "isbn13": "9787115394927",
    "title": "精通Linux（第2版）",
    "url": "https://api.douban.com/v2/book/26546893",
    "alt_title": "",
    "author_intro": "Brian Ward\n毕业于芝加哥大学，获计算机科学博士学位。1993年开始接触Linux，研究并教授Linux二十余年。除了这本深受读者喜爱的书，Brian还著有Linux Kernel-HOWTO（No Starch Press）、The Linux Problem Solver（No Starch Press）等畅销著作。现居旧金山，身兼计算机高级顾问与高级讲师等数职。",
    "summary": "本书讲解了Linux操作系统的工作机制以及运行Linux系统所需的常用工具和命令。根据系统启动的大体顺序，本书更深入地介绍从设备管理到网络配置的各个部分，最后演示了系统各部分的运行方式，并介绍了一些基本技巧和开发人员常用的工具。\nLinux不像其他操作，会对用户隐藏很多重要的东西。相反，Linux会让用户掌控一切。而要掌控一切，就必须理解这个操作系统的工作机制，包括如何启动、如何连网，以及Linux内核如何工作。本书是畅销书的新版本，作者拥有多年的实践经验，内容通俗易懂。通过这本书，读者可以迅速从Linux新手变成老鸟，把作者丰富的经验装进自己的知识库。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "59.00元"
  },
  "9787111384991": {
    "rating": { "max": 10, "numRaters": 236, "average": "8.8", "min": 0 },
    "subtitle": "—服务器架设篇(第三版)",
    "author": ["鸟哥"],
    "pubdate": "2012-7",
    "tags": [
      { "count": 310, "name": "Linux", "title": "Linux" },
      { "count": 142, "name": "服务器", "title": "服务器" },
      { "count": 86, "name": "计算机", "title": "计算机" },
      {
        "count": 77,
        "name": "鸟哥的Linux私房菜",
        "title": "鸟哥的Linux私房菜"
      },
      { "count": 58, "name": "服务器架设篇", "title": "服务器架设篇" },
      { "count": 56, "name": "操作系统", "title": "操作系统" },
      { "count": 45, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 27, "name": "鸟哥", "title": "鸟哥" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s10328185.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "目录\n《鸟哥的linux私房菜——服务器架设篇(第三版)》\n作者序\n第一篇　 服务器搭建前的进修专区\n第1章　 搭建服务器前的准备工作 2\n1.1　linux 的功能 3\n1.1.1　用 linux 搭建服务器需要的能力 3\n1.1.2　搭建服务器难不难呢 4\n1.2　搭建服务器的基本流程 5\n1.2.1　网络服务器成功连接的分析 5\n1.2.2　一个常见的服务器设置案例分析 8\n1.2.3　系统安全与备份处理 25\n1.3　自我评估是否已经具备服务器搭建的能力 27\n第2章　 网络的基本概念 29\n2.1　网络 30\n2.1.1　什么是网络 30\n2.1.2　计算机网络组成组件 32\n2.1.3　计算机网络的范围 33\n2.1.4　计算机网络协议：osi 七层协议 34\n2.1.5　计算机网络协议：tcp/ip 37\n2.2　tcp/ip 的网络接口层的相关协议 39\n.2.2.1　广域网使用的设备 39\n2.2.2　局域网使用的设备——以太网 40\n2.2.3　以太网络的传输协议：csma/cd 42\n2.2.4　mac 的封装格式 44\n2.2.5　mtu（最大传输单位） 46\n2.2.6　集线器、交换器与相关机制 47\n2.3　tcp/ip 的网络层相关数据包与数据 49\n2.3.1　ip 数据包的封装 49\n2.3.2　ip 地址的组成与分级 52\n2.3.3　ip 的种类与取得方式 55\n2.3.4　netmask、子网与 cidr（classless interdomain routing） 57\n2.3.5　路由概念 61\n2.3.6　观察主机路由：route 64\n2.3.7　ip 与 mac：网络接口层的 arp 与 rarp 协议 65\n2.3.8　icmp 协议 66\n2.4　tcp/ip 的传输层相关数据包与数据 67\n2.4.1　面向连接的可靠的 tcp 协议 67\n2.4.2　tcp 的三次握手 72\n2.4.3　无连接的 udp 协议 73\n2.4.4　网络防火墙与 osi 七层协议 74\n2.5　连上 internet 前的准备事项 75\n2.5.1　ip地址、主机名与dns系统 75\n2.5.2　连上 internet 的必要网络参数 76\n2.6　重点回顾 77\n2.7　参考数据与延伸阅读 78\n第3章　 局域网架构简介 79\n3.1　局域网的连接 80\n3.1.1　局域网的布线规划 80\n3.1.2　网络设备选购建议 84\n3.2　本书使用的内部连接网络参数与通信协议 88\n3.2.1　网络联机参数与通信协议 88\n3.2.2　windows 个人计算机网络配置范例 90\n第4章　 连接 internet 93\n4.1　linux 连接 internet 前的注意事项 94\n4.1.1　linux 的网卡 94\n4.1.2　编译网卡驱动程序（option） 96\n4.1.3　linux 网络相关配置文件 98\n4.2　连接 internet 的设置方法 100\n4.2.1　手动配置固定 ip 参数 100\n4.2.2　自动取得 ip 参数（dhcp 方法，适用 cable modem、ip 路由器的环境） 105\n4.2.3　adsl 拨号上网（适用 adsl 拨号以及光纤接入） 106\n4.3　无线网络——以笔记本电脑为例 111\n4.3.1　无线网络所需要的硬件：ap、无线网卡 111\n4.3.2　关于 ap 的设置：网络安全方面 113\n4.3.3　利用无线网卡开始连接 115\n4.4　常见问题说明 118\n4.4.1　内部网络使用某些服务（如 ftp、pop3）所遇到的连接延迟问题 118\n4.4.2　域名无法解析的问题 120\n4.4.3　默认网关的问题 120\n4.5　重点回顾 121\n4.6　参考数据与延伸阅读 121\n第5章　 linux 中常用的网络命令 122\n5.1　设置网络参数的命令 123\n5.1.1　 手动/自动配置ip 参数与启动/关闭网络接口：ifconfig、ifup、ifdown 123\n5.1.2　修改路由：route 126\n5.1.3　网络参数综合命令：ip 128\n5.1.4　无线网络：iwlist, iwconfig 134\n5.1.5　dhcp客户端命令：dhclient 134\n5.2　网络排错与查看命令 134\n5.2.1　两台主机的两点沟通：ping 134\n5.2.2　两主机间各节点分析：traceroute 137\n5.2.3　查看本机的网络连接与后门：netstat 138\n5.2.4　检测主机名与 ip 的对应：host、nslookup 141\n5.3　远程连接命令与即时通信软件 143\n5.3.1　终端机与 bbs 连接：telnet 143\n5.3.2　ftp 连接软件：ftp、lftp 144\n5.3.3　图形接口的即时通信软件：pidgin（gaim 的延伸） 147\n5.4　文字接口网页浏览 150\n5.4.1　文字浏览器：links 150\n5.4.2　文字接口下载器：wget 152\n5.5　数据包捕获功能 153\n5.5.1　文字接口数据包捕获器：tcpdump 153\n5.5.2　图形接口数据包捕获器：wireshark 157\n5.5.3　任意启动 tcp/udp 数据包的端口连接：nc、netcat 159\n5.6　重点回顾 160\n5.7　参考数据与延伸阅读 161\n第6章　 linux 网络排错 162\n6.1　无法连接网络的原因分析 163\n6.1.1　硬件问题：网线、网络设备、网络布线等 163\n6.1.2　软件问题：ip 参数设置、路由设置、服务器与防火墙设置等 165\n6.1.3　问题的处理 165\n6.2　处理流程 166\n6.2.1　步骤1：网卡工作确认 166\n6.2.2　步骤2：局域网内各项连接设备检测 167\n6.2.3　步骤3：取得正确的 ip 参数 168\n6.2.4　步骤4：确认路由表的规则 169\n6.2.5　步骤5：主机名与 ip 查询的 dns 错误 170\n6.2.6　步骤6：linux 的 nat 服务器或 ip 路由器出问题 171\n6.2.7　步骤7：internet 的问题 171\n6.2.8　步骤8：服务器的问题 171\n6.3　参考数据与延伸阅读 172\n第二篇　主机的简易安全防护措施\n第7章　 网络安全与主机基本防护：限制端口、网络升级与selinux 174\n7.1　网络数据包连接进入主机的流程 175\n7.1.1　数据包进入主机的流程 175\n7.1.2　常见的攻击手法与相关保护 177\n7.1.3　主机能执行的保护操作：软件更新、减少网络服务、 启动 selinux 182\n7.2　网络自动升级软件 184\n7.2.1　如何进行软件升级 184\n7.2.2　centos 的 yum 软件更新、镜像站点使用的原理 186\n7.2.3　yum 的功能：安装软件组、全系统更新 187\n7.2.4　挑选特定的镜像站点：修改 yum 配置文件与清除 yum 缓存 193\n7.3　限制连接端口（port） 196\n7.3.1　什么是port 197\n7.3.2　端口的查看：netstat、nmap 198\n7.3.3　端口与服务的启动/关闭及开机时状态设定 201\n7.3.4　安全性考虑——关闭网络服务端口 205\n7.4　selinux 管理原则 206\n7.4.1　selinux 的工作模式 206\n7.4.2　selinux 的启动、关闭与查看 210\n7.4.3　selinux type 的修改 212\n7.4.4　selinux 策略内的规则布尔值修订 214\n7.4.5　selinux 日志文件记录所需的服务 217\n7.5　被攻击后的主机修复工作 221\n7.5.1　网管人员应具备的技能 221\n7.5.2　主机受攻击后恢复的工作流程 223\n7.6　重点回顾 225\n7.7　参考数据与延伸阅读 225\n第8章　 路由的概念与路由器设置 226\n8.1　路由 227\n8.1.1　路由表产生的类型 227\n8.1.2　一个网卡绑多个 ip：ip alias 的测试用途 229\n8.1.3　重复路由的问题 230\n8.2　路由器配置 231\n8.2.1　什么是路由器与 ip 路由器 231\n8.2.2　何时需要路由器 233\n8.2.3　静态路由的路由器 234\n8.3　动态路由器架设 239\n8.4　特殊状况——路由器两边界面是同一个ip网段：arp proxy 245\n8.5　重点回顾 249\n8.6　参考数据与延伸阅读 250\n第9章　 防火墙与 nat 服务器 251\n9.1　认识防火墙 252\n9.1.1　关于本章的一些提醒事项 252\n9.1.2　为何需要防火墙 253\n9.1.3　linux 系统上防火墙的主要类别 253\n9.1.4　防火墙的一般网络布线示意 255\n9.1.5　 防火墙的使用限制 258\n9.2　tcp wrappers 259\n9.2.1　哪些服务有支持 259\n9.2.2　/etc/hosts.{allowdeny} 的设置方式 261\n9.3　linux 的数据包过滤软件：iptables 262\n9.3.1　不同 linux 内核版本的防火墙软件 262\n9.3.2　数据包进入流程：规则顺序的重要性 263\n9.3.3　iptables 的表格（table）与链（chain） 264\n9.3.4　本机的 iptables 语法 267\n9.3.5　ipv4 的内核管理功能：/proc/sys/net/ipv4/* 278\n9.4　设置单机防火墙的一个实例 281\n9.4.1　规则草拟 281\n9.4.2　实际设置 282\n9.5　nat 服务器的设置 286\n9.5.1　什么是 nat？ snat？ dnat？ 287\n9.5.2　最简单的 nat 服务器：ip 分享功能 290\n9.5.3　iptables 的额外内核模块功能 292\n9.5.4　在防火墙后端的网络服务器上做dnat 设置 292\n9.6　重点回顾 293\n9.7　参考数据与延伸阅读 294\n第10章　 申请合法的主机名 295\n10.1　为何需要主机名 296\n10.1.1　主机名的由来 296\n10.1.2　重点在合法授权 297\n10.1.3　申请静态还是动态 dns 主机名 298\n10.2　注册一个合法的主机名 299\n10.2.1　静态 dns 主机名注册（以 hinet 为例） 299\n10.2.2　动态 dns 主机名注册（以 no-ip 为例） 301\n10.3　重点回顾 306\n10.4　参考数据与延伸阅读 307\n第三篇　 局域网内常见服务器的搭建\n第11章　 远程连接服务器 ssh / xdmcp / vnc /xrdp 310\n11.1　远程连接服务器 311\n11.1.1　什么是远程连接服务器 311\n11.1.2　有哪些可供登录的类型 312\n11.2　文字接口连接服务器： ssh 服务器 313\n11.2.1　连接加密技术简介 314\n11.2.2　启动 ssh 服务 317\n11.2.3　 ssh 客户端连接程序——linux 用户 317\n11.2.4　 ssh 客户端连接程序——windows 用户 324\n11.2.5　 sshd 服务器详细配置 328\n11.2.6　制作不用密码可立即登录的ssh用户 332\n11.2.7　简易安全设置 335\n11.3　最原始图形接口：xdmcp服务的启用 337\n11.3.1　 x window 的 server/client 架构与各组件 338\n11.3.2　设定 gdm 的 xdmcp 服务 341\n11.3.3　用户系统为 linux 的登录方式 343\n11.3.4　用户系统为 windows 的登录方式： xming 345\n11.4　华丽的图形接口：vnc 服务器 348\n11.4.1　默认的 vnc 服务器 348\n11.4.2　 vnc 的客户端连接软件 350\n11.4.3　 vnc 搭配本机的 xdmcp 画面 352\n11.4.4　开机就启动 vnc server 的方法 354\n11.4.5　同步的 vnc ：可以通过图示同步教学 354\n11.5　仿真的远程桌面系统：xrdp 服务器 355\n11.6　 ssh 服务器的高级应用 357\n11.6.1　在非标准端口启动 ssh（非 port 22） 357\n11.6.2　以 rsync 进行同步镜像备份 359\n11.6.3　通过ssh通道加密原本无加密的服务 362\n11.6.4　以ssh通道配合 x server 传递图形界面 363\n11.7　重点回顾 367\n11.8　参考数据与延伸阅读 368\n第12章　 网络参数管理者：dhcp服务器 369\n12.1　dhcp 的工作原理 370\n12.1.1　dhcp 服务器的用途 370\n12.1.2　dhcp 协议的工作方式 371\n12.1.3　何时需要架设 dhcp 服务器 375\n12.2　dhcp 服务器端的配置 376\n12.2.1　所需软件与文件结构 376\n12.2.2　主要配置文件 /etc/dhcp/dhcpd.conf 的语法 377\n12.2.3　一个局域网的 dhcp 服务器设置案例 379\n12.2.4　dhcp 服务器的启动与观察 380\n12.2.5　内部主机的 ip 对应 382\n12.3　dhcp 客户端的设置 382\n12.3.1　客户端是 linux 382\n12.3.2　客户端是 windows 384\n12.4　dhcp 服务器端的高级查看与使用 387\n12.4.1　检查租约文件 387\n12.4.2　让大量 pc 都具有固定 ip 的脚本 387\n12.4.3　使用 ether-wake 实现远程自动开机（remote boot） 388\n12.4.4　dhcp 与 dns 的关系 389\n12.5　重点回顾 390\n12.6　参考数据与延伸阅读 391\n第13章　 文件服务器之一：nfs 服务器 392\n13.1　nfs的由来与功能 393\n13.1.1　什么是 nfs（network file system） 393\n13.1.2　什么是 rpc（remote procedure call） 394\n13.1.3　nfs 启动的 rpc daemons 395\n13.1.4　nfs 的文件访问权限 396\n13.2　nfs server 端的配置 397\n13.2.1　所需要的软件 398\n13.2.2　nfs 的软件结构 398\n13.2.3　/etc/exports 配置文件的语法与参数 399\n13.2.4　启动 nfs 404\n13.2.5　nfs 的连接查看 406\n13.2.6　nfs 的安全性 408\n13.3　nfs 客户端的设置 410\n13.3.1　手动挂载 nfs 服务器共享的资源 410\n13.3.2　客户端可处理的挂载参数与开机挂载 411\n13.3.3　无法挂载的原因分析 414\n13.3.4　自动挂载 autofs 的使用 415\n13.4　案例演练 418\n13.5　重点回顾 420\n13.6　参考数据与延伸阅读 420\n第14章　 账号管理：nis 服务器 421\n14.1　nis 的由来与功能 422\n14.1.1　nis 的主要功能：管理账号信息 422\n14.1.2　nis 的工作流程：通过 rpc 服务 423\n14.2　nis server 端的设置 425\n14.2.1　所需要的软件 425\n14.2.2　nis 服务器相关的配置文件 425\n14.2.3　一个实际操作案例 426\n14.2.4　nis server 的设置与启动 426\n14.2.5　防火墙设置 431\n14.3　nis client 端的设置 431\n14.3.1　nis client 所需的软件与软件结构 432\n14.3.2　nis client 的设置与启动 432\n14.3.3　nis client 端的验证：yptest、ypwhich、ypcat 435\n14.3.4　用户参数修改：yppasswd、ypchfn、ypchsh 437\n14.4　nis 搭配 nfs 的设置在群集计算机上的应用 438\n14.5　重点回顾 441\n14.6　参考数据与延伸阅读 442\n第15章　 时间服务器：ntp 服务器 443\n15.1　关于时区与网络校时的通信协议 444\n15.1.1　什么是时区？全球有多少时区？gmt 在哪个时区？ 444\n15.1.2　什么是夏令时（daylight saving time） 446\n15.1.3　coordinated universal time（utc）与系统时间的误差 447\n15.1.4　ntp 通信协议 447\n15.1.5　ntp 服务器的层次概念 448\n15.2　ntp 服务器的安装与设置 449\n15.2.1　所需软件与软件结构 449\n15.2.2　主要配置文件 ntp.conf 的处理 451\n15.2.3　ntp 的启动与观察 453\n15.2.4　安全性设置 455\n15.3　客户端的时间更新方式 455\n15.3.1　linux 手动校时工作：date、hwclock 455\n15.3.2　linux 的网络校时 456\n15.3.3　windows 的网络校时 457\n15.4　重点回顾 459\n15.5　参考数据与延伸阅读 459\n第16章　 文件服务器之二：samba 服务器 460\n16.1　什么是 samba 461\n16.1.1　samba 的发展历史与名称的由来 461\n16.1.2　samba 常见的应用 462\n16.1.3　samba 使用的 netbios 通信协议 463\n16.1.4　samba 使用的 daemons 464\n16.1.5　连接模式的介绍（peer/peer、domain model） 465\n16.2　samba 服务器的基础设置 467\n16.2.1　samba所需软件及其软件结构 467\n16.2.2　基础的网上邻居共享流程与 smb.conf 的常用设置项目 469\n16.2.3　不需密码的共享（security = share，纯测试） 474\n16.2.4　需账号密码才可登录的共享（security = user） 479\n16.2.5　设置成为打印机服务器（cups 系统） 486\n16.2.6　安全性的议题与管理 496\n16.2.7　主机安装时的规划与中文扇区挂载 499\n16.3　samba客户端软件功能 500\n16.3.1　windows 系统的使用 501\n16.3.2　linux 系统的使用 505\n16.4　以 pdc 服务器提供账号管理 509\n16.4.1　让 samba 管理网络用户的一个实际案例 509\n16.4.2　pdc 服务器的搭建 511\n16.4.3　wimdows xp pro. 的客户端 515\n16.4.4　windows 7 的客户端 519\n16.4.5　pdc 问题的克服 520\n16.5　服务器简单维护与管理 521\n16.5.1　服务器相关问题克服 521\n16.5.2　让用户修改samba密码同时同步更新 /etc/shadow 密码 522\n16.5.3　利用 acl 配合单一用户时的管理 523\n16.6　重点回顾 524\n16.7　参考数据与延伸阅读 524\n第17章　 局域网控制者：proxy 服务器 526\n17.1　什么是代理服务器 527\n17.1.1　什么是代理服务器 527\n17.1.2　代理服务器的工作流程 528\n17.1.3　上层代理服务器 529\n17.1.4　代理服务器与 nat 服务器的差异 531\n17.1.5　搭建代理服务器的用途与优缺点 531\n17.2　proxy 服务器的配置基础 533\n17.2.1　proxy 所需的 squid 软件及其软件结构 533\n17.2.2　centos 默认的 squid 设置 534\n17.2.3　管理信任来源（如局域网）与目标（如恶意网站）：acl 与 http_access 的使用 539\n17.2.4　其他额外的功能项目 542\n17.2.5　安全性设置：防火墙、selinux 与黑名单文件 544\n17.3　客户端的使用与测试 545\n17.3.1　浏览器的设置：firefox & ie 545\n17.3.2　测试proxy 失败的画面 548\n17.4　服务器的其他应用设定 549\n17.4.1　上层 proxy 与获取数据分流的设定 549\n17.4.2　proxy 服务放在 nat 服务器上：透明代理（transparent proxy） 551\n17.4.3　proxy 的认证设置 553\n17.4.4　末端日志分析：sarg 555\n17.5　重点回顾 557\n17.6　参考数据与延伸阅读 558\n第18章　 网络驱动器设备：iscsi 服务器 559\n18.1　网络文件系统还是网络驱动器 560\n18.1.1　nas 与 san 560\n18.1.2　iscsi接口 561\n18.1.3　各组件相关性 562\n18.2　iscsi target 的设置 564\n18.2.1　所需软件与软件结构 564\n18.2.2　iscsi target 的实际设置 565\n18.3　iscsi initiator 的设置 570\n18.3.1　所需软件与软件结构 570\n18.3.2　iscsi initiator 的实际设置 570\n18.3.3　一个测试范例 574\n18.4　重点回顾 576\n18.5　参考数据与延伸阅读 577\n第四篇　 常见因特网服务器的搭建\n第19章　 主机名控制者：dns 服务器 580\n19.1　什么是 dns 581\n19.1.1　用网络主机名取得 ip 的历史渊源 581\n19.1.2　dns 的主机名对应 ip 的查询流程 584\n19.1.3　合法 dns 的关键：申请区域查询授权 590\n19.1.4　主机名交由 isp 代管还是自己设置 dns 服务器 591\n19.1.5　dns 数据库的记录：正解、反解、zone 的意义 592\n19.1.6　dns 数据库的类型：hint、master/slave 架构 594\n19.2　client 端的设置 596\n19.2.1　相关配置文件 596\n19.2.2　dns 的正、反解查询命令：host、nslookup、dig 597\n19.2.3　查询域管理者相关信息：whois 602\n19.3　 dns 服务器的软件、种类与caching only dns服务器设置 604\n19.3.1　搭建 dns 所需要的软件 604\n19.3.2　bind 的默认路径设置与 chroot 604\n19.3.3　单纯的 cache-only dns 服务器与 forwarding 功能 605\n19.4　dns 服务器的详细设置 611\n19.4.1　正解文件记录的数据（resource record，rr） 612\n19.4.2　反解文件记录的 rr 数据 616\n19.4.3　步骤一：dns 的环境规划 617\n19.4.4　步骤二：主配置文件 /etc/named.conf 的设置 618\n19.4.5　步骤三：最上层 . (root) 数据库文件的设置 620\n19.4.6　步骤四：正解数据库文件的设置 620\n19.4.7　步骤五：反解数据库文件的设置 622\n19.4.8　步骤六：dns 的启动、查看与防火墙 623\n19.4.9　步骤七：测试与数据库更新 624\n19.5　协同工作的 dns：slave dns 及子域授权设定 626\n19.5.1　master dns 权限的开放 626\n19.5.2　slave dns 的设置与数据库权限问题 628\n19.5.3　配置子域 dns 服务器：子域授权课题 630\n19.5.4　依不同接口给予不同的 dns 主机名：view 功能的应用 632\n19.6　dns 服务器的高级设定 635\n19.6.1　架设一个合法授权的 dns 服务器 635\n19.6.2　lame server 的问题 637\n19.6.3　利用 rndc 命令管理 dns 服务器 638\n19.6.4　搭建动态 dns 服务器：让你成为 isp 642\n19.7　重点回顾 645\n19.8　参考数据与延伸阅读 646\n第20章　 www 服务器 647\n20.1　www的简史、资源以及服务器软件 648\n20.1.1　www 的简史、html 与标准制订（w3c） 648\n20.1.2　www 服务器与浏览器所提供的资源定位（url） 651\n20.1.3　 www 服务器的类型：系统、平台、数据库与程序（lamp） 653\n20.1.4　https：加密的网页数据（ssl）及第三方证书机构 655\n20.1.5　客户端常见的浏览器 656\n20.2　www（lamp）服务器基本配置 657\n20.2.1　lamp 所需软件与其结构 657\n20.2.2　apache 的基本设定 660\n20.2.3　php 的默认参数修改 668\n20.2.4　启动 www 服务与测试 php 模块 670\n20.2.5　mysql 的基本设定 672\n20.2.6　防火墙设置与 selinux规则的放行 676\n20.2.7　开始网页设计及安装架站软件，如 phpbb3 677\n20.3　apache 服务器的高级设定 678\n20.3.1　启动用户的个人网站（权限是重点） 678\n20.3.2　启动某个目录的 cgi（perl）程序执行权限 680\n20.3.3　找不到网页时的显示信息通知 681\n20.3.4　浏览权限的设定操作（order、limit） 683\n20.3.5　服务器状态说明网页 686\n20.3.6　.htaccess 与认证网页设定 687\n20.3.7　虚拟主机的设定（重要！） 691\n20.4　日志文件分析以及 php 强化模块 694\n20.4.1　php 强化模块（eaccelerator）与 apache 简易性能测试 694\n20.4.2　syslog 与 logrotate 697\n20.4.3　日志文件分析软件：webalizer 698\n20.4.4　日志文件分析软件：awstats 700\n20.5　建立连接加密网站（https）及防整站下载脚本 702\n20.5.1　ssl 所需软件与证书文件及默认的 https 702\n20.5.2　拥有自制证书的https 704\n20.5.3　将加密首页与非加密首页分离 706\n20.5.4　防整站下载软件 707\n20.6　重点回顾 708\n20.7　参考数据与延伸阅读 709\n第21章　 文件服务器之三：ftp 服务器 710\n21.1　ftp 的数据传输原理 711\n21.1.1　ftp 功能简介 711\n21.1.2　ftp 的工作流程与使用到的端口 712\n21.1.3　客户端选择被动式连接模式 714\n21.1.4　ftp 的安全性问题与替代方案 716\n21.1.5　开放什么身份的用户登录 716\n21.2　vsftpd 服务器基础设置 718\n21.2.1　为何使用 vsftpd 718\n21.2.2　所需要的软件以及软件结构 719\n21.2.3　vsftpd.conf 配置值说明 721\n21.2.4　vsftpd 启动的模式 726\n21.2.5　centos 的 vsftpd 默认值 727\n21.2.6　针对实体账号的设定 729\n21.2.7　仅有匿名登录的相关设置 734\n21.2.8　防火墙设置 738\n21.2.9　常见问题与解决之道 739\n21.3　客户端的图形接口 ftp 连接软件 740\n21.3.1　filezilla 740\n21.3.2　通过浏览器取得 ftp 连接 744\n21.4　让 vsftpd 增加 ssl 的加密功能 744\n21.5　重点回顾 747\n21.6　参考数据与延伸阅读 748\n第22章　 邮件服务器：postfix 749\n22.1　邮件服务器的功能与工作原理 750\n22.1.1　电子邮件的功能与问题 750\n22.1.2　mail server 与 dns 之间的关系 751\n22.1.3　邮件传输所需要的组件（mta、mua、mda）以及相关协议 754\n22.1.4　用户收信时服务器端所提供的相关协议： mra 757\n22.1.5　relay 与认证机制的重要性 759\n22.1.6　电子邮件的数据内容 760\n22.2　mta 服务器：postfix基础设定 761\n22.2.1　postfix 的开发 761\n22.2.2　所需要的软件与软件结构 762\n22.2.3　一个邮件服务器的设定案例 764\n22.2.4　让 postfix 可监听 internet 来收发邮件 764\n22.2.5　邮件发送流程与收信、relay 等重要概念 767\n22.2.6　设定邮件主机权限与过滤机制：/etc/postfix/access 770\n22.2.7　设定邮件别名： /etc/aliases、~/.forward 770\n22.2.8　查看邮件队列信息：postqueue、mailq 773\n22.2.9　防火墙设置 775\n22.3　mra 服务器：dovecot 设定 775\n22.3.1　基础的 pop3/imap 设定 775\n22.3.2　加密的 pop3s/imaps 设定 776\n22.3.3　防火墙设置 777\n22.4　mua 软件：客户端的收发邮件软件 777\n22.4.1　linux mail 778\n22.4.2　linux mutt 781\n22.4.3　好用的跨平台（windows/linux x）软件：thunderbird 784\n22.5　邮件服务器的高级设定 788\n22.5.1　邮件过滤一：用 postgrey 进行非正规mail server 的垃圾邮件过滤 788\n22.5.2　邮件过滤二：关于黑名单的过滤机制 792\n22.5.3　邮件过滤三：基础的邮件过滤机制 793\n22.5.4　非信任来源的 relay：开放 smtp 身份认证 795\n22.5.5　非固定 ip 邮件服务器的福音：relayhost 799\n22.5.6　其他设置小技巧 800\n22.6　重点回顾 803\n22.7　参考数据与延伸阅读 804",
    "pages": "804",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s10328185.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s10328185.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s10328185.jpg"
    },
    "alt": "https://book.douban.com/subject/10794788/",
    "id": "10794788",
    "publisher": "机械工业出版社",
    "isbn10": "7111384997",
    "isbn13": "9787111384991",
    "title": "鸟哥的Linux私房菜",
    "url": "https://api.douban.com/v2/book/10794788",
    "alt_title": "",
    "author_intro": "鸟哥 “台湾成功大学”环境工程系博士，在就读期间由于研究需要，接触到Linux操作系统，又因实验室交接传承的需要而搭建了“鸟哥的Linux私房菜”网站(俗称鸟站)，因个人喜好碎碎念(琐碎重复)的特质，因此，鸟站文章风格就此成形。\n曾任台湾多家知名Linux教育中心讲师，目前于台湾昆山科技大学资讯传播系教授Linux相关课程。\n专长是Linux操作系统、网站规划与维护、网络安全，兴趣是写作与阅读，研究方向是网络整合应用。",
    "summary": "《鸟哥的Linux私房菜:服务器架设篇(第3版)》内容简介：您已有Linux基础，想要进一步学习服务器架设？还想了解如何维护与管理您的服务器？本书是您最佳的选择。\n目前有关Linux架站的书籍大多只教导读者如何架设服务器，很少针对服务器的维护与管理，以及发生问题时的应对策略加以说明，以至于一旦服务器遭受攻击，眼见的就是一场手忙脚乱。因此，作者先从系统基础以及网络基础讲起，再谈到网络攻击与防火墙防护主机后，才进入服务器的架设。\n《鸟哥的Linux私房菜:服务器架设篇(第3版)》共分为四篇：第一篇，服务器搭建前的进修专区，主要介绍架设服务器之前必须具备的基本知识，看完这一篇，不论您的Linux是以何种方式进行Internet连接，都将不成问题；第二篇，主机的简易安全防护措施，这一篇鸟哥将告诉您如何保护您的主机，以及如何养成良好的操作习惯，使您的主机能够百毒不侵，安然渡过一次次的考验；第三篇，局域网内常见服务器的搭建，介绍内部网络经常使用的远程连接服务（SSH、VNC、XRDP），网络参数设置服务（DHCP、NTP），网络磁盘服务（Samba、NFS、iSCSI），以及代理服务器等服务。其中SSH密钥系统，对于异地备份更是相当有帮助，您绝对不能错过；第四篇，常见因特网服务器的搭建，介绍DNS、WWW、FTP及Mail Server等常见的服务。",
    "series": { "id": "1496", "title": "鸟哥的Linux私房菜" },
    "price": "108.00元"
  },
  "9787115226266": {
    "rating": { "max": 10, "numRaters": 2672, "average": "9.1", "min": 0 },
    "subtitle": "基础学习篇",
    "author": ["鸟哥"],
    "pubdate": "2010-6-28",
    "tags": [
      { "count": 2569, "name": "Linux", "title": "Linux" },
      { "count": 1028, "name": "操作系统", "title": "操作系统" },
      { "count": 885, "name": "计算机", "title": "计算机" },
      { "count": 659, "name": "鸟哥", "title": "鸟哥" },
      { "count": 568, "name": "Linux/Unix", "title": "Linux/Unix" },
      { "count": 319, "name": "IT", "title": "IT" },
      { "count": 286, "name": "linux", "title": "linux" },
      { "count": 258, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s4399937.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第一部分　Linux的规则与安装\n第0章　计算机概论　1\n0.1　计算机：辅助人脑的好工具　2\n0.1.1　计算机硬件的五大单元　2\n0.1.2　CPU的种类　3\n0.1.3　接口设备　4\n0.1.4　运作流程　4\n0.1.5　计算机分类　5\n0.1.6　计算机上面常用的计算单位(大小、速度等)　6\n0.2　个人计算机架构与接口设备　7\n0.2.1　CPU　7\n0.2.2　内存　9\n0.2.3　显卡　11\n0.2.4　硬盘与存储设备　12\n0.2.5　PCI适配卡　14\n0.2.6　主板　15\n0.2.7　电源　16\n0.2.8　选购须知　16\n0.3　数据表示方式　17\n0.3.1　数字系统　17\n.0.3.2　文字编码系统　18\n0.4　软件程序运行　18\n0.4.1　机器程序与编译程序　18\n0.4.2　操作系统　19\n0.4.3　应用程序　22\n0.5　重点回顾　22\n0.6　本章习题　23\n0.7　参考数据与扩展阅读　24\n第1章　Linux是什么　25\n1.1　Linux是什么　26\n1.1.1　Linux是什么　26\n1.1.2　Linux之前UNIX的历史　27\n1.1.3　关于GNU项目　32\n1.2　Torvalds的Linux开发　34\n1.2.1　Minix　34\n1.2.2　对386硬件的多任务测试　35\n1.2.3　初次释出Linux 0.02　36\n1.2.4　Linux的开发：虚拟团队的产生　37\n1.2.5　Linux的内核版本　38\n1.2.6　Linux distributions　39\n1.3　Linux的特色　42\n1.3.1　Linux的特色　42\n1.3.2　Linux的优缺点　43\n1.3.3　关于授权　45\n1.4　重点回顾　46\n1.5　本章习题　46\n1.6　参考数据与扩展阅读　47\n第2章　Linux如何学习　48\n2.1　Linux当前的应用角色　49\n2.1.1　企业环境的利用　49\n2.1.2　个人环境的使用　50\n2.2　鸟哥的Linux苦难经验回忆录　51\n2.2.1　鸟哥的Linux学习之路　51\n2.2.2　学习心态的分别　53\n2.2.3　X Window的学习　54\n2.3　有心向Linux操作系统学习者学习态度　55\n2.3.1　从头学习Linux基础　56\n2.3.2　选择一本易读的工具书　57\n2.3.3　实践再实践　57\n2.3.4　发生问题怎么处理..　58\n2.4　鸟哥的建议(重点在Solution的学习)　59\n2.5　重点回顾　60\n2.6　本章习题　61\n2.7　参考数据与扩展阅读　61\n第3章　主机规划与磁盘分区　62\n3.1　Linux与硬件的搭配　63\n3.1.1　认识计算机的硬件配置　63\n3.1.2　选择与Linux搭配的主机配置　64\n3.1.3　各硬件设备在Linux中的文件名　66\n3.2　磁盘分区　67\n3.2.1　磁盘连接的方式与设备文件名的关系　67\n3.2.2　磁盘的组成复习　68\n3.2.3　磁盘分区表(partition table)　69\n3.2.4　开机流程与主引导分区(MBR)　72\n3.2.5　Linux安装模式下，磁盘分区的选择(极重要)　74\n3.3　安装Linux前的规划　76\n3.3.1　选择适当的distribution　76\n3.3.2　主机的服务规划与硬件的关系　77\n3.3.3　主机硬盘的主要规划　79\n3.3.4　鸟哥说：关于练习机的安装建议　80\n3.3.5　鸟哥的两个实际案例　80\n3.3.6　大硬盘配合旧主机造成的无法开机问题　81\n3.4　重点回顾　82\n3.5　本章习题　82\n3.6　参考数据与扩展阅读　82\n第4章　安装CentOS 5.x与多重引导小技巧　83\n4.1　本练习机的规划(尤其是分区参数)　84\n4.2　开始安装CentOS 5　85\n4.2.1　调整启动媒体(BIOS)　86\n4.2.2　选择安装结构与开机　87\n4.2.3　选择语系数据　89\n4.2.4　磁盘分区　90\n4.2.5　引导装载程序、网络、时区设置与root密码　95\n4.2.6　软件选择　98\n4.2.7　其他功能：RAM testing、安装笔记本电脑的内核参数(Option)　99\n4.3　安装后的首次设置　100\n4.4　多重引导安装流程与技巧　104\n4.4.1　新主机仅有一块硬盘　104\n4.4.2　旧主机有两块以上硬盘　105\n4.4.3　旧主机只有一块硬盘　105\n4.5　关于大硬盘导致无法开机的问题　106\n4.6　重点回顾　106\n4.7　本章习题　107\n4.8　参考数据与扩展阅读　107\n第5章　首次登录与在线求助man page　108\n5.1　首次登录系统　109\n5.1.1　首次登录CentOS 5.x图形界面　109\n5.1.2　GNOME的操作与注销　110\n5.1.3　KDE的操作与注销　113\n5.1.4　X Window与命令行模式的切换　115\n5.1.5　在终端界面登录linux　116\n5.2　在命令行模式下执行命令　117\n5.2.1　开始执行命令　117\n5.2.2　基础命令的操作　118\n5.2.3　重要的热键[Tab], [ctrl]-c, [ctrl]-d　121\n5.2.4　错误信息的查看　122\n5.3　Linux系统的在线求助man page与info page　122\n5.3.1　man page　123\n5.3.2　info page　127\n5.3.3　其他有用的文件(documents)　129\n5.4　超简单文本编辑器：nano　130\n5.5　正确的关机方法　131\n5.5.1　数据同步写入磁盘：sync　132\n5.5.2　惯用的关机命令：shutdown　132\n5.5.3　重启、关机：reboot, halt, poweroff　133\n5.5.4　切换执行等级：init　133\n5.6　开机过程的问题排解　134\n5.6.1　文件系统错误的问题　134\n5.6.2　忘记root密码　135\n5.7　重点回顾　136\n5.8　本章习题　136\n5.9　参考数据与扩展阅读　137\n第二部分　Linux文件、目录与磁盘格式\n第6章　Linux的文件权限与目录配置　138\n6.1　用户与用户组　139\n6.2　Linux文件权限概念　140\n6.2.1　Linux文件属性　141\n6.2.2　如何改变文件属性与权限　144\n6.2.3　目录与文件的权限意义　147\n6.2.4　Linux文件种类与扩展名　150\n6.3　Linux目录配置　152\n6.3.1　Linux目录配置标准：FHS　152\n6.3.2　目录树(directory tree)　156\n6.3.3　绝对路径与相对路径　158\n6.3.4　CentOS的查看　159\n6.4　重点回顾　159\n6.5　本章练习　160\n6.6　参考数据与扩展阅读　160\n第7章　Linux文件与目录管理　161\n7.1　目录与路径　162\n7.1.1　相对路径与绝对路径　162\n7.1.2　目录的相关操作　162\n7.1.3　关于执行文件路径的变量：$PATH　165\n7.2　文件与目录管理　167\n7.2.1　查看文件与目录：ls　167\n7.2.2　复制、删除与移动：cp, rm, mv　169\n7.2.3　取得路径的文件名与目录名称　173\n7.3　文件内容查阅　173\n7.3.1　直接查看文件内容　173\n7.3.2　可翻页查看　175\n7.3.3　数据选取　176\n7.3.4　非纯文本文件：od　177\n7.3.5　修改文件时间或创建新文件：touch　178\n7.4　文件与目录的默认权限与隐藏权限　180\n7.4.1　文件默认权限：umask　181\n7.4.2　文件隐藏属性：chattr, lsattr　183\n7.4.3　文件特殊权限：SUID, SGID, SBIT　184\n7.4.4　查看文件类型：file　187\n7.5　命令与文件的查询　187\n7.5.1　脚本文件名的查询　187\n7.5.2　文件名的查找　188\n7.6　权限与命令间的关系(极重要)　192\n7.7　重点回顾　193\n7.8　本章习题　194\n7.9　参考数据与扩展阅读　195\n第8章　Linux磁盘与文件系统管理　196\n8.1　认识EXT2文件系统　197\n8.1.1　硬盘组成与分区的复习　197\n8.1.2　文件系统特性　197\n8.1.3　Linux的EXT2文件系统(inode)　199\n8.1.4　与目录树的关系　204\n8.1.5　EXT2/EXT3文件的访问与日志文件系统的功能　206\n8.1.6　Linux文件系统的操作　208\n8.1.7　挂载点(mount point)的意义　208\n8.1.8　其他Linux支持的文件系统 与VFS　209\n8.2　文件系统的简单操作　210\n8.2.1　磁盘与目录的容量：df, du　210\n8.2.2　连接文件：ln　213\n8.3　磁盘的分区、格式化、检验与挂载　217\n8.3.1　磁盘分区：fdisk　217\n8.3.2　磁盘格式化　223\n8.3.3　磁盘检验：fsck, badblocks　225\n8.3.4　磁盘挂载与卸载　226\n8.3.5　磁盘参数修改　231\n8.4　设置开机挂载　234\n8.4.1　开机挂载/etc/fstab及/etc/mtab　234\n8.4.2　特殊设备loop挂载(镜像文件不刻录就挂载使用)　236\n8.5　内存交换空间(swap)的构建　238\n8.5.1　使用物理分区构建swap　238\n8.5.2　使用文件构建swap　240\n8.5.3　swap使用上的限制　241\n8.6　文件系统的特殊查看与操作　241\n8.6.1　boot sector与superblock的关系　241\n8.6.2　磁盘空间的浪费问题　243\n8.6.3　利用GNU的parted进行分区行为　243\n8.7　重点回顾　245\n8.8　本章习题　245\n8.9　参考数据与扩展阅读　246\n第9章　文件与文件系统的压缩与打包　248\n9.1　压缩文件的用途与技术　249\n9.2　Linux系统常见的压缩命令　250\n9.2.1　Compress　250\n9.2.2　gzip, zcat　252\n9.2.3　bzip2, bzcat　253\n9.3　打包命令：tar　253\n9.3.1　tar　254\n9.4　完整备份工具：dump　259\n9.4.1　dump　259\n9.4.2　restore　262\n9.5　光盘写入工具　265\n9.5.1　mkisofs：新建镜像文件　265\n9.5.2　Cdrecord：光盘刻录工具　267\n9.6　其他常见的压缩与备份工具　269\n9.6.1　dd　269\n9.6.2　Cpio　270\n9.7　重点回顾　272\n9.8　本章习题　272\n9.9　参考数据与扩展阅读　273\n第三部分　学习shell与shell script\n第10章　vim程序编辑器　274\n10.1　vi与vim　275\n10.1.1　为何要学vim　275\n10.2　vi的使用　276\n10.2.1　简单执行范例　277\n10.2.2　按键说明　278\n10.2.3　一个案例练习　281\n10.2.4　vim的保存文件、恢复与打开时的警告信息　282\n10.3　vim的功能　284\n10.3.1　块选择(Visual Block)　285\n10.3.2　多文件编辑　286\n10.3.3　多窗口功能　286\n10.3.4　vim环境设置与记录：～/.vimrc, ～/.viminfo　287\n10.3.5　vim常用命令示意图　289\n10.4　其他vim使用注意事项　289\n10.4.1　中文编码的问题　289\n10.4.2　DOS与Linux的断行字符　290\n10.4.3　语系编码转换　290\n10.5　重点回顾　291\n10.6　本章练习　291\n10.7　参考数据与扩展阅读　292\n第11章　认识与学习bash　293\n11.1　认识bash这个shell　294\n11.1.1　硬件、内核与shell　294\n11.1.2　为何要学命令行界面的shell　295\n11.1.3　系统的合法shell与/etc/shells功能　295\n11.1.4　bash shell的功能　296\n11.1.5　bash shell的内置命令：type　298\n11.1.6　命令的执行　298\n11.2　shell的变量功能　299\n11.2.1　什么是变量　299\n11.2.2　变量的显示与设置：echo, unset　300\n11.2.3　环境变量的功能　304\n11.2.4　影响显示结果的语系变量(locale)　308\n11.2.5　变量的有效范围　309\n11.2.6　变量键盘读取、数组与声明：read，array，declare　310\n11.2.7　与文件系统及程序的限制关系：ulimit　312\n11.2.8　变量内容的删除、替代与替换　313\n11.3　命令别名与历史命令　317\n11.3.1　命令别名设置：alias，unalias　317\n11.3.2　历史命令：history　318\n11.4　Bash Shell的操作环境　320\n11.4.1　路径与命令查找顺序　320\n11.4.2　bash的登录与欢迎信息：/etc/issue, /etc/motd　320\n11.4.3　bash 的环境配置文件　321\n11.4.4　终端机的环境设置：stty, set　325\n11.4.5　通配符与特殊符号　327\n11.5　数据流重定向　328\n11.5.1　什么是数据流重定向　329\n11.5.2　命令执行的判断依据：",
    "pages": "778",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s4399937.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s4399937.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s4399937.jpg"
    },
    "alt": "https://book.douban.com/subject/4889838/",
    "id": "4889838",
    "publisher": "人民邮电出版社",
    "isbn10": "7115226261",
    "isbn13": "9787115226266",
    "title": "鸟哥的Linux私房菜",
    "url": "https://api.douban.com/v2/book/4889838",
    "alt_title": "",
    "author_intro": "鸟哥 台湾成功大学环境工程系博士，就学期间由于研究需要接触到Linux操作系统，又因实验室交接需求而建立“鸟哥的Linux私房菜”网站。因个人喜好“絮叨”，网站文章风格就此成形。\n曾任台湾多家知名Linux教育中心讲师，目前于昆山科技大学资讯传播系教授Linux相关课程。专长是Linux 操作系统、网站规划与维护、网络安全，兴趣是写作与阅读，研究方向是网络应用整合。",
    "summary": "本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。\n本书内容丰富全面，基本概念的讲解非常细致，深入浅出。各种功能和命令的介绍，都配以大量的实例操作和详尽的解析。本书是初学者学习Linux不可多得的一本入门好书。",
    "series": { "id": "1496", "title": "鸟哥的Linux私房菜" },
    "price": "88.00元"
  },
  "9787302392644": {
    "rating": { "max": 10, "numRaters": 217, "average": "8.3", "min": 0 },
    "subtitle": "软件工程师经典读本 不可错过的名著",
    "author": ["(美) 布鲁克斯(Brooks, F. P.)  著"],
    "pubdate": "2015-4-1",
    "tags": [
      { "count": 148, "name": "软件工程", "title": "软件工程" },
      { "count": 99, "name": "计算机", "title": "计算机" },
      { "count": 92, "name": "项目管理", "title": "项目管理" },
      { "count": 39, "name": "产品经理", "title": "产品经理" },
      { "count": 36, "name": "经典", "title": "经典" },
      { "count": 35, "name": "软件开发", "title": "软件开发" },
      { "count": 34, "name": "管理", "title": "管理" },
      { "count": 31, "name": "人月神话", "title": "人月神话" }
    ],
    "origin_title": "(美) 布鲁克斯(Brooks, F. P.)  著",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28040623.jpg",
    "binding": "平装",
    "translator": ["UML China翻译组，汪颖 译"],
    "catalog": "第1章  焦油坑\t1\n编程系统产品\t4\n职业的乐趣\t6\n职业的苦恼\t8\n第2章  人月神话\t11\n乐观主义\t14\n人月\t16\n系统测试\t19\n空泛的估算\t21\n重复产生的进度灾难\t22\n第3章  外科手术队伍\t27\n问题\t30\nMills的建议\t32\n如何运作\t35\n团队的扩建\t36\n第4章  贵族专制、民主政治和系统设计\t39\n概念的完整性\t42\n获得概念的完整性\t43\n贵族专制统治和民主政治\t44\n在等待时，实现人员应该做什么\t47\n第5章  画蛇添足\t51\n结构师的交互准则和机制\t54\n自律—— 开发第二个系统所带来的后果\t55\n第6章  贯彻执行\t59\n文档化的规格说明—— 手册\t62\n形式化定义\t63\n直接整合\t66\n会议和大会\t66\n多重实现\t68\n电话日志\t68\n产品测试\t69\n第7章  为什么巴比伦塔会失败\t71\n巴比伦塔的管理教训\t75\n大型编程项目中的交流\t76\n项目工作手册\t76\n大型编程项目的组织架构\t80\n第8章  胸有成竹\t85\nPortman的数据\t89\nAron的数据\t90\nHarr的数据\t90\nOS/360的数据\t92\nCorbató的数据\t93\n第9章  削足适履\t95\n作为成本的程序空间\t98\n规模控制\t99\n空间技能\t100\n数据的表现形式是编程的根本\t102\n第10章  提纲挈领\t105\n计算机产品的文档\t108\n大学科系的文档\t110\n软件项目的文档\t110\n为什么要有正式的文档\t111\n第11章  未雨绸缪\t113\n试验性工厂和增大规模\t116\n唯一不变的就是变化本身\t117\n为变更设计系统\t117\n为变更计划组织架构\t118\n前进两步，后退一步\t120\n前进一步，后退一步\t122\n第12章  干将莫邪\t125\n目标机器\t129\n辅助机器和数据服务\t131\n高级语言和交互式编程\t134\n第13章  整体部分\t139\n剔除bug的设计\t142\n构件单元调试\t144\n系统集成调试\t147\n第14章  祸起萧墙\t153\n里程碑还是沉重的负担\t156\n“其他的部分反正会落后”\t158\n地毯的下面\t159\n第15章  另外一面\t165\n需要什么样的文档\t169\n流程图\t171\n自文档化的程序\t175\n第16章  没有银弹\t181\n摘要\t184\n介绍\t184\n根本困难\t185\n以往解决次要困难的一些突破\t190\n银弹的希望\t192\n针对概念上根本问题的颇具前途的方法\t200\n第17章  再论“没有银弹”\t209\n人狼和其他恐怖传说\t212\n存在着银弹—— 就在这里\t212\n含糊的表达将会导致误解\t213\nHarel的分析\t216\nJones的观点—— 质量带来生产率\t221\n那么，生产率的情形如何\t222\n面向对象编程—— 这颗铜质子弹可以吗\t223\n重用的情况怎样\t225\n学习大量的词汇—— 对软件重用的一个可预见但还没有被预言的问题\t228\n子弹的本质—— 形势没有发生改变\t229\n第18章  《人月神话》的观点：是与非\t231\n第1章  焦油坑\t234\n第2章  人月神话\t235\n第3章  外科手术队伍\t236\n第4章  贵族专制、民主政治和系统设计\t237\n第5章  画蛇添足\t238\n第6章  贯彻执行\t239\n第7章  为什么巴比伦塔会失败\t240\n第8章  胸有成竹\t242\n第9章  削足适履\t243\n第10章  提纲挈领\t245\n第11章  未雨绸缪\t246\n第12章  干将莫邪\t249\n第13章  整体部分\t251\n第14章  祸起萧墙\t253\n第15章  另外一面\t255\n第1版结束语\t256\n第19章  20年后的《人月神话》\t257\n为什么要出版20周年纪念版本\t260\n核心观点—— 概念完整性和结构师\t261\n开发第二个系统所引起的后果—— 盲目的功能和频率猜测\t263\n图形界面的成功\t265\n没有构建舍弃原型—— 瀑布模型是错误的\t269\n增量开发模型更佳—— 渐进地精化\t272\n关于信息隐藏，Parnas是正确的，我是错误的\t276\n人月到底有多少神话色彩？Boehm的模型和数据\t278\n人就是一切(或者说，几乎是一切)\t280\n放弃权力的力量\t281\n最令人惊讶的新事物是什么？数百万的计算机\t283\n全新的软件产业—— 塑料薄膜包装的成品软件\t286\n买来开发—— 使用塑料包装的成品软件包作为构件\t288\n软件工程的状态和未来\t290\n结束语：令人向往、激动人心和充满乐趣的50年\t293\n注解与参考文献\t295\n附录：人月落地实战体验\t315\n一、名家谈人月\t317\n1. 年金\t317\n2. 《人月神话》与实践\t318\n3. Frank Chance评人月\t327\n4. 软件尚方宝剑(Silver Bullet)何在\t330\n二、名著评人月\t339\n三、读者感言\t351\n1. 读书有感——人月神话\t351\n2. 我这几天很烦(产品概念完整性)\t353\n3. 关于我们的思考——“项目开发”及读《人月神话》有感\t355\n4. 我的“人月神话”\t358\n5. 《人月神话》软玉生香\t360",
    "pages": "392",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28040623.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28040623.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28040623.jpg"
    },
    "alt": "https://book.douban.com/subject/26358448/",
    "id": "26358448",
    "publisher": "清华大学出版社",
    "isbn10": "7302392641",
    "isbn13": "9787302392644",
    "title": "人月神话(40周年中文纪念版)",
    "url": "https://api.douban.com/v2/book/26358448",
    "alt_title": "(美) 布鲁克斯(Brooks, F. P.)  著",
    "author_intro": "小弗雷德里克•布鲁克斯曾获得美国计算机领域最具声望的图灵奖(A. M. Turing Award)。美国计算机协会(ACM)称赞他“对计算机体系结构、操作系统和软件工程做出了里程碑式的贡献”。\n布鲁克斯博士1956年开始任职于IBM公司，早期担任Stretch 和Harvest计算机的体系建构师。他被认为是“IBM 360系统之父”，曾担任360系统的项目经理。凭借在此项目中的杰出贡献，他与Bob Evans和Erich Bloch在1985年获得了美国国家技术奖(National Medal of Technology)。\n布鲁克斯博士创立了北卡罗来纳大学的计算机科学系，并于1965-1985年担任系主任。他还曾任职于美国国家科技局和国防科学技术委员会。目前其仍活跃于从事虚拟环境和科学可视化等方面的研究工作，2010年获得虚拟现实事业奖(IEEE Virtual Reality Career Award)。",
    "summary": "在软件领域，很少能有像《人月神话》一样具有深远影响力和畅销不衰的著作。Brooks博士为人们管理复杂项目提供了最具洞察力的见解，既有很多发人深省的观点，又有大量软件工程的实践。本书内容来自Brooks博士在IBM公司SYSTEM／360家族和OS／360中的项目管理经验，该项目堪称软件开发项目管理的典范。该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄、中、韩等多种文字，全球销售数百万册。确立了其在行业内的经典地位。\n在本书第一次出版40年后的今天，我们重新整理了Brooks博士的经典内容，并将国内软件开发领域先行者们对《人月神话》中的实践及系统理论的使用经验和心得集结成册免费赠与大家共享，更使本书成为国内从业者的必读经典之一。\n本书读者包括：软件开发人员、软件项目经理、系统分析师等IT从业者。",
    "price": "68.00元"
  },
  "9787115221704": {
    "rating": { "max": 10, "numRaters": 1553, "average": "9.1", "min": 0 },
    "subtitle": "改善既有代码的设计",
    "author": ["Martin Fowler"],
    "pubdate": "2010",
    "tags": [
      { "count": 1378, "name": "重构", "title": "重构" },
      { "count": 851, "name": "软件工程", "title": "软件工程" },
      { "count": 723, "name": "代码优化", "title": "代码优化" },
      { "count": 665, "name": "编程", "title": "编程" },
      { "count": 479, "name": "计算机", "title": "计算机" },
      { "count": 455, "name": "软件开发", "title": "软件开发" },
      { "count": 263, "name": "经典", "title": "经典" },
      { "count": 245, "name": "架构", "title": "架构" }
    ],
    "origin_title": "Refactoring: Improving the Design of Existing Code",
    "image": "https://img3.doubanio.com/view/subject/m/public/s4157180.jpg",
    "binding": "平装",
    "translator": ["熊节"],
    "catalog": "第1章 重构，第一个案例1\n1.1 起点1\n1.2 重构的第一步7\n1.3 分解并重组statement()8\n1.4 运用多态取代与价格相关的条件逻辑34\n1.5 结语52\n第2章 重构原则53\n2.1 何谓重构53\n2.2 为何重构55\n2.3 何时重构57\n2.4 怎么对经理说60\n2.5 重构的难题62\n2.6 重构与设计66\n2.7 重构与性能69\n2.8 重构起源何处71\n第3章 代码的坏味道75\n3.1 DuplicatedCode（重复代码）76\n3.2 LongMethod（过长函数）76\n3.3 LargeClass（过大的类）78\n3.4 LongParameterList（过长参数列）78\n3.5 DivergentChange（发散式变化）79\n3.6 ShotgunSurgery（霰弹式修改）80\n3.7 FeatureEnvy（依恋情结）80\n3.8 DataClumps（数据泥团）81\n3.9 PrimitiveObsession（基本类型偏执）81\n3.10 SwitchStatements（switch惊悚现身）82\n3.11 ParallelInheritanceHierarchies（平行继承体系）83\n3.12 LazyClass（冗赘类）83\n3.13 SpeculativeGenerality（夸夸其谈未来性）83\n3.14 TemporaryField（令人迷惑的暂时字段）84\n3.15 MessageChains（过度耦合的消息链）84\n3.16 MiddleMan（中间人）85\n3.17 InappropriateIntimacy（狎昵关系）85\n3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85\n3.19 IncompleteLibraryClass（不完美的库类）86\n3.20 DataClass（纯稚的数据类）86\n3.21 RefusedBequest（被拒绝的遗赠）87\n3.22 Comments（过多的注释）87\n第4章 构筑测试体系89\n4.1 自测试代码的价值89\n4.2 JUnit测试框架91\n4.3 添加更多测试97\n第5章 重构列表103\n5.1 重构的记录格式103\n5.2 寻找引用点105\n5.3 这些重构手法有多成熟106\n第6章 重新组织函数109\n6.1 ExtractMethod（提炼函数）110\n6.2 InlineMethod（内联函数）117\n6.3 InlineTemp（内联临时变量）119\n6.4 ReplaceTempwithQuery（以查询取代临时变量）120\n6.5 IntroduceExplainingVariable（引入解释性变量）124\n6.6 SplitTemporaryVariable（分解临时变量）128\n6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131\n6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135\n6.9 SubstituteAlgorithm（替换算法）139\n第7章 在对象之间搬移特性141\n7.1 MoveMethod（搬移函数）142\n7.2 MoveField（搬移字段）146\n7.3 ExtractClass（提炼类）149\n7.4 InlineClass（将类内联化）154\n7.5 HideDelegate（隐藏“委托关系”）157\n7.6 RemoveMiddleMan（移除中间人）160\n7.7 IntroduceForeignMethod（引入外加函数）162\n7.8 IntroduceLocalExtension（引入本地扩展）164\n第8章 重新组织数据169\n8.1 SelfEncapsulateField（自封装字段）171\n8.2 ReplaceDataValuewithObject（以对象取代数据值）175\n8.3 ChangeValuetoReference（将值对象改为引用对象）179\n8.4 ChangeReferencetoValue（将引用对象改为值对象）183\n8.5 ReplaceArraywithObject（以对象取代数组）186\n8.6 DuplicateObservedData（复制“被监视数据”）189\n8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197\n8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200\n8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204\n8.10 EncapsulateField（封装字段）206\n8.11 EncapsulateCollection（封装集合）208\n8.12 ReplaceRecordwithDataClass（以数据类取代记录）217\n8.13 ReplaceTypeCodewithClass（以类取代类型码）218\n8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223\n8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227\n8.16 ReplaceSubclasswithFields（以字段取代子类）232\n第9章 简化条件表达式237\n9.1 DecomposeConditional（分解条件表达式）238\n9.2 ConsolidateConditionalExpression（合并条件表达式）240\n9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243\n9.4 RemoveControlFlag（移除控制标记）245\n9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250\n9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255\n9.7 IntroduceNullObject（引入Null对象）260\n9.8 IntroduceAssertion（引入断言）267\n第10章 简化函数调用271\n10.1 RenameMethod（函数改名）273\n10.2 AddParameter（添加参数）275\n10.3 RemoveParameter（移除参数）277\n10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279\n10.5 ParameterizeMethod（令函数携带参数）283\n10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285\n10.7 PreserveWholeObject（保持对象完整）288\n10.8 ReplaceParameterwithMethods（以函数取代参数）292\n10.9 IntroduceParameterObject（引入参数对象）295\n10.10 RemoveSettingMethod（移除设值函数）300\n10.11 HideMethod（隐藏函数）303\n10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304\n10.13 EncapsulateDowncast（封装向下转型）308\n10.14 ReplaceErrorCodewithException（以异常取代错误码）310\n10.15 ReplaceExceptionwithTest（以测试取代异常）315\n第11章 处理概括关系319\n11.1 PullUpField（字段上移）320\n11.2 PullUpMethod（函数上移）322\n11.3 PullUpConstructorBody（构造函数本体上移）325\n11.4 PushDownMethod（函数下移）328\n11.5 PushDownField（字段下移）329\n11.6 ExtractSubclass（提炼子类）330\n……\n第12章 大型重构359\n第13章 重构，复用与现实379\n第14章 重构工具401\n第15章 总结409\n参考书目413\n要点列表417\n索引419",
    "pages": "428",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s4157180.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s4157180.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s4157180.jpg"
    },
    "alt": "https://book.douban.com/subject/4262627/",
    "id": "4262627",
    "publisher": "人民邮电出版社",
    "isbn10": "7115221707",
    "isbn13": "9787115221704",
    "title": "重构",
    "url": "https://api.douban.com/v2/book/4262627",
    "alt_title": "Refactoring: Improving the Design of Existing Code",
    "author_intro": "Martin Fowler  世界软件开发大师，在面向对象分析设计、UML、模式、XP和重构等领域都有卓越贡献，现为著名软件开发咨询公司ThoughtWorks的首席科学家。他的多部著作《分析模式》、《UML精粹》和《企业应用架构模式》等都已经成为脍炙人口的经典。\n其他参编者——\nKent Beck 软件开发方法学的泰斗，极限编程的创始人。他是Three Rivers Institute公司总裁，也是Agitar Software的成员。\nJohn Brant和Don Roberts The Refactory公司的创始人，Refactoring Browser （http://st-www.cs.illinois.edu/users/brant/Refactory/）的开发者，多年来一直从事研究重构的实践与理论。\nWilliam Opdyke  目前在朗讯贝尔实验室工作，他写的关于面向对象框架的博士论文是重构方面的第一篇著名文章。",
    "summary": "重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。\n本书凝聚了软件开发社区专家多年摸索而获得的宝贵经验，拥有不因时光流逝而磨灭的价值。今天，无论是重构本身，业界对重构的理解，还是开发工具对重构的支持力度，都与本书最初出版时不可同日而语，但书中所蕴涵的意味和精华，依然值得反复咀嚼，而且往往能够常读常新。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "69.00元"
  },
  "9787115238870": {
    "rating": { "max": 10, "numRaters": 148, "average": "9.1", "min": 0 },
    "subtitle": "软件核心复杂性应对之道",
    "author": ["埃文斯"],
    "pubdate": "2010-11",
    "tags": [
      { "count": 261, "name": "领域驱动设计", "title": "领域驱动设计" },
      { "count": 151, "name": "软件工程", "title": "软件工程" },
      { "count": 139, "name": "软件架构", "title": "软件架构" },
      { "count": 89, "name": "架构", "title": "架构" },
      { "count": 87, "name": "程序设计", "title": "程序设计" },
      { "count": 83, "name": "软件开发", "title": "软件开发" },
      { "count": 66, "name": "领域驱动", "title": "领域驱动" },
      { "count": 66, "name": "计算机", "title": "计算机" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27608362.jpg",
    "binding": "平装",
    "translator": ["赵俐", "盛海艳", "刘霞"],
    "catalog": "第一部分 让领域模型发挥作用\n第1章 消化知识\n1.1 有效建模的要素\n1.2 知识消化\n1.3 持续学习\n1.4 知识丰富的设计\n1.5 深层模型\n第2章 语言的交流和使用\n2.1 模式：UBIQUITOUS LANGUAGE\n2.2 “大声地”建模\n2.3 一个团队，一种语言\n2.4 文档和图\n2.4.1 书面设计文档\n2.4.2 完全依赖可执行代码的情况\n2.5 解释性模型\n第3章 绑定模型和实现\n3.1 模式：MODEL-DRIVEN DESIGN\n3.2 建模范式和工具支持\n3.3 揭示主旨：为什么模型对用户至关重要\n3.4 模式：HANDS-ON MODELER\n第二部分 模型驱动设计的构造块\n第4章 分离领域\n4.1 模式：LAYERED ARCHITECTURE\n4.1.1 将各层关联起来\n4.1.2 架构框架\n4.2 模型属于领域层\n4.3 模式：THE SMART UI“ANTI-PATTERN”\n4.4 其他分离方式\n第5章 软件中所表示的模型\n5.1 关联\n5.2 模式：ENTITY（又称为REFERENCE OBJECT）\n5.2.1 ENTITY建模\n5.2.2 设计标识操作\n5.3 模式：VALUE OBJECT\n5.3.1 设计VALUE OBJECT\n5.3.2 设计包含VALUE OBJECT的关联\n5.4 模式：SERVICE\n5.4.1 SERVICE与孤立的领域层\n5.4.2 粒度\n5.4.3 对SERVICE的访问\n5.5 模式：ＭODULE（也称为PACKAGE）\n5.5.1 敏捷的MODULE\n5.5.2 基础设施驱动的打包存在的隐患\n5.6 建模范式\n5.6.1 对象范式流行的原因\n5.6.2 对象世界中的非对象\n5.6.3 在混合范式中坚持使用MODEL-DRIVEN DESIGN\n第6章 领域对象的生命周期\n6.1 模式：AGGREGATE\n6.2 模式：FACTORY\n6.2.1 选择FACTORY及其应用位置\n6.2.2 有些情况下只需使用构造函数\n6.2.3 接口的设计\n6.2.4 固定规则的逻辑应放置在哪里\n6.2.5 ENTITY FACTORY与VALUE OBJECT FACTORY\n6.2.6 重建已存储的对象\n6.3 模式：REPOSITORY\n6.3.1 REPOSITORY的查询\n6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略\n6.3.3 REPOSITORY的实现\n6.3.4 在框架内工作\n6.3.5 REPOSITORY与FACTORY的关系\n6.4 为关系数据库设计对象\n第7章 使用语言：一个扩展的示例\n7.1 货物运输系统简介\n7.2 隔离领域：应用程序的引入\n7.3 将ENTITY和VALUE OBJECT区别开\n7.4 设计运输系统中的关联\n7.5 AGGREGATE边界\n7.6 选择REPOSITORY\n7.7 场景走查\n7.7.1 应用程序特性举例：更改Cargo的目的地\n7.7.2 应用程序特性举例：重复业务\n7.8 对象的创建\n7.8.1 Cargo的FACTORY和构造函数\n7.8.2 添加一个Handling Event\n7.9 停下来重构：Cargo AGGREGATE的另一种设计\n7.10 运输模型中的ＭODULE\n7.11 引入新特性：配额检查\n7.11.1 连接两个系统\n7.11.2 进一步完善模型：划分业务\n7.11.3 性能优化\n7.12 小结\n第三部分 通过重构来加深理解\n第8章 突破\n8.1 一个突破的故事\n8.1.1 华而不实的模型\n8.1.2 突破\n8.1.3 更深层模型\n8.1.4 冷静决策\n8.1.5 成果\n8.2 机遇\n8.3 关注根本\n8.4 后记：越来越多的新理解\n第9章 将隐式概念转变为显式概念\n9.1 概念挖掘\n9.1.1 倾听语言\n9.1.2 检查不足之处\n9.1.3 思考矛盾之处\n9.1.4 查阅书籍\n9.1.5 尝试，再尝试\n9.2 如何为那些不太明显的概念建模\n9.2.1 显式的约束\n9.2.2 作为领域对象的过程\n9.2.3 模式：SPECIFICATION\n9.2.4 SPECIFICATION的应用和实现\n第10章 柔 性 设 计\n10.1 模式：INTENTION-REVEALING INTERFACES\n10.2 模式：SIDE-EFFECT-FREE FUNCTION\n10.3 模式：ASSERTION\n10.4 模式：CONCEPTUAL CONTOUR\n10.5 模式：STANDALONE CLASS\n10.6 模式：CLOSURE OF OPERATION\n10.7 声明式设计\n10.8 声明式设计风格\n10.9 切入问题的角度\n10.9.1 分割子领域\n10.9.2 尽可能利用已有的形式\n第11章 分析模式的应用\n第12章 将设计模式应用于模型\n12.1 模式：STRATEGY（也称为POLICY）\n12.2 模式：COMPOSITE\n12.3 为什么没有介绍FLYWEIGHT\n第13章 通过重构得到更深层的理解\n13.1 开始重构\n13.2 探索团队\n13.3 借鉴先前的经验\n13.4 针对开发人员的设计\n13.5 重构的时机\n13.6 危机就是机遇\n第四部分 战略设计\n第14章 保持模型的完整性\n14.1 模式：BOUNDED CONTEXT\n14.2 模式：CONTINUOUS INTEGRATION\n14.3 模式：CONTEXT MAP\n14.3.1 测试CONTEXT的边界\n14.3.2 CONTEXT MAP的组织和文档化\n14.4 BOUNDED CONTEXT之间的关系\n14.5 模式：SHARED KERNEL\n14.6 模式：CUSTOMER/SUPPLIERDEVELOPMENT TEAM\n14.7 模式：CONFORMIST\n14.8 模式：ANTICORRUPTION LAYER\n14.8.1 设计ANTICORRUPTION LAYER的接口\n14.8.2 实现ANTICORRUPTION LAYER\n14.8.3 一个关于防御的故事\n14.9 模式：SEPARATE WAY\n14.10 模式：OPEN HOST SERVICE\n14.11 模式：PUBLISHED LANGUAGE\n14.12 “大象”的统一\n14.13 选择你的模型上下文策略\n14.13.1 制定团队决策或更高层的决策\n14.13.2 在上下文中工作\n14.13.3 转换边界\n14.13.4 接受那些我们无法更改的事物：描述外部系统\n14.13.5 与外部系统的关系\n14.13.6 正在设计的系统\n14.13.7 满足不同模型的特殊需要\n14.13.8 部署\n14.13.9 权衡\n14.13.10 当项目正在进行时\n14.14 转换\n14.14.1 合并CONTEXT：SEPARATE WAY →SHARED KERNEL\n14.14.2 合并CONTEXT：SHARED KERNEL→CONTINUOUS INTEGRATION\n14.14.3 逐步淘汰遗留系统\n14.14.4 OPEN HOST SERVICE→PUBLISHED LANGUAGE\n第15章 精炼\n15.1 模式：CORE DOMAIN\n15.1.1 选择核心\n15.1.2 工作的分配\n15.2 精炼的逐步提升\n15.3 模式：GENERIC SUBDOMAIN\n15.3.1 通用不等于可以重用\n15.3.2 项目风险管理\n15.4 模式：DOMAIN VISION STATEMENT\n15.5 模式：HIGHLIGHTED CORE\n15.5.1 精炼文档\n15.5.2 标明CORE\n15.5.3 把精炼文档作为过程工具\n15.6 模式：COHESIVE MECHANISM\n15.6.1 GENERIC SUBDOMAIN与COHE-SIVE MECHANISM的比较\n15.6.2 MECHANISM是CORE DOMAIN一部分\n15.7 通过精炼得到声明式风格\n15.8 模式：SEGREGATED CORE\n15.8.1 创建SEGREGATED CORE的代价\n15.8.2 不断发展演变的团队决策\n15.9 模式：ABSTRACT CORE\n15.10 深层模型精炼\n15.11 选择重构目标\n第16章 大比例结构\n16.1 模式：EVOLVING ORDER\n16.2 模式：SYSTEM METAPHOR\n16.3 模式：RESPONSIBILITY LAYER\n16.4 模式：KNOWLEDGE LEVEL\n16.5 模式：PLUGGABLE COMPONENT FRAMEWORK\n16.6 结构应该有一种什么样的约束\n16.7 通过重构得到更适当的结构\n16.7.1 最小化\n16.7.2 沟通和自律\n16.7.3 通过重构得到柔性设计\n16.7.4 通过精炼可以减轻负担\n第17章 领域驱动设计的综合运用\n17.1 把大比例结构与BOUNDED CONTEXT结合起来使用\n17.2 将大比例结构与精炼结合起来使用\n17.3 首先评估\n17.4 由谁制定策略\n17.4.1 从应用程序开发自动得出的结构\n17.4.2 以客户为中心的架构团队\n17.5 制定战略设计决策的6个要点\n17.5.1 技术框架同样如此\n17.5.2 注意总体规划\n结束语\n附录\n术语表\n参考文献\n图片说明\n索引",
    "pages": "369",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27608362.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27608362.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27608362.jpg"
    },
    "alt": "https://book.douban.com/subject/5344973/",
    "id": "5344973",
    "publisher": "人民邮电出版社",
    "isbn10": "7115238871",
    "isbn13": "9787115238870",
    "title": "领域驱动设计",
    "url": "https://api.douban.com/v2/book/5344973",
    "alt_title": "",
    "author_intro": "",
    "summary": "《领域驱动设计:软件核心复杂性应对之道》是领域驱动设计方面的经典之作。全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。书中给出了领域驱动设计的系统化方法，并将人们普遍接受的一些最佳实践综合到一起，融入了作者的见解和经验，展现了一些可扩展的设计最佳实践、已验证过的技术以及便于应对复杂领域的软件项目开发的基本原则。《领域驱动设计:软件核心复杂性应对之道》适合各层次的面向对象软件开发人员、系统分析员阅读。",
    "price": "69.00元"
  },
  "9787115330246": {
    "rating": { "max": 10, "numRaters": 330, "average": "8.2", "min": 0 },
    "subtitle": "像google一样进行软件测试",
    "author": ["James A. Whittaker", "Jason Arbon", "Jeff Carollo"],
    "pubdate": "2013-10",
    "tags": [
      { "count": 514, "name": "软件测试", "title": "软件测试" },
      { "count": 208, "name": "测试", "title": "测试" },
      { "count": 160, "name": "Google", "title": "Google" },
      { "count": 120, "name": "测试方法", "title": "测试方法" },
      { "count": 100, "name": "软件工程", "title": "软件工程" },
      { "count": 94, "name": "计算机", "title": "计算机" },
      { "count": 69, "name": "软件开发", "title": "软件开发" },
      { "count": 45, "name": "计算机科学", "title": "计算机科学" }
    ],
    "origin_title": "How Google Tests Software",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27082506.jpg",
    "binding": "平装",
    "translator": ["黄利", "李中杰", "薛明"],
    "catalog": "《google软件测试之道》\n第1章　google软件测试介绍　1\n1.1　质量不等于测试　5\n1.2　角色　6\n1.2.1　软件开发工程师(swe)　7\n1.2.2　软件测试开发工程师(set)　7\n1.2.3　测试工程师(te)　8\n1.3　组织结构　9\n1.4　爬、走、跑　10\n1.5　测试类型　12\n第2章　软件测试开发工程师　15\n2.1　set的工作　17\n2.1.1　开发和测试流程　17\n2.1.2　set究竟是谁　21\n2.1.3　项目的早期阶段　22\n2.1.4　团队结构　23\n2.1.5　设计文档　24\n2.1.6　接口与协议　26\n2.1.7　自动化计划　27\n2.1.8　可测试性　28\n.2.1.9　set的工作流程：一个实例　31\n2.1.10　测试执行　41\n2.1.11　测试大小的定义　42\n2.1.12　测试规模在共享测试平台中的使用　45\n2.1.13　测试规模的益处　46\n2.1.14　测试运行要求　48\n2.2　测试认证　54\n2.3　set的招聘　62\n2.4　与工具开发工程师ted mao的访谈　68\n2.5　与web driver的创建者simon stewart的对话　70\n第3章　测试工程师　75\n3.1　一种面向用户的测试角色　75\n3.2　测试工程师的工作　76\n3.2.1　测试计划　79\n3.2.2　风险　94\n3.2.3　测试用例的生命周期　104\n3.2.4　bug的生命周期　109\n3.2.5　te的招聘　121\n3.2.6　google的测试领导和管理工作　128\n3.2.7　维护模式的测试(maintenance mode testing)　131\n3.2.8　质量机器人(quality bot)实验　134\n3.2.9　bite实验　145\n3.2.10　google test analytics　154\n3.2.11　零成本测试流程　159\n3.2.12　外部供应商　163\n3.3　与google docs测试工程师林赛·韦伯斯特(lindsay webster)的访谈　165\n3.4　与youtube测试工程师安普·周(apple chow)的访谈　170\n第4章　测试工程经理　177\n4.1　测试工程经理的工作　177\n4.2　获得项目和人员　179\n4.3　影响力　180\n4.4　gmail测试工程经理ankit mehta的访谈　182\n4.5　android测试工程经理hung dang的访谈　188\n4.6　chrome测试工程经理joel hynoski的访谈　192\n4.7　测试总监　197\n4.8　搜索和地理信息测试总监shelton mar的访谈　198\n4.9　工程工具总监ashish kumar的访谈　201\n4.10　印度google测试总监sujaysahni访谈　205\n4.11　工程经理brad green访谈　209\n4.12　james whittaker访谈　212\n第5章　google软件测试改进　219\n5.1　google流程中的致命缺陷　219\n5.2　set的未来　221\n5.3　te的未来　222\n5.4　测试总监和经理的未来　223\n5.5　未来的测试基础设施　224\n5.6　结论　225\n附录a　chrome os测试计划　227\na.1　测试主题概述　227\na.2　风险分析　228\na.3　每次构建版本的基线测试　228\na.4　最新可测试版本(last known good，lkg)的每日测试　229\na.5　发布版本测试　229\na.6　手工测试与自动化测试　229\na.7　开发和测试的质量关注点　230\na.8　发布通道　230\na.9　用户输入　230\na.10　测试用例库　231\na.11　测试仪表盘　231\na.12　虚拟化　231\na.13　性能　231\na.14　压力、长时运行和稳定性测试　231\na.15　测试执行框架(autotest)　232\na.16　oem厂商　232\na.17　硬件实验田　232\na.18　端到端测试自动化集群　232\na.19　测试浏览器的应用管理器　232\na.20　浏览器的可测试性　233\na.21　硬件　234\na.22　时间线　234\na.23　主要的测试驱动力　236\na.24　相关文档　236\n附录b　chrome的漫游测试　239\nb.1　购物漫游　239\nb.2　学生漫游　240\nb.3　国际长途电话漫游　241\nb.4　地标漫游　241\nb.5　通宵漫游　242\nb.6　公务漫游测试　243\nb.7　危险地带漫游　243\nb.8　个性化漫游　244\n附录c　有关工具和代码的博客文章　245\nc.1　使用bite从bug和冗余的工作中解脱出来　245\nc.2　发布qualitybot　247\nc.3　rpf：google的录制回放框架　249\nc.4　google测试分析系统(google test analytics)——现在开源了　251\n附录d　术语表　257",
    "pages": "258",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27082506.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27082506.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27082506.jpg"
    },
    "alt": "https://book.douban.com/subject/25742200/",
    "id": "25742200",
    "publisher": "人民邮电出版社",
    "isbn10": "7115330247",
    "isbn13": "9787115330246",
    "title": "Google软件测试之道",
    "url": "https://api.douban.com/v2/book/25742200",
    "alt_title": "How Google Tests Software",
    "author_intro": "james whittaker 是google的工程总监 ，负责部分google产品的测试，包括chrome、地图、google web apps。在加盟google之前，james在microsoft工作，再之前是一名大学教授。james在全球测试领域闻名遐迩。\njason arbon 是google的一名测试工程师te ，曾参与负责google桌面、chrome和chrome os的测试。同时jason也是一系列开源测试工具和个性化实验的开发负责人。在加入google之前，他也曾在microsoft工作过。\njeff carollo 是google的一名测试开发工程师set，曾参与负责google voice、工具框、chrome、chrome os产品 的测试。jeff为许多google内部的开发团队提供咨询服务，帮助提升这些团队初期的代码质量。之后在2010年，jeff转岗为软件开发工程师（se），并领导负责google+ apis的开发。在加入google之前，jeff也曾经在microsoft工作过。",
    "summary": "每天，google都要测试和发布数百万个源文件、亿万行的代码。数以亿计的构建动作会触发几百万次的自动化测试，并在好几十万个浏览器实例上执行。面对这些看似不可能完成的任务，谷歌是如何测试的呢？\n《google软件测试之道》从内部视角告诉你这个世界上知名的互联网公司是如何应对21世纪软件测试的独特挑战的。《google软件测试之道》抓住了google做测试的本质，抓住了google测试这个时代最复杂软件的精华。《google软件测试之道》描述了测试解决方案，揭示了测试架构是如何设计、实现和运行的，介绍了软件测试工程师的角色；讲解了技术测试人员应该具有的技术技能；阐述了测试工程师在产品生命周期中的职责；讲述了测试管理及在google的测试历史或在主要产品上发挥了重要作用的工程师的访谈，这对那些试图建立类似google的测试流程或团队的人受益很大。\n最后，《google软件测试之道》还介绍了作者对于google测试如何继续演进的见解、google乃至整个业界的测试方向的一些预言，相信很多读者都会感受到其中的洞察力，甚至感到震惊。本书可以作为任何从事软件测试人员到达目标的指南。\n《google软件测试之道》适合开发人员、测试人员、测试管理人员使用，也适合大中专院校相关专业师生的学习用书，以及培训学校的教材。",
    "price": "59.00元"
  },
  "9787111173199": {
    "rating": { "max": 10, "numRaters": 195, "average": "8.4", "min": 0 },
    "subtitle": "",
    "author": ["梅尔斯"],
    "pubdate": "2006年01月",
    "tags": [
      { "count": 416, "name": "软件测试", "title": "软件测试" },
      { "count": 125, "name": "软件测试的艺术", "title": "软件测试的艺术" },
      { "count": 125, "name": "测试", "title": "测试" },
      { "count": 82, "name": "计算机", "title": "计算机" },
      { "count": 63, "name": "软件工程", "title": "软件工程" },
      { "count": 48, "name": "IT", "title": "IT" },
      { "count": 45, "name": "编程", "title": "编程" },
      { "count": 43, "name": "Test", "title": "Test" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s1694970.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "",
    "pages": "122 页",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s1694970.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s1694970.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s1694970.jpg"
    },
    "alt": "https://book.douban.com/subject/1445661/",
    "id": "1445661",
    "publisher": "机械工业出版社",
    "isbn10": "7111173198",
    "isbn13": "9787111173199",
    "title": "软件测试的艺术",
    "url": "https://api.douban.com/v2/book/1445661",
    "alt_title": "",
    "author_intro": "",
    "summary": "《软件测试的艺术》(原书第2版)成功、有效地进行软件测试的实用策略和技术：\n　　 基本的测试原理和策略　　　　　 验收测试\n　　 程序检查和走查 　　　　　　　  安装测试\n　　 代码检查　　　　　　　　　　　 模块（单元）测试\n　　 错误列表　　　　　　　　　　　 测试规划与控制\n　　 同行评分　　　　　　　　　　　 独立测试机构\n　　 黑盒、白盒测试　　　　　　　　 调试原理\n　　 错误猜测　　　　　　　　　　　 错误分析\n　　 自顶向下与自底向上测试　　　　 极限测试\n　　 高级测试　　　　　　　　　　　 测试因特网应用系统\n　　 功能和系统测试 　　　　　　　  电子商务体系结构的高级测试",
    "series": { "id": "9870", "title": "华章·软件工程技术丛书" },
    "price": "22.0"
  },
  "9787121315787": {
    "rating": { "max": 10, "numRaters": 51, "average": "7.3", "min": 0 },
    "subtitle": "",
    "author": ["李艳鹏", "杨彪"],
    "pubdate": "2017-8",
    "tags": [
      { "count": 69, "name": "分布式", "title": "分布式" },
      { "count": 59, "name": "架构", "title": "架构" },
      { "count": 32, "name": "微服务", "title": "微服务" },
      { "count": 25, "name": "软件架构", "title": "软件架构" },
      { "count": 21, "name": "软件开发", "title": "软件开发" },
      { "count": 12, "name": "计算机", "title": "计算机" },
      { "count": 10, "name": "Java", "title": "Java" },
      { "count": 7, "name": "互联网", "title": "互联网" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29496866.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章  分布式微服务架构设计原理\t1\n1.1  从传统单体架构到服务化架构\t2\n1.1.1  JEE架构\t2\n1.1.2  SSH架构\t5\n1.1.3  服务化架构\t8\n1.2  从服务化到微服务\t11\n1.2.1  微服务架构的产生\t12\n1.2.2  微服务架构与传统单体架构的对比\t13\n1.2.3  微服务架构与SOA服务化的对比\t15\n1.3  微服务架构的核心要点和实现原理\t16\n1.3.1  微服务架构中职能团队的划分\t16\n1.3.2  微服务的去中心化治理\t18\n1.3.3  微服务的交互模式\t18\n1.3.4  微服务的分解和组合模式\t22\n1.3.5  微服务的容错模式\t35\n1.3.6  微服务的粒度\t41\n1.4  Java平台微服务架构的项目组织形式\t42\n1.4.1  微服务项目的依赖关系\t42\n1.4.2  微服务项目的层级结构\t43\n1.4.3  微服务项目的持续发布\t45\n1.5  服务化管理和治理框架的技术选型\t45\n1.5.1  RPC\t46\n1.5.2  服务化\t47\n1.5.3  微服务\t49\n1.6  本章小结\t52\n第2章  彻底解决分布式系统一致性的问题\t54\n2.1  什么是一致性\t55\n2.2  一致性问题\t56\n2.3  解决一致性问题的模式和思路\t57\n2.3.1  酸碱平衡理论\t58\n2.3.2  分布式一致性协议\t61\n2.3.3  保证最终一致性的模式\t67\n2.4  超时处理模式\t75\n2.4.1  微服务的交互模式\t76\n2.4.2  同步与异步的抉择\t77\n2.4.3  交互模式下超时问题的解决方案\t78\n2.4.4  超时补偿的原则\t85\n2.5  迁移开关的设计\t87\n2.6  本章小结\t88\n第3章  服务化系统容量评估和性能保障\t89\n3.1  架构设计与非功能质量\t90\n3.2  全面的非功能质量需求\t91\n3.2.1  非功能质量需求的概述\t91\n3.2.2  非功能质量需求的具体指标\t92\n3.3  典型的技术评审提纲\t97\n3.3.1  现状\t97\n3.3.2  需求\t98\n3.3.3  方案描述\t98\n3.3.4  方案对比\t99\n3.3.5  风险评估\t100\n3.3.6  工作量评估\t100\n3.4  性能和容量评估经典案例\t100\n3.4.1  背景\t100\n3.4.2  目标数据量级\t101\n3.4.3  量级评估标准\t101\n3.4.4  方案\t102\n3.4.5  小结\t107\n3.5  性能评估参考标准\t108\n3.5.1  常用的应用层性能指标参考标准\t108\n3.5.2  常用的系统层性能指标参考标准\t109\n3.6  性能测试方案的设计和最佳实践\t112\n3.6.1  明确压测目标\t112\n3.6.2  压测场景设计和压测方案制定\t114\n3.6.3  准备压测环境\t121\n3.6.4  压测的执行\t122\n3.6.5  问题修复和系统优化\t123\n3.7  有用的压测工具\t123\n3.7.1  ab\t123\n3.7.2  jmeter\t125\n3.7.3  mysqlslap\t125\n3.7.4  sysbench\t129\n3.7.5  dd\t134\n3.7.6  LoadRunner\t135\n3.7.7  hprof\t136\n3.8  本章小结\t138\n第4章  大数据日志系统的构建\t140\n4.1  开源日志框架的原理分析与应用实践\t142\n4.1.1  JDK Logger\t142\n4.1.2  Apache Commons Logging\t143\n4.1.3  Apache Log4j\t147\n4.1.4  Slf4j\t156\n4.1.5  Logback\t160\n4.1.6  Apache Log4j 2\t164\n4.2  日志系统的优化和最佳实践\t168\n4.2.1  开发人员的日志意识\t168\n4.2.2  日志级别的设置\t168\n4.2.3  日志的数量和大小\t169\n4.2.4  切割方式\t170\n4.2.5  日志格式的配置\t170\n4.2.6  一行日志导致的线上事故\t177\n4.3  大数据日志系统的原理与设计\t178\n4.3.1  通用架构和设计\t179\n4.3.2  日志采集器\t180\n4.3.3  日志缓冲队列\t186\n4.3.4  日志解析器\t187\n4.3.5  日志存储和搜索\t187\n4.3.6  日志展示系统\t188\n4.3.7  监控和报警\t188\n4.3.8  日志系统的容量和性能评估\t188\n4.4  ELK系统的构建与使用\t190\n4.4.1  Elasticsearch\t191\n4.4.2  Logstash\t193\n4.4.3  Kibana\t196\n4.5  本章小结\t198\n第5章  基于调用链的服务治理系统的设计与实现\t199\n5.1  APM系统简介\t200\n5.1.1  优秀的开源APM系统\t200\n5.1.2  国内商业APM产品的介绍\t202\n5.2  调用链跟踪的原理\t203\n5.2.1  分布式系统的远程调用过程\t204\n5.2.2  TraceID\t207\n5.2.3  SpanID\t208\n5.2.4  业务链\t210\n5.3  调用链跟踪系统的设计与实现\t211\n5.3.1  整体架构\t211\n5.3.2  TraceID和SpanID在服务间的传递\t213\n5.3.3  采集器的设计与实现\t217\n5.3.4  处理器的设计与实现\t222\n5.3.5  调用链系统的展示\t225\n5.4  本章小结\t226\n第6章  Java服务的线上应急和技术攻关\t227\n6.1  海恩法则和墨菲定律\t227\n6.2  线上应急的目标、原则和方法\t229\n6.2.1  应急目标\t229\n6.2.2  应急原则\t229\n6.2.3  线上应急的方法和流程\t230\n6.3  技术攻关的方法论\t233\n6.4  环境搭建和示例服务启动\t236\n6.5  高效的服务化治理脚本\t240\n6.5.1  show-busiest-java-threads\t240\n6.5.2  find-in-jar\t243\n6.5.3  grep-in-jar\t244\n6.5.4  jar-conflict-detect\t245\n6.5.5  http-spy\t247\n6.5.6  show-mysql-qps\t248\n6.5.7  小结\t249\n6.6  JVM提供的监控命令\t249\n6.6.1  jad\t249\n6.6.2  btrace\t250\n6.6.3  jmap\t252\n6.6.4  jstat\t255\n6.6.5  jstack\t256\n6.6.6  jinfo\t258\n6.6.7  其他命令\t258\n6.6.8  小结\t259\n6.7  重要的Linux基础命令\t260\n6.7.1  必不可少的基础命令和工具\t260\n6.7.2  查看活动进程的命令\t268\n6.7.3  窥探内存的命令\t270\n6.7.4  针对CPU使用情况的监控命令\t272\n6.7.5  监控磁盘I/O的命令\t273\n6.7.6  查看网络信息和网络监控命令\t275\n6.7.7  Linux系统的高级工具\t287\n6.7.8  /proc文件系统\t288\n6.7.9  摘要命令\t288\n6.7.10  小结\t290\n6.8  现实中的应急和攻关案例\t291\n6.8.1  一次OOM事故的分析和定位\t291\n6.8.2  一次CPU 100%的线上事故排查\t301\n6.9  本章小结\t304\n第7章  服务的容器化过程\t306\n7.1  容器vs虚拟机\t306\n7.1.1  什么是虚拟机\t306\n7.1.2  什么是容器\t306\n7.1.3  容器和虚拟机的区别\t307\n7.1.4  容器主要解决的问题\t307\n7.1.5  Docker的优势\t310\n7.2  Docker实战\t311\n7.2.1  Docker的架构\t311\n7.2.2  Docker的安装\t315\n7.2.3  Docker初体验\t319\n7.2.4  Docker后台服务的管理\t322\n7.2.5  Docker的客户端命令\t328\n7.2.6  Docker Compose编排工具的使用\t372\n7.3  容器化项目\t379\n7.3.1  传统的应用部署\t380\n7.3.2  将应用程序部署在虚拟机上\t380\n7.3.3  容器化部署应用\t381\n7.3.4  Docker实现的应用容器化示例\t382\n7.4  本章小结\t384\n第8章  敏捷开发2.0的自动化工具\t385\n8.1  什么是敏捷开发2.0\t385\n8.1.1  常用的4种开发模式\t385\n8.1.2  什么是DevOps\t390\n8.1.3  敏捷开发2.0解决的问题\t392\n8.2  敏捷开发的自动化流程\t393\n8.2.1  持续集成\t393\n8.2.2  持续交付和持续部署\t397\n8.3  敏捷开发的常用自动化工具\t400\n8.3.1  分布式版本控制工具Git\t400\n8.3.2  持续集成和持续交付工具Jenkins\t410\n8.3.3  基础平台管理工具SaltStack\t418\n8.3.4  Docker容器化工具\t421\n8.4  本章小结\t422",
    "ebook_url": "https://read.douban.com/ebook/49567191/",
    "pages": "400",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29496866.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29496866.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29496866.jpg"
    },
    "alt": "https://book.douban.com/subject/27091029/",
    "id": "27091029",
    "publisher": "电子工业出版社",
    "isbn10": "7121315785",
    "isbn13": "9787121315787",
    "title": "分布式服务架构：原理、设计与实战",
    "url": "https://api.douban.com/v2/book/27091029",
    "alt_title": "",
    "author_intro": "李艳鹏\n现任易宝支付产品中心首席架构师，曾在花旗银行、甲骨文、路透社、新浪微博等大型IT互联网公司担任技术负责人和架构师，现专注于大规模、高并发的线上和线下支付平台的应用架构和技术架构的规划与落地，负责交易、支付、渠道、出款、风控、对账等核心支付系统的设计与实现，对移动支付、聚合支付、合规账户、扫码支付、标记化支付等业务场景有产品应用架构规划与落地的实践经验。\n杨 彪\n现任某创业公司技术总监及合伙人，在互联网和游戏行业有近10年工作经验，曾在酷我音乐盒、人人游戏和掌趣科技等上市公司担任核心研发职位，在互联网公司做过日活跃用户量达千万的项目，也在游戏公司做过多款月流水千万以上的游戏。喜欢研究问题，追求前沿技术，学无止境。",
    "summary": "《分布式服务架构：原理、设计与实战》全面介绍了分布式服务架构的原理与设计，并结合作者在实施微服务架构过程中的实践经验，总结了保障线上服务健康、可靠的最佳方案，是一本架构级、实战型的重量级著作。\n《分布式服务架构：原理、设计与实战》以分布式服务架构的设计与实现为主线，由浅入深地介绍了分布式服务架构的方方面面，主要包括理论和实践两部分。理论上，首先介绍了服务架构的背景，以及从服务化架构到微服务架构的演化；然后提出了保证分布式服务系统架构一致性的方案和模式，并介绍了互联网架构评审的方法论；最后给出了一个简要的非功能质量的技术评审提纲。实践上，首先提供了一个互联网项目的性能和容量评估的真实案例，介绍了压测的方案设计和最佳实践，这些技术能够全面保证大规模、高并发项目的一致性、可用性和高并发性；然后讲解了大规模服务的日志系统的原理、设计与实践，包括ELK等框架的特点和使用方式等，并介绍了当前流行的APM系统的设计与实现，主要包括调用链和业务链的跟踪与恢复，涵盖了线上应急和技术攻关的流程及重点，也结合服务化系统线上应急过程进行分析并总结了其中需要用到的Java虚拟机、Linux和定制化脚本等命令，这些命令都是每个开发人员都会用到的解决线上问题的利器；最后，阐述了系统服务的容器化过程，并详细介绍了敏捷开发流程和实现自动化的常用工具等，让读者既能学到架构设计的基础理论，也能结合书中的原理、设计与方法论来解决大规模、高并发互联网项目中的现实问题。\n无论是对于软件工程师、测试工程师、运维工程师、软件架构师、技术经理、技术总监，还是对于资深IT人士来说，《分布式服务架构：原理、设计与实战》都有很强的借鉴性和参考价值。",
    "ebook_price": "53.40",
    "price": "89.00"
  },
  "9787121271649": {
    "rating": { "max": 10, "numRaters": 79, "average": "7.1", "min": 0 },
    "subtitle": "高效部署分布式消息队列",
    "author": ["Alvaro Videla", "Jason J. W. Williams"],
    "pubdate": "2015-10",
    "tags": [
      { "count": 83, "name": "消息队列", "title": "消息队列" },
      { "count": 50, "name": "rabbitmq", "title": "rabbitmq" },
      { "count": 43, "name": "分布式", "title": "分布式" },
      { "count": 25, "name": "RabbitMQ", "title": "RabbitMQ" },
      { "count": 15, "name": "Erlang", "title": "Erlang" },
      { "count": 13, "name": "架构", "title": "架构" },
      { "count": 9, "name": "计算机", "title": "计算机" },
      { "count": 9, "name": "编程", "title": "编程" }
    ],
    "origin_title": "RabbitMQ in Action : Distributed Messaging for Everyone",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28324884.jpg",
    "binding": "平装",
    "translator": ["汪佳南"],
    "catalog": "第1章 天降奇兵 1\n1.1 住在别人的地下城堡 3\n1.2 救世主AMQP 5\n1.3 RabbitMQ简史 5\n1.4 百里挑一 8\n1.5 在UNIX系统上安装RabbitMQ 8\n1.5.1 为什么环境很重要--生活在Erlang 的世界里 9\n1.5.2 获取安装包 9\n1.5.3 设置文件夹结构 9\n1.5.4 首次运行Rabbit 10\n1.6 总结 12\n第2章 理解消息通信13\n2.1 消费者和生产者（这可不是经济学课程哦） 14\n2.2 从底部开始构造：队列 17\n2.3 联合起来：交换器和绑定 22\n2.4 多租户模式：虚拟主机和隔离 27\n2.5 我的消息去哪儿了呢？持久化和你的策略 28\n2.6 把所有内容结合起来：一条消息的一生 32\n2.7 使用发送方确认模式来确认投递 37\n2.8 总结 40\n第3章 运行和管理Rabbit 42\n3.1 服务器管理 43\n3.1.1 启动节点 43\n3.1.2 停止节点 45\n3.1.3 关闭和重启应用程序：有何差别 46\n3.1.4 Rabbit 配置文件 46\n3.2 请求许可 48\n3.2.1 管理用户 49\n3.2.2 Rabbit 的权限系统 50\n3.3 检查 54\n3.3.1 查看数据统计 54\n3.3.2 理解RabbitMQ 日志 59\n3.4 修复Rabbit：疑难解答 63\n由badrpc、nodedown 和其他Erlang 引起的问题 63\n3.5 总结 68\n第4章 解决Rabbit相关问题：编码与模式69\n4.1 解耦风雨路：谁将我们推向消息通信 70\n4.1.1 异步状态思维（分离请求和动作） 70\n4.1.2 提供扩展性：没有负载均衡器的世界 73\n4.1.3 零成本API ：语言不应成为枷锁 73\n4.2 发后即忘模型 74\n4.2.1 发送告警 75\n4.2.2 并行处理 84\n4.3 别忘了：用RabbitMQ实现RPC并等待响应 92\n4.3.1 私有队列和发送确认 93\n4.3.2 使用reply_to 来实现简单的JSON RPC 93\n4.4 总结 98\n第5章 集群并处理失败99\n5.1 开足马力：RabbitMQ集群 100\n5.2 集群架构 101\n5.2.1 集群中的队列 101\n5.2.2 分布交换器 103\n5.2.3 是内存节点还是磁盘节点 104\n5.3 在你的笔记本电脑上设置集群 106\n5.4 将节点分布到更多的机器上 110\n5.5 升级集群节点 114\n5.6 镜像队列和保留消息 115\n5.6.1 声明并使用镜像队列 115\n5.6.2 镜像队列工作原理 118\n5.7 总结 120\n第6章 从故障中恢复121\n6.1 为Rabbit做负载均衡 122\n6.1.1 安装HAProxy 124\n6.1.2 配置HAProxy 125\n6.2 连接丢失和故障转移 127\n6.3 总结 134\n第7章 warren和Shovel：故障转移和复制 135\n7.1 warren：另一种集群方式 136\n7.2 设定负载均衡器--基于主/从的集群 138\n7.3 远距离通信和复制 142\n7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142\n7.3.2 安装Shovel 145\n7.3.3 配置并运行Shovel 146\n7.4 总结 152\n第8章 从Web端管理RabbitMQ 154\n8.1 超越rabbitmqctl：RabbitMQ Management插件 155\n8.1.1 为何需要Management 插件 155\n8.1.2 Management 插件功能 155\n8.1.3 启用Management 插件 156\n8.2 从Web控制台来管理RabbitMQ 158\n8.2.1 监控Erlang VM 158\n8.2.2 从JSON 文件导入配置 159\n8.3 从Web控制台管理用户 160\n8.3.1 创建用户 161\n8.3.2 管理用户的权限 162\n8.4 从Web控制台管理交换器和队列 163\n8.4.1 列出队列信息 165\n8.4.2 创建队列 166\n8.5 回到命令行 168\n8.5.1 为什么需要另一个CLI 168\n8.5.2 CLI 管理：一种更简单的方式 170\n8.5.3 安装rabbitmqadmin 脚本 170\n8.5.4 清空队列、创建交换器等 171\n8.6 总结 172\n第9章 使用REST API控制Rabbit 173\n9.1 能用RabbitMQ REST API做什么 175\n9.2 对客户端授权访问 177\n9.3 访问数据统计 178\n9.4 自动化vhost和用户配置 181\n9.5 总结 .186\n第10章 监控187\n10.1 监控RabbitMQ：密切关注你的warren 188\n10.1.1 为Nagios 编写健康检测 188\n10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190\n10.1.3 使用REST API 来检测 193\n10.1.4 监控配置文件修改 196\n10.1.5 监控集群状态 201\n10.2 确保消费者正常工作 206\n10.2.1 通过AMQP 监控队列等级 208\n10.2.2 使用REST API 来监控队列级别 212\n10.2.3 建立队列的消息计数基准经验法则 215\n10.3 总结216\n第11章 提升性能，保障安全217\n11.1 对速度的需求 218\n11.1.1 消息持久化 218\n11.1.2 消息确认 219\n11.1.3 路由算法和绑定规则 219\n11.1.4 投递消息 221\n11.2 内存使用率和进程限制 223\n11.2.1 内存使用率 223\n11.2.2 Erlang 进程计数 226\n11.3 SSL连接 ..227\n11.3.1 SSL 证书.228\n11.3.2 设置证书颁发机构 ..229\n11.3.3 生成根证书 233\n11.3.4 生成服务器端证书 234\n11.3.5 生成客户端证书 235\n11.3.6 启用RabbitMQ 的SSL 监听器 236\n11.3.7 测试你的RabbitMQ SSL 设置 237\n11.4 总结 239\n第12章 聪明的Rabbit：扩展RabbitMQ241\n12.1 RabbitMQ插件 242\n12.1.1 你可以用插件做什么 242\n12.1.2 在哪里可以找到插件 244\n12.1.3 安装插件 244\n12.1.4 移除插件 245\n12.2 制作你自己的插件 247\n12.2.1 获取RabbitMQ Public Umbrella 248\n12.2.2 设置文件夹结构 249\n12.2.3 包含插件构建系统 250\n12.2.4 创建Erlang 应用文件 250\n12.3 创建自定义交换器模块 252\n12.3.1 将交换器注册到RabbitMQ 254\n12.3.2 实现交换器behaviour 257\n12.3.3 编译自定义交换器 264\n12.3.4 测试你的插件 267\n12.4 总结 271\n附录A 在Java和.NET上使用Rabbit 273\n附录B 在线资源302\n附录C 在Windows上安装RabbitMQ 307",
    "pages": "332",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28324884.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28324884.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28324884.jpg"
    },
    "alt": "https://book.douban.com/subject/26649178/",
    "id": "26649178",
    "publisher": "电子工业出版社",
    "isbn10": "7121271648",
    "isbn13": "9787121271649",
    "title": "RabbitMQ实战",
    "url": "https://api.douban.com/v2/book/26649178",
    "alt_title": "RabbitMQ in Action : Distributed Messaging for Everyone",
    "author_intro": "Alvaro Videla是一名专门从事基于MQ应用程序的开发者和架构师。\nJason J.W. Williams是消息通信服务供应商DigiTar公司的CTO，他领导着设计与开发工作。",
    "summary": "本书对RabbitMQ做了全面、翔实的讲解，体现了两位专家的真知灼见。本书首先介绍了有关MQ的历史，然后从基本的消息通信原理讲起，带领读者一路探索RabbitMQ的消息通信世界。这当中不仅包含了针对单台RabbitMQ服务器和RabbitMQ集群的讲解，还教导读者如何使用各种工具来进行监控。\n本书内容浅显易懂，文笔风趣幽默。书中包含了丰富的、可以运行的示例程序源代码，读者可以自行下载并运行，这种亲身实践有助于加深对相关主题的理解。对于初学者来说，这样的编排非常适用。对于那些有一定RabbitMQ使用经验的读者来说，本书不仅可以巩固消息通信基本原理，同时也可加深对RabbitMQ高级特性的理解，譬如如何编写RabbitMQ插件。相信处于RabbitMQ探索之旅不同阶段的读者都能从本书获益。\n本书适合有一定工作经验的开发者或者架构师阅读，也可以作为RabbitMQ运维工作的参考手册。",
    "price": "75.00元"
  },
  "9787115473271": {
    "rating": { "max": 10, "numRaters": 114, "average": "8.9", "min": 0 },
    "subtitle": "",
    "author": ["Neha Narkhede", "Gwen Shapira", "Todd Palino"],
    "pubdate": "2017-12-26",
    "tags": [
      { "count": 126, "name": "Kafka", "title": "Kafka" },
      { "count": 69, "name": "消息队列", "title": "消息队列" },
      { "count": 38, "name": "大数据", "title": "大数据" },
      { "count": 38, "name": "分布式", "title": "分布式" },
      { "count": 34, "name": "计算机", "title": "计算机" },
      { "count": 27, "name": "架构", "title": "架构" },
      { "count": 25, "name": "大数据流", "title": "大数据流" },
      { "count": 11, "name": "计算机科学", "title": "计算机科学" }
    ],
    "origin_title": "Kafka: The Definitive Guide",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29665582.jpg",
    "binding": "平装",
    "translator": ["薛命灯"],
    "catalog": "序 xiii\n前言 xv\n第 1 章　初识Kafka 1\n1.1　发布与订阅消息系统 1\n1.1.1　如何开始 2\n1.1.2　独立的队列系统 3\n1.2　Kafka登场 4\n1.2.1　消息和批次 4\n1.2.2　模式 4\n1.2.3　主题和分区 5\n1.2.4　生产者和消费者 5\n1.2.5　broker和集群 6\n1.2.6　多集群 7\n1.3　为什么选择Kafka 8\n1.3.1　多个生产者 8\n1.3.2　多个消费者 8\n1.3.3　基于磁盘的数据存储 9\n1.3.4　伸缩性 9\n1.3.5　高性能 9\n1.4　数据生态系统 9\n1.5　起源故事 11\n1.5.1　LinkedIn的问题 11\n1.5.2　Kafka的诞生 12\n1.5.3　走向开源 12\n1.5.4　命名 13\n1.6　开始Kafka之旅 13\n第 2 章　安装Kafka 14\n2.1　要事先行 14\n2.1.1　选择操作系统 14\n2.1.2　安装Java 14\n2.1.3　安装Zookeeper 15\n2.2　安装Kafka Broker 17\n2.3　broker配置 18\n2.3.1　常规配置 18\n2.3.2　主题的默认配置 19\n2.4　硬件的选择 23\n2.4.1　磁盘吞吐量 23\n2.4.2　磁盘容量 23\n2.4.3　内存 23\n2.4.4　网络 24\n2.4.5　CPU 24\n2.5　云端的Kafka 24\n2.6　Kafka集群 24\n2.6.1　需要多少个broker 25\n2.6.2　broker 配置 25\n2.6.3　操作系统调优 26\n2.7　生产环境的注意事项 28\n2.7.1　垃圾回收器选项 28\n2.7.2　数据中心布局 29\n2.7.3　共享Zookeeper 29\n2.8　总结 30\n第 3 章　Kafka生产者——向Kafka写入数据 31\n3.1　生产者概览 32\n3.2　创建Kafka生产者 33\n3.3　发送消息到Kafka 34\n3.3.1　同步发送消息 35\n3.3.2　异步发送消息 35\n3.4　生产者的配置 36\n3.5　序列化器 39\n3.5.1　自定义序列化器 39\n3.5.2　使用Avro序列化 41\n3.5.3　在Kafka里使用Avro 42\n3.6　分区 45\n3.7　旧版的生产者API 46\n3.8　总结 47\n第 4 章　Kafka消费者——从Kafka读取数据 48\n4.1　KafkaConsumer概念 48\n4.1.1　消费者和消费者群组 48\n4.1.2　消费者群组和分区再均衡 51\n4.2　创建Kafka消费者 52\n4.3　订阅主题 53\n4.4　轮询 53\n4.5　消费者的配置 55\n4.6　提交和偏移量 57\n4.6.1　自动提交 58\n4.6.2　提交当前偏移量 59\n4.6.3　异步提交 59\n4.6.4　同步和异步组合提交 61\n4.6.5　提交特定的偏移量 61\n4.7　再均衡监听器 62\n4.8　从特定偏移量处开始处理记录 64\n4.9　如何退出 66\n4.10　反序列化器 67\n4.11　独立消费者——为什么以及怎样使用没有群组的消费者 71\n4.12　旧版的消费者API 71\n4.13　总结 72\n第 5 章　深入Kafka 73\n5.1　集群成员关系 73\n5.2　控制器 74\n5.3　复制 74\n5.4　处理请求 76\n5.4.1　生产请求 78\n5.4.2　获取请求 78\n5.4.3　其他请求 80\n5.5　物理存储 81\n5.5.1　分区分配 81\n5.5.2　文件管理 82\n5.5.3　文件格式 83\n5.5.4　索引 84\n5.5.5　清理 84\n5.5.6　清理的工作原理 84\n5.5.7　被删除的事件 86\n5.5.8　何时会清理主题 86\n5.9　总结 86\n第 6 章　可靠的数据传递 87\n6.1　可靠性保证 87\n6.2　复制 88\n6.3　broker配置 89\n6.3.1　复制系数 89\n6.3.2　不完全的首领选举 90\n6.3.3　最少同步副本 91\n6.4　在可靠的系统里使用生产者 92\n6.4.1　发送确认 92\n6.4.2　配置生产者的重试参数 93\n6.4.3　额外的错误处理 94\n6.5　在可靠的系统里使用消费者 94\n6.5.1　消费者的可靠性配置 95\n6.5.2　显式提交偏移量 95\n6.6　验证系统可靠性 97\n6.6.1　配置验证 98\n6.6.2　应用程序验证 98\n6.6.3　在生产环境监控可靠性 99\n6.7　总结 100\n第 7 章　构建数据管道 101\n7.1　构建数据管道时需要考虑的问题 102\n7.1.1　及时性 102\n7.1.2　可靠性 102\n7.1.3　高吞吐量和动态吞吐量 103\n7.1.4　数据格式 103\n7.1.5　转换 104\n7.1.6　安全性 104\n7.1.7　故障处理能力 104\n7.1.8　耦合性和灵活性 105\n7.2　如何在Connect API和客户端API之间作出选择 105\n7.3　Kafka Connect 106\n7.3.1　运行Connect 106\n7.3.2　连接器示例——文件数据源和文件数据池 107\n7.3.3　连接器示例——从MySQL到ElasticSearch 109\n7.3.4　深入理解Connect 114\n7.4　Connect之外的选择 116\n7.4.1　用于其他数据存储的摄入框架 116\n7.4.2　基于图形界面的ETL工具 117\n7.4.3　流式处理框架 117\n7.5　总结 117\n第 8 章　跨集群数据镜像 118\n8.1　跨集群镜像的使用场景 118\n8.2　多集群架构 119\n8.2.1　跨数据中心通信的一些现实情况 119\n8.2.2　Hub和Spoke架构 120\n8.2.3　双活架构 121\n8.2.4　主备架构 123\n8.2.5　延展集群 127\n8.3　Kafka的MirrorMaker 128\n8.3.1　如何配置 129\n8.3.2　在生产环境部署MirrorMaker 130\n8.3.3　MirrorMaker调优 132\n8.4　其他跨集群镜像方案 134\n8.4.1　优步的uReplicator 134\n8.4.2　Confluent的Replicator 135\n8.5　总结 135\n第 9 章　管理Kafka 136\n9.1　主题操作 136\n9.1.1　创建主题 137\n9.1.2　增加分区 138\n9.1.3　删除主题 138\n9.1.4　列出集群里的所有主题 139\n9.1.5　列出主题详细信息 139\n9.2　消费者群组 140\n9.2.1　列出并描述群组 140\n9.2.2　删除群组 142\n9.2.3　偏移量管理 142\n9.3　动态配置变更 143\n9.3.1　覆盖主题的默认配置 143\n9.3.2　覆盖客户端的默认配置 145\n9.3.3　列出被覆盖的配置 145\n9.3.4　移除被覆盖的配置 146\n9.4　分区管理 146\n9.4.1　首选的首领选举 146\n9.4.2　修改分区副本 147\n9.4.3　修改复制系数 150\n9.4.4　转储日志片段 151\n9.4.5　副本验证 152\n9.5　消费和生产 153\n9.5.1　控制台消费者 153\n9.5.2　控制台生产者 155\n9.6　客户端ACL 157\n9.7　不安全的操作 157\n9.7.1　移动集群控制器 157\n9.7.2　取消分区重分配 157\n9.7.3　移除待删除的主题 158\n9.7.4　手动删除主题 158\n9.8　总结 159\n第 10 章　监控Kafka 160\n10.1　度量指标基础 160\n10.1.1　度量指标在哪里 160\n10.1.2　内部或外部度量 161\n10.1.3　应用程序健康检测 161\n10.1.4　度量指标的覆盖面 161\n10.2　broker的度量指标 162\n10.2.1　非同步分区 162\n10.2.2　broker度量指标 166\n10.2.3　主题和分区的度量指标 173\n10.2.4　Java虚拟机监控 174\n10.2.5　操作系统监控 175\n10.2.6　日志 176\n10.3　客户端监控 177\n10.3.1　生产者度量指标 177\n10.3.2　消费者度量指标 179\n10.3.3　配额 181\n10.4　延时监控 182\n10.5　端到端监控 183\n10.6　总结 183\n第 11 章　流式处理 184\n11.1　什么是流式处理 185\n11.2　流式处理的一些概念 186\n11.2.1　时间 187\n11.2.2　状态 188\n11.2.3　流和表的二元性 188\n11.2.4　时间窗口 189\n11.3　流式处理的设计模式 190\n11.3.1　单个事件处理 191\n11.3.2　使用本地状态 191\n11.3.3　多阶段处理和重分区 193\n11.3.4　使用外部查找——流和表的连接 193\n11.3.5　流与流的连接 195\n11.3.6　乱序的事件 195\n11.3.7　重新处理 196\n11.4　Streams示例 197\n11.4.1　字数统计 197\n11.4.2　股票市场统计 199\n11.4.3　填充点击事件流 201\n11.5　Kafka Streams的架构概览 202\n11.5.1　构建拓扑 202\n11.5.2　对拓扑进行伸缩 203\n11.5.3　从故障中存活下来 205\n11.6　流式处理使用场景 205\n11.7　如何选择流式处理框架 206\n11.8　总结 208\n附录A　在其他操作系统上安装Kafka 209\n作者介绍 214\n封面介绍 214",
    "pages": "214",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29665582.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29665582.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29665582.jpg"
    },
    "alt": "https://book.douban.com/subject/27665114/",
    "id": "27665114",
    "publisher": "人民邮电出版社",
    "isbn10": "7115473277",
    "isbn13": "9787115473271",
    "title": "Kafka权威指南",
    "url": "https://api.douban.com/v2/book/27665114",
    "alt_title": "Kafka: The Definitive Guide",
    "author_intro": "Neha Narkhede， Confluent联合创始人、CTO，曾在LinkedIn主导基于Kafka和Apache Samza构建流式基础设施，是Kafka作者之一。\nGwen Shapira， Confluent系统架构师，帮助客户构建基于Kafka的系统，在可伸缩数据架构方面拥有十余年经验；曾任Cloudera公司解决方案架构师。另著有《Hadoop应用架构》。\nTodd Palino， LinkedIn主任级SRE，负责部署管理大型的Kafka、Zookeeper和Samza集群。\n【译者简介】\n薛命灯，毕业于厦门大学软件学院，十余年软件开发和架构经验，InfoQ高级社区编辑。译有《硅谷革命》《生产微服务》等书。微信公众号CodeDeep。",
    "summary": "每个应用程序都会产生数据，包括日志消息、度量指标、用户活动记录、响应消息等。如何移动数据，几乎变得与数据本身一样重要。如果你是架构师、开发者或者产品工程师，同时也是Apache Kafka新手，那么这本实践指南将会帮助你成为流式平台上处理实时数据的专家。\n本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节。\n● 了解发布和订阅消息模型以及该模型如何被应用在大数据生态系统中\n● 学习使用Kafka生产者和消费者来生成消息和读取消息\n● 了解Kafka保证可靠性数据传递的模式和场景需求\n● 使用Kafka构建数据管道和应用程序的最佳实践\n● 在生产环境中管理Kafka，包括监控、调优和维护\n● 了解Kafka的关键度量指标\n● 探索Kafka如何成为流式处理利器",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "69.00元"
  },
  "9780596521998": {
    "rating": { "max": 10, "numRaters": 266, "average": "8.3", "min": 0 },
    "subtitle": "MapReduce for the Cloud",
    "author": ["Tom White"],
    "pubdate": "2009",
    "tags": [
      { "count": 316, "name": "hadoop", "title": "hadoop" },
      { "count": 177, "name": "MapReduce", "title": "MapReduce" },
      { "count": 151, "name": "分布式", "title": "分布式" },
      { "count": 60, "name": "Cloud", "title": "Cloud" },
      { "count": 41, "name": "计算机", "title": "计算机" },
      { "count": 40, "name": "架构", "title": "架构" },
      { "count": 36, "name": "Hadoop", "title": "Hadoop" },
      { "count": 26, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s3810946.jpg",
    "binding": "pap",
    "translator": [],
    "catalog": "",
    "pages": "250",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s3810946.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s3810946.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s3810946.jpg"
    },
    "alt": "https://book.douban.com/subject/3220004/",
    "id": "3220004",
    "publisher": "O'Reilly Media, Inc.",
    "isbn10": "0596521995",
    "isbn13": "9780596521998",
    "title": "Hadoop: The Definitive Guide",
    "url": "https://api.douban.com/v2/book/3220004",
    "alt_title": "",
    "author_intro": "",
    "summary": "Apache Hadoop is ideal for organizations with a growing need to store and process massive application datasets. Hadoop: The Definitive Guide is a comprehensive resource for using Hadoop to build reliable, scalable, distributed systems. Programmers will find details for analyzing large datasets with Hadoop, and administrators will learn how to set up and run Hadoop clusters. The book includes case studies that illustrate how Hadoop solves specific problems.\nOrganizations large and small are adopting Apache Hadoop to deal with huge application datasets. Hadoop: The Definitive Guide provides you with the key for unlocking the wealth this data holds. Hadoop is ideal for storing and processing massive amounts of data, but until now, information on this open-source project has been lacking -- especially with regard to best practices. This comprehensive resource demonstrates how to use Hadoop to build reliable, scalable, distributed systems. Programmers will find details for analyzing large datasets with Hadoop, and administrators will learn how to set up and run Hadoop clusters.\nWith case studies that illustrate how Hadoop solves specific problems, this book helps you:\n* Learn the Hadoop Distributed File System (HDFS), including ways to use its many APIs to transfer data\n* Write distributed computations with MapReduce, Hadoop's most vital component\n* Become familiar with Hadoop's data and IO building blocks for compression, data integrity, serialization, and persistence\n* Learn the common pitfalls and advanced features for writing real-world MapReduce programs\n* Design, build, and administer a dedicated Hadoop cluster\n* Use HBase, Hadoop's database for structured and semi-structured data\nAnd more. Hadoop: The Definitive Guide is still in progress, but you can get started on this technology with the Rough Cuts edition, which lets you read the book online or download it in PDF format as the manuscript evolves.",
    "price": "44.99"
  },
  "9787121249679": {
    "rating": { "max": 10, "numRaters": 302, "average": "7.8", "min": 0 },
    "subtitle": "分布式一致性原理与实践",
    "author": ["倪超"],
    "pubdate": "2015-2-1",
    "tags": [
      { "count": 335, "name": "分布式", "title": "分布式" },
      { "count": 286, "name": "ZooKeeper", "title": "ZooKeeper" },
      { "count": 129, "name": "Paxos", "title": "Paxos" },
      { "count": 126, "name": "分布式一致性", "title": "分布式一致性" },
      { "count": 61, "name": "计算机", "title": "计算机" },
      { "count": 54, "name": "zookeeper", "title": "zookeeper" },
      { "count": 47, "name": "软件架构", "title": "软件架构" },
      { "count": 40, "name": "Java", "title": "Java" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28377338.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1章分布式架构\t1\n1.1  从集中式到分布式\t1\n1.1.1  集中式的特点\t2\n1.1.2  分布式的特点\t2\n1.1.3  分布式环境的各种问题\t4\n1.2  从ACID到CAP/BASE\t5\n1.2.1  ACID\t5\n1.2.2  分布式事务\t8\n1.2.3  CAP和BASE理论\t9\n小结\t15\n第2章一致性协议\t17\n2.1  2PC与3PC\t17\n2.1.1  2PC\t17\n2.1.2  3PC\t21\n2.2  Paxos算法\t24\n2.2.1  追本溯源\t25\n2.2.2  Paxos理论的诞生\t26\n2.2.3  Paxos算法详解\t27\n小结\t37\n第3章Paxos的工程实践\t39\n3.1  Chubby\t39\n3.1.1  概述\t39\n3.1.2  应用场景\t40\n3.1.3  设计目标\t40\n3.1.4  Chubby技术架构\t43\n3.1.5  Paxos协议实现\t52\n3.2  Hypertable\t55\n3.2.1  概述\t55\n3.2.2  算法实现\t57\n小结\t58\n第4章ZooKeeper与Paxos\t59\n4.1  初识ZooKeeper\t59\n4.1.1  ZooKeeper介绍\t59\n4.1.2  ZooKeeper从何而来\t62\n4.1.3  ZooKeeper的基本概念\t62\n4.1.4  为什么选择ZooKeeper\t64\n4.2  ZooKeeper的ZAB协议\t65\n4.2.1  ZAB协议\t65\n4.2.2  协议介绍\t66\n4.2.3  深入ZAB协议\t71\n4.2.4  ZAB与Paxos算法的联系与区别\t77\n小结\t78\n第5章使用ZooKeeper\t79\n5.1  部署与运行\t79\n5.1.1  系统环境\t79\n5.1.2  集群与单机\t80\n5.1.3  运行服务\t84\n5.2  客户端脚本\t88\n5.2.1  创建\t88\n5.2.2  读取\t89\n5.2.3  更新\t90\n5.2.4  删除\t91\n5.3  Java客户端API使用\t91\n5.3.1  创建会话\t91\n5.3.2  创建节点\t95\n5.3.3  删除节点\t99\n5.3.4  读取数据\t100\n5.3.5  更新数据\t109\n5.3.6  检测节点是否存在\t113\n5.3.7  权限控制\t115\n5.4  开源客户端\t120\n5.4.1  ZkClient\t120\n5.4.2  Curator\t130\n小结\t162\n第6章ZooKeeper的典型应用场景\t163\n6.1  典型应用场景及实现注\t163\n6.1.1  数据发布/订阅\t164\n6.1.2  负载均衡\t166\n6.1.3  命名服务\t170\n6.1.4  分布式协调/通知\t173\n6.1.5  集群管理\t179\n6.1.6  Master选举\t185\n6.1.7  分布式锁\t188\n6.1.8  分布式队列\t194\n小结\t197\n6.2  ZooKeeper在大型分布式系统中的应用\t197\n6.2.1  Hadoop\t198\n6.2.2  HBase\t203\n6.2.3  Kafka\t207\n6.3  ZooKeeper在阿里巴巴的实践与应用\t213\n6.3.1  案例一消息中间件：Metamorphosis\t213\n6.3.2  案例二  RPC服务框架：Dubbo\t217\n6.3.3  案例三基于MySQL Binlog的增量订阅和消费组件：Canal\t219\n6.3.4  案例四分布式数据库同步系统：Otter\t223\n6.3.5  案例五轻量级分布式通用搜索平台：终搜\t226\n6.3.6  案例六实时计算引擎：JStorm\t238\n小结\t242\n第7章ZooKeeper技术内幕\t243\n7.1  系统模型\t243\n7.1.1  数据模型\t243\n7.1.2  节点特性\t244\n7.1.3  版本——保证分布式数据原子性操作\t246\n7.1.4  Watcher——数据变更的通知\t249\n7.1.5  ACL——保障数据的安全\t265\n7.2  序列化与协议\t272\n7.2.1  Jute介绍\t272\n7.2.2  使用Jute进行序列化\t273\n7.2.3  深入Jute\t275\n7.2.4  通信协议\t277\n7.3  客户端\t284\n7.3.1  一次会话的创建过程\t286\n7.3.2  服务器地址列表\t289\n7.3.3  ClientCnxn：网络I/O\t295\n7.4  会话\t298\n7.4.1  会话状态\t298\n7.4.2  会话创建\t299\n7.4.3  会话管理\t304\n7.4.4  会话清理\t307\n7.4.5  重连\t309\n7.5  服务器启动\t311\n7.5.1  单机版服务器启动\t312\n7.5.2  集群版服务器启动\t315\n7.6  Leader选举\t321\n7.6.1  Leader选举概述\t321\n7.6.2  Leader选举的算法分析\t323\n7.6.3  Leader选举的实现细节\t328\n7.7  各服务器角色介绍\t335\n7.7.1  Leader\t335\n7.7.2  Follower\t338\n7.7.3  Observer\t339\n7.7.4  集群间消息通信\t339\n7.8  请求处理\t342\n7.8.1  会话创建请求\t343\n7.8.2  SetData请求\t351\n7.8.3  事务请求转发\t354\n7.8.4  GetData请求\t355\n7.9  数据与存储\t356\n7.9.1  内存数据\t356\n7.9.2  事务日志\t358\n7.9.3  snapshot——数据快照\t364\n7.9.4  初始化\t368\n7.9.5  数据同步\t372\n小结\t376\n第8章ZooKeeper运维\t379\n8.1  配置详解\t379\n8.1.1  基本配置\t379\n8.1.2  高级配置\t380\n8.2  四字命令\t384\n8.3  JMX\t390\n8.3.1  开启远程JMX\t390\n8.3.2  通过JConsole连接ZooKeeper\t391\n8.4  监控\t397\n8.4.1  实时监控\t397\n8.4.2  数据统计\t398\n8.5  构建一个高可用的集群\t398\n8.5.1  集群组成\t398\n8.5.2  容灾\t399\n8.5.3  扩容与缩容\t402\n8.6  日常运维\t402\n8.6.1  数据与日志管理\t402\n8.6.2  Too many connections\t404\n8.6.3  磁盘管理\t405\n小结\t405\n附录AWindows平台上部署ZooKeeper\t406\n附录B从源代码开始构建\t409\n附录C各发行版本重大更新记录\t414\n附录DZooKeeper源代码阅读指引\t418",
    "pages": "422",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28377338.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28377338.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28377338.jpg"
    },
    "alt": "https://book.douban.com/subject/26292004/",
    "id": "26292004",
    "publisher": "电子工业出版社",
    "isbn10": "7121249677",
    "isbn13": "9787121249679",
    "title": "从Paxos到Zookeeper",
    "url": "https://api.douban.com/v2/book/26292004",
    "alt_title": "",
    "author_intro": "倪超，阿里巴巴集团高级研发工程师，国家认证系统分析师，毕业于杭州电子科技大学计算机系。2010年加入阿里巴巴中间件团队担任研发实习岗位，一直从事ZooKeeper的开发与运维工作，从中学习与总结了不少分布式一致性相关的理论与实践经验，尤其对ZooKeeper及其相关技术有非常深入的研究。目前在中间件团队专家组任职产品经理，负责分布式产品的产品化和云计算化改造工作。\n新浪微博：@ni掌柜",
    "summary": "《Paxos到Zookeeper：分布式一致性原理与实践》从分布式一致性的理论出发，向读者简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。全书共8章，分为五部分：第一部分（第1章）主要介绍了计算机系统从集中式向分布式系统演变过程中面临的挑战，并简要介绍了ACID、CAP和BASE等经典分布式理论；第二部分（第2～4章）介绍了2PC、3PC和Paxos三种分布式一致性协议，并着重讲解了ZooKeeper中使用的一致性协议——ZAB协议；第三部分（第5～6章）介绍了ZooKeeper的使用方法，包括客户端API的使用以及对ZooKeeper服务的部署与运行，并结合真实的分布式应用场景，总结了ZooKeeper使用的最佳实践；第四部分（第7章）对ZooKeeper的架构设计和实现原理进行了深入分析，包含系统模型、Leader选举、客户端与服务端的工作原理、请求处理，以及服务器角色的工作流程和数据存储等；第五部分（第8章）介绍了ZooKeeper的运维实践，包括配置详解和监控管理等，重点讲解了如何构建一个高可用的ZooKeeper服务。",
    "price": "75.00元"
  },
  "9787121212000": {
    "rating": { "max": 10, "numRaters": 1348, "average": "7.9", "min": 0 },
    "subtitle": "核心原理与案例分析",
    "author": ["李智慧"],
    "pubdate": "2013-9-1",
    "tags": [
      { "count": 1199, "name": "架构", "title": "架构" },
      { "count": 611, "name": "互联网", "title": "互联网" },
      { "count": 446, "name": "Web", "title": "Web" },
      { "count": 328, "name": "计算机", "title": "计算机" },
      { "count": 267, "name": "网站", "title": "网站" },
      { "count": 198, "name": "服务器", "title": "服务器" },
      { "count": 192, "name": "Web开发", "title": "Web开发" },
      { "count": 163, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27250675.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "第1篇  概述\n1      大型网站架构演化\t2\n1.1  大型网站软件系统的特点\t3\n1.2  大型网站架构演化发展历程\t4\n1.2.1  初始阶段的网站架构\t4\n1.2.2  应用服务和数据服务分离\t4\n1.2.3  使用缓存改善网站性能\t5\n1.2.4  使用应用服务器集群改善网站的并发处理能力\t6\n1.2.5  数据库读写分离\t7\n1.2.6  使用反向代理和CDN加速网站响应\t8\n1.2.7  使用分布式文件系统和分布式数据库系统\t9\n1.2.8  使用NoSQL和搜索引擎\t10\n1.2.9  业务拆分\t11\n1.2.10  分布式服务\t11\n1.3  大型网站架构演化的价值观\t13\n1.3.1  大型网站架构技术的核心价值是随网站所需灵活应对\t13\n1.3.2  驱动大型网站技术发展的主要力量是网站的业务发展\t13\n1.4  网站架构设计误区\t14\n1.4.1  一味追随大公司的解决方案\t14\n1.4.2  为了技术而技术\t14\n1.4.3  企图用技术解决所有问题\t14\n1.5  小结\t15\n2      大型网站架构模式\t16\n2.1  网站架构模式\t16\n2.1.1  分层\t17\n2.1.2  分割\t18\n2.1.3  分布式\t18\n2.1.4  集群\t19\n2.1.5  缓存\t20\n2.1.6  异步\t20\n2.1.7  冗余\t21\n2.1.8  自动化\t22\n2.1.9  安全\t23\n2.2  架构模式在新浪微博的应用\t23\n2.3  小结\t25\n3      大型网站核心架构要素\t26\n3.1  性能\t27\n3.2  可用性\t28\n3.3  伸缩性\t29\n3.4  扩展性\t30\n3.5  安全性\t30\n3.6  小结\t31\n第2篇  架构\n4      瞬时响应：网站的高性能架构\t34\n4.1  网站性能测试\t35\n4.1.1  不同视角下的网站性能\t35\n4.1.2  性能测试指标\t36\n4.1.3  性能测试方法\t39\n4.1.4  性能测试报告\t41\n4.1.5  性能优化策略\t41\n4.2  Web前端性能优化\t42\n4.2.1  浏览器访问优化\t42\n4.2.2  CDN加速\t43\n4.2.3  反向代理\t44\n4.3  应用服务器性能优化\t45\n4.3.1  分布式缓存\t45\n4.3.2  异步操作\t52\n4.3.3  使用集群\t53\n4.3.4  代码优化\t54\n4.4  存储性能优化\t58\n4.4.1  机械硬盘vs. 固态硬盘\t58\n4.4.2  B+树vs. LSM树\t59\n4.4.3  RAID vs. HDFS\t61\n4.5  小结\t64\n5      万无一失：网站的高可用架构\t66\n5.1  网站可用性的度量与考核\t67\n5.1.1  网站可用性度量\t67\n5.1.2  网站可用性考核\t67\n5.2  高可用的网站架构\t69\n5.3  高可用的应用\t71\n5.3.1  通过负载均衡进行无状态服务的失效转移\t72\n5.3.2  应用服务器集群的Session管理\t73\n5.4  高可用的服务\t76\n5.5  高可用的数据\t78\n5.5.1  CAP原理\t79\n5.5.2  数据备份\t82\n5.5.3  失效转移\t84\n5.6  高可用网站的软件质量保证\t85\n5.6.1  网站发布\t85\n5.6.2  自动化测试\t86\n5.6.3  预发布验证\t87\n5.6.4  代码控制\t88\n5.6.5  自动化发布\t90\n5.6.6  灰度发布\t91\n5.7  网站运行监控\t91\n5.7.1  监控数据采集\t92\n5.7.2  监控管理\t93\n5.8  小结\t94\n6      永无止境：网站的伸缩性架构\t95\n6.1  网站架构的伸缩性设计\t97\n6.1.1  不同功能进行物理分离实现伸缩\t97\n6.1.2  单一功能通过集群规模实现伸缩\t98\n6.2  应用服务器集群的伸缩性设计\t99\n6.2.1  HTTP重定向负载均衡\t100\n6.2.2  DNS域名解析负载均衡\t101\n6.2.3  反向代理负载均衡\t102\n6.2.4  IP负载均衡\t103\n6.2.5  数据链路层负载均衡\t104\n6.2.6  负载均衡算法\t105\n6.3  分布式缓存集群的伸缩性设计\t106\n6.3.1  Memcached分布式缓存集群的访问模型\t107\n6.3.2  Memcached分布式缓存集群的伸缩性挑战\t107\n6.3.3  分布式缓存的一致性Hash算法\t109\n6.4  数据存储服务器集群的伸缩性设计\t112\n6.4.1  关系数据库集群的伸缩性设计\t113\n6.4.2  NoSQL数据库的伸缩性设计\t117\n6.5  小结\t119\n7      随需应变：网站的可扩展架构\t121\n7.1  构建可扩展的网站架构\t122\n7.2  利用分布式消息队列降低系统耦合性\t123\n7.2.1  事件驱动架构\t123\n7.2.2  分布式消息队列\t124\n7.3  利用分布式服务打造可复用的业务平台\t126\n7.3.1  Web Service与企业级分布式服务\t128\n7.3.2  大型网站分布式服务的需求与特点\t129\n7.3.3  分布式服务框架设计\t130\n7.4  可扩展的数据结构\t131\n7.5  利用开放平台建设网站生态圈\t132\n7.6  小结\t134\n8      固若金汤：网站的安全架构\t135\n8.1  道高一尺魔高一丈的网站应用攻击与防御\t136\n8.1.1  XSS攻击\t136\n8.1.2  注入攻击\t138\n8.1.3  CSRF攻击\t139\n8.1.4  其他攻击和漏洞\t140\n8.1.5  Web应用防火墙\t141\n8.1.6  网站安全漏洞扫描\t142\n8.2  信息加密技术及密钥安全管理\t142\n8.2.1  单向散列加密\t143\n8.2.2  对称加密\t144\n8.2.3  非对称加密\t144\n8.2.4  密钥安全管理\t145\n8.3  信息过滤与反垃圾\t146\n8.3.1  文本匹配\t147\n8.3.2  分类算法\t148\n8.3.3  黑名单\t149\n8.4  电子商务风险控制\t150\n8.4.1  风险\t151\n8.4.2  风控\t151\n8.5  小结\t153\n第3篇  案例\n9      淘宝网的架构演化案例分析\t156\n9.1  淘宝网的业务发展历程\t157\n9.2  淘宝网技术架构演化\t158\n9.3  小结\t162\n10     维基百科的高性能架构设计分析\t163\n10.1  Wikipedia网站整体架构\t163\n10.2  Wikipedia性能优化策略\t165\n10.2.1  Wikipedia前端性能优化\t165\n10.2.2  Wikipedia服务端性能优化\t166\n10.2.3  Wikipedia后端性能优化\t167\n11     海量分布式存储系统Doris的高可用架构设计分析\t169\n11.1  分布式存储系统的高可用架构\t170\n11.2  不同故障情况下的高可用解决方案\t171\n11.2.1  分布式存储系统的故障分类\t172\n11.2.2  正常情况下系统访问结构\t172\n11.2.3  瞬时故障的高可用解决方案\t173\n11.2.4  临时故障的高可用解决方案\t174\n11.2.5  永久故障的高可用解决方案\t175\n12     网购秒杀系统架构设计案例分析\t176\n12.1  秒杀活动的技术挑战\t177\n12.2  秒杀系统的应对策略\t177\n12.3  秒杀系统架构设计\t178\n12.4  小结\t182\n13     大型网站典型故障案例分析\t183\n13.1  写日志也会引发故障\t184\n13.2  高并发访问数据库引发的故障\t184\n13.3  高并发情况下锁引发的故障\t185\n13.4  缓存引发的故障\t185\n13.5  应用启动不同步引发的故障\t186\n13.6  大文件读写独占磁盘引发的故障\t186\n13.7  滥用生产环境引发的故障\t187\n13.8  不规范的流程引发的故障\t187\n13.9  不好的编程习惯引发的故障\t188\n13.10  小结\t188\n第4篇  架构师\n14     架构师领导艺术\t190\n14.1  关注人而不是产品\t191\n14.2  发掘人的优秀\t191\n14.3  共享美好蓝图\t192\n14.4  共同参与架构\t193\n14.5  学会妥协\t194\n14.6  成就他人\t194\n15     网站架构师职场攻略\t196\n15.1  发现问题，寻找突破\t197\n15.2  提出问题，寻求支持\t199\n15.3  解决问题，达成绩效\t201\n16     漫话网站架构师\t203\n16.1  按作用划分架构师\t203\n16.2  按效果划分架构师\t204\n16.3  按职责角色划分架构师\t205\n16.4  按关注层次划分架构师\t205\n16.5  按口碑划分架构师\t206\n16.6  非主流方式划分架构师\t207\n附录A  大型网站架构技术一览\t208\n附录B  Web开发技术发展历程\t215\n后记\t218",
    "ebook_url": "https://read.douban.com/ebook/35648299/",
    "pages": "218",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27250675.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27250675.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27250675.jpg"
    },
    "alt": "https://book.douban.com/subject/25723064/",
    "id": "25723064",
    "publisher": "电子工业出版社",
    "isbn10": "7121212005",
    "isbn13": "9787121212000",
    "title": "大型网站技术架构",
    "url": "https://api.douban.com/v2/book/25723064",
    "alt_title": "",
    "author_intro": "李智慧\n曾在阿里巴巴担任技术专家，参与阿里巴巴基础技术平台开发和www.alibaba.com架构设计。\n目前就职英特尔亚太研发中心从事云计算与大数据方面的研发工作。",
    "summary": "《大型网站技术架构：核心原理与案例分析》通过梳理大型网站技术发展历程，剖析大型网站技术架构模式，深入讲述大型互联网架构设计的核心原理，并通过一组典型网站技术架构设计案例，为读者呈现一幅包括技术选型、架构设计、性能优化、Web 安全、系统发布、运维监控等在内的大型网站开发全景视图。\n《大型网站技术架构：核心原理与案例分析》不仅适用于指导网站工程师、架构师进行网站技术架构设计，也可用于指导产品经理、项目经理、测试运维人员等了解网站技术架构的基础概念；还可供包括企业系统开发人员在内的各类软件开发从业人员借鉴，了解大型网站的解决方案和开发理念。",
    "ebook_price": "23.99",
    "price": "59.00元"
  },
  "9787111430520": {
    "rating": { "max": 10, "numRaters": 388, "average": "7.9", "min": 0 },
    "subtitle": "原理解析与架构实战",
    "author": ["杨传辉"],
    "pubdate": "2013-9-1",
    "tags": [
      { "count": 756, "name": "分布式", "title": "分布式" },
      { "count": 449, "name": "存储", "title": "存储" },
      { "count": 291, "name": "大数据", "title": "大数据" },
      { "count": 249, "name": "架构", "title": "架构" },
      { "count": 143, "name": "计算机", "title": "计算机" },
      { "count": 99, "name": "软件架构", "title": "软件架构" },
      {
        "count": 75,
        "name": "distributed-system",
        "title": "distributed-system"
      },
      { "count": 41, "name": "编程", "title": "编程" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27043456.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "前言\n第1章　概述\n1.1　分布式存储概念\n1.2　分布式存储分类\n第一篇　基础篇\n第2章　单机存储系统\n2.1　硬件基础\n2.1.1　CPU架构\n2.1.2　IO总线\n2.1.3　网络拓扑\n2.1.4　性能参数\n2.1.5　存储层次架构\n2.2　单机存储引擎\n2.2.1　哈希存储引擎\n2.2.2　B树存储引擎\n2.2.3　LSM树存储引擎\n2.3　数据模型\n2.3.1　文件模型\n2.3.2　关系模型\n2.3.3　键值模型\n2.3.4　SQL与NoSQL\n2.4　事务与并发控制\n2.4.1　事务\n2.4.2　并发控制\n2.5　故障恢复\n2.5.1　操作日志\n2.5.2　重做日志\n2.5.3　优化手段\n2.6　数据压缩\n2.6.1　压缩算法\n2.6.2　列式存储\n第3章　分布式系统\n3.1　基本概念\n3.1.1　异常\n3.1.2　一致性\n3.1.3　衡量指标\n3.2　性能分析\n3.3　数据分布\n3.3.1　哈希分布\n3.3.2　顺序分布\n3.3.3　负载均衡\n3.4　复制\n3.4.1　复制的概述\n3.4.2　一致性与可用性\n3.5　容错\n3.5.1　常见故障\n3.5.2　故障检测\n3.5.3　故障恢复\n3.6　可扩展性\n3.6.1　总控节点\n3.6.2　数据库扩容\n3.6.3　异构系统\n3.7　分布式协议\n3.7.1　两阶段提交协议\n3.7.2　Paxos协议\n3.7.3　Paxos与2PC\n3.8　跨机房部署\n第二篇　范型篇\n第4章　分布式文件系统\n4.1　Google文件系统\n4.1.1　系统架构\n4.1.2　关键问题\n4.1.3　Master设计\n4.1.4　ChunkServer设计\n4.1.5　讨论\n4.2　Taobao File System\n4.2.1　系统架构\n4.2.2　讨论\n4.3　Facebook Haystack\n4.3.1　系统架构\n4.3.2　讨论\n4.4　内容分发网络\n4.4.1　CDN架构\n4.4.2　讨论\n第5章　分布式键值系统\n5.1　Amazon Dynamo\n5.1.1　数据分布\n5.1.2　一致性与复制\n5.1.3　容错\n5.1.4　负载均衡\n5.1.5　读写流程\n5.1.6　单机实现\n5.1.7　讨论\n5.2　淘宝Tair\n5.2.1　系统架构\n5.2.2　关键问题\n5.2.3　讨论\n第6章　分布式表格系统\n6.1　Google Bigtable\n6.1.1　架构\n6.1.2　数据分布\n6.1.3　复制与一致性\n6.1.4　容错\n6.1.5　负载均衡\n6.1.6　分裂与合并\n6.1.7　单机存储\n6.1.8　垃圾回收\n6.1.9　讨论\n6.2　Google Megastore\n6.2.1　系统架构\n6.2.2　实体组\n6.2.3　并发控制\n6.2.4　复制\n6.2.5　索引\n6.2.6　协调者\n6.2.7　读取流程\n6.2.8　写入流程\n6.2.9　讨论\n6.3　Windows Azure Storage\n6.3.1　整体架构\n6.3.2　文件流层\n6.3.3　分区层\n6.3.4　讨论\n第7章　分布式数据库\n7.1　数据库中间层\n7.1.1　架构\n7.1.2　扩容\n7.1.3　讨论\n7.2　Microsoft SQL Azure\n7.2.1　数据模型\n7.2.2　架构\n7.2.3　复制与一致性\n7.2.4　容错\n7.2.5　负载均衡\n7.2.6　多租户\n7.2.7　讨论\n7.3　Google Spanner\n7.3.1　数据模型\n7.3.2　架构\n7.3.3　复制与一致性\n7.3.4　TrueTime\n7.3.5　并发控制\n7.3.6　数据迁移\n7.3.7　讨论\n第三篇　实践篇\n第8章　OceanBase架构初探\n8.1　背景简介\n8.2　设计思路\n8.3　系统架构\n8.3.1　整体架构图\n8.3.2　客户端\n8.3.3　RootServer\n8.3.4　MergeServer\n8.3.5　ChunkServer\n8.3.6　UpdateServer\n8.3.7　定期合并&数据分发\n8.4　架构剖析\n8.4.1　一致性选择\n8.4.2　数据结构\n8.4.3　可靠性与可用性\n8.4.4　读写事务\n8.4.5　单点性能\n8.4.6　SSD支持\n8.4.7　数据正确性\n8.4.8　分层结构\n第9章　分布式存储引擎\n9.1　公共模块\n9.1.1　内存管理\n9.1.2　基础数据结构\n9.1.3　锁\n9.1.4　任务队列\n9.1.5　网络框架\n9.1.6　压缩与解压缩\n9.2　RootServer实现机制\n9.2.1　数据结构\n9.2.2　子表复制与负载均衡\n9.2.3　子表分裂与合并\n9.2.4　UpdateServer选主\n9.2.5　RootServer主备\n9.3　UpdateServer实现机制\n9.3.1　存储引擎\n9.3.2　任务模型\n9.3.3　主备同步\n9.4　ChunkServer实现机制\n9.4.1　子表管理\n9.4.2　SSTable\n9.4.3　缓存实现\n9.4.4　IO实现\n9.4.5　定期合并&数据分发\n9.4.6　定期合并限速\n9.5　消除更新瓶颈\n9.5.1　读写优化回顾\n9.5.2　数据旁路导入\n9.5.3　数据分区\n第10章　数据库功能\n10.1　整体结构\n10.2　只读事务\n10.2.1　物理操作符接口\n10.2.2　单表操作\n10.2.3　多表操作\n10.2.4　SQL执行本地化\n10.3　写事务\n10.3.1　写事务执行流程\n10.3.2　多版本并发控制\n10.4　OLAP业务支持\n10.4.1　并发查询\n10.4.2　列式存储\n10.5　特色功能\n10.5.1　大表左连接\n10.5.2　数据过期与批量删除\n第11章　质量保证、运维及实践\n11.1　质量保证\n11.1.1　RD开发\n11.1.2　QA测试\n11.1.3　试运行\n11.2　使用与运维\n11.2.1　使用\n11.2.2　运维\n11.3　应用\n11.3.1　收藏夹\n11.3.2　天猫评价\n11.3.3　直通车报表\n11.4　最佳实践\n11.4.1　系统发展路径\n11.4.2　人员成长\n11.4.3　系统设计\n11.4.4　系统实现\n11.4.5　使用与运维\n11.4.6　工程现象\n11.4.7　经验法则\n第四篇　专题篇\n第12章　云存储\n12.1　云存储的概念\n12.2　云存储的产品形态\n12.3　云存储技术\n12.4　云存储的核心优势\n12.5　云平台整体架构\n12.5.1　Amazon云平台\n12.5.2　Google云平台\n12.5.3　Microsoft云平台\n12.5.4　云平台架构\n12.6　云存储技术体系\n12.7　云存储安全\n第13章　大数据\n13.1　大数据的概念\n13.2　MapReduce\n13.3　MapReduce扩展\n13.3.1　Google Tenzing\n13.3.2　Microsoft Dryad\n13.3.3　Google Pregel\n13.4　流式计算\n13.4.1　原理\n13.4.2　Yahoo S4\n13.4.3　Twitter Storm\n13.5　实时分析\n13.5.1　MPP架构\n13.5.2　EMC Greenplum\n13.5.3　HP Vertica\n13.5.4　Google Dremel\n参考资料",
    "ebook_url": "https://read.douban.com/ebook/10179010/",
    "pages": "293",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27043456.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27043456.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27043456.jpg"
    },
    "alt": "https://book.douban.com/subject/25723658/",
    "id": "25723658",
    "publisher": "机械工业出版社",
    "isbn10": "7111430522",
    "isbn13": "9787111430520",
    "title": "大规模分布式存储系统",
    "url": "https://api.douban.com/v2/book/25723658",
    "alt_title": "",
    "author_intro": "杨传辉，阿里巴巴高级技术专家，花名日照，OceanBase核心开发人员，对分布式系统的理论和工程实践有深刻理解。曾在百度作为核心成员参与类MapReduce系统、类Bigtable系统和百度分布式消息队列等底层基础设施架构工作。热衷于分布式存储和计算系统设计，乐于分享，有技术博客NosqlNotes。",
    "summary": "《大规模分布式存储系统：原理解析与架构实战》是分布式系统领域的经典著作，由阿里巴巴高级技术专家“阿里日照”（OceanBase核心开发人员）撰写，阳振坤、章文嵩、杨卫华、汪源、余锋（褚霸）、赖春波等来自阿里、新浪、网易和百度的资深技术专家联袂推荐。理论方面，不仅讲解了大规模分布式存储系统的核心技术和基本原理，而且对谷歌、亚马逊、微软和阿里巴巴等国际型大互联网公司的大规模分布式存储系统进行了分析；实战方面，首先通过对阿里巴巴的分布式数据库OceanBase的实现细节的深入剖析完整地展示了大规模分布式存储系统的架构与设计过程，然后讲解了大规模分布式存储技术在云计算和大数据领域的实践与应用。\n《大规模分布式存储系统：原理解析与架构实战》内容分为四个部分：基础篇——分布式存储系统的基础知识，包含单机存储系统的知识，如数据模型、事务与并发控制、故障恢复、存储引擎、压缩/解压缩等；分布式系统的数据分布、复制、一致性、容错、可扩展性等。范型篇——介绍谷歌、亚马逊、微软、阿里巴巴等著名互联网公司的大规模分布式存储系统架构，涉及分布式文件系统、分布式键值系统、分布式表格系统以及分布式数据库技术等。实践篇——以阿里巴巴的分布式数据库OceanBase为例，详细介绍分布式数据库内部实现，以及实践过程中的经验。专题篇——介绍分布式系统的主要应用：云存储和大数据，这些是近年来的热门领域，本书介绍了云存储平台、技术与安全，以及大数据的概念、流式计算、实时分析等。",
    "ebook_price": "25.00",
    "series": { "id": "19432", "title": "大数据技术丛书" },
    "price": "59"
  },
  "9787115420268": {
    "rating": { "max": 10, "numRaters": 523, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["[英] Sam Newman"],
    "pubdate": "2016-5",
    "tags": [
      { "count": 510, "name": "微服务", "title": "微服务" },
      { "count": 343, "name": "架构", "title": "架构" },
      { "count": 238, "name": "软件架构", "title": "软件架构" },
      { "count": 153, "name": "计算机", "title": "计算机" },
      { "count": 111, "name": "软件工程", "title": "软件工程" },
      { "count": 85, "name": "编程", "title": "编程" },
      { "count": 77, "name": "模式与架构", "title": "模式与架构" },
      { "count": 77, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28626997.jpg",
    "binding": "平装",
    "translator": ["崔力强", "张　骏"],
    "catalog": "前言　　xiv\n第1章　微服务　　1\n1.1　什么是微服务　　2\n1.1.1　很小，专注于做好一件事　　2\n1.1.2　自治性　　3\n1.2　主要好处　　3\n1.2.1　技术异构性　　3\n1.2.2　弹性　　4\n1.2.3　扩展　　5\n1.2.4　简化部署　　5\n1.2.5　与组织结构相匹配　　6\n1.2.6　可组合性　　6\n1.2.7　对可替代性的优化　　6\n1.3　面向服务的架构　　7\n1.4　其他分解技术　　7\n1.4.1　共享库　　8\n1.4.2　模块　　8\n1.5　没有银弹　　9\n1.6　小结　　10\n第2章　演化式架构师　　11\n2.1　不准确的比较　　11\n2.2　架构师的演化视角　　12\n2.3　分区　　14\n2.4　一个原则性的方法　　15\n2.4.1　战略目标　　15\n2.4.2　原则　　15\n2.4.3　实践　　16\n2.4.4　将原则和实践相结合　　16\n2.4.5　真实世界的例子　　16\n2.5　要求的标准　　17\n2.5.1　监控　　18\n2.5.2　接口　　18\n2.5.3　架构安全性　　18\n2.6　代码治理　　18\n2.6.1　范例　　19\n2.6.2　裁剪服务代码模板　　19\n2.7　技术债务　　20\n2.8　例外管理　　21\n2.9　集中治理和领导　　21\n2.10　建设团队　　22\n2.11　小结　　23\n第3章　如何建模服务　　24\n3.1　MusicCorp简介　　24\n3.2　什么样的服务是好服务　　25\n3.2.1　松耦合　　25\n3.2.2　高内聚　　25\n3.3　限界上下文　　26\n3.3.1　共享的隐藏模型　　26\n3.3.2　模块和服务　　27\n3.3.3　过早划分　　28\n3.4　业务功能　　28\n3.5　逐步划分上下文　　29\n3.6　关于业务概念的沟通　　30\n3.7　技术边界　　30\n3.8　小结　　31\n第4章　集成　　32\n4.1　寻找理想的集成技术　　32\n4.1.1　避免破坏性修改　　32\n4.1.2　保证API的技术无关性　　32\n4.1.3　使你的服务易于消费方使用　　33\n4.1.4　隐藏内部实现细节　　33\n4.2　为用户创建接口　　33\n4.3　共享数据库　　33\n4.4　同步与异步　　35\n4.5　编排与协同　　35\n4.6　远程过程调用　　38\n4.6.1　技术的耦合　　38\n4.6.2　本地调用和远程调用并不相同　　39\n4.6.3　脆弱性　　39\n4.6.4　RPC很糟糕吗　　40\n4.7　REST　　41\n4.7.1　REST和HTTP　　41\n4.7.2　超媒体作为程序状态的引擎　　42\n4.7.3　JSON、XML还是其他　　44\n4.7.4　留心过多的约定　　44\n4.7.5　基于HTTP的REST的缺点　　45\n4.8　实现基于事件的异步协作方式　　46\n4.8.1　技术选择　　46\n4.8.2　异步架构的复杂性　　47\n4.9　服务即状态机　　48\n4.10　响应式扩展　　48\n4.11　微服务世界中的DRY和代码重用的危险　　49\n4.12　按引用访问　　50\n4.13　版本管理　　51\n4.13.1　尽可能推迟　　51\n4.13.2　及早发现破坏性修改　　52\n4.13.3　使用语义化的版本管理　　53\n4.13.4　不同的接口共存　　53\n4.13.5　同时使用多个版本的服务　　54\n4.14　用户界面　　55\n4.14.1　走向数字化　　56\n4.14.2　约束　　56\n4.14.3　API组合　　57\n4.14.4　UI片段的组合　　57\n4.14.5　为前端服务的后端　　59\n4.14.6　一种混合方式　　60\n4.15　与第三方软件集成　　61\n4.15.1　缺乏控制　　61\n4.15.2　定制化　　62\n4.15.3　意大利面式的集成　　62\n4.15.4　在自己可控的平台进行定制化　　62\n4.15.5　绞杀者模式　　64\n4.16　小结　　65\n第5章　分解单块系统　　66\n5.1　关键是接缝　　66\n5.2　分解MusicCorp　　67\n5.3　分解单块系统的原因　　68\n5.3.1　改变的速度　　68\n5.3.2　团队结构　　68\n5.3.3　安全　　68\n5.3.4　技术　　68\n5.4　杂乱的依赖　　69\n5.5　数据库　　69\n5.6　找到问题的关键　　69\n5.7　例子：打破外键关系　　70\n5.8　例子：共享静态数据　　71\n5.9　例子：共享数据　　72\n5.10　例子：共享表　　73\n5.11　重构数据库　　74\n5.12　事务边界　　75\n5.12.1　再试一次　　76\n5.12.2　终止整个操作　　77\n5.12.3　分布式事务　　77\n5.12.4　应该怎么办呢　　78\n5.13　报告　　78\n5.14　报告数据库　　78\n5.15　通过服务调用来获取数据　　80\n5.16　数据导出　　81\n5.17　事件数据导出　　82\n5.18　数据导出的备份　　83\n5.19　走向实时　　84\n5.20　修改的代价　　84\n5.21　理解根本原因　　84\n5.22　小结　　85\n第6章　部署　　86\n6.1　持续集成简介　　86\n6.2　把持续集成映射到微服务　　87\n6.3　构建流水线和持续交付　　90\n6.4　平台特定的构建物　　91\n6.5　操作系统构建物　　92\n6.6　定制化镜像　　93\n6.6.1　将镜像作为构建物　　94\n6.6.2　不可变服务器　　95\n6.7　环境　　95\n6.8　服务配置　　96\n6.9　服务与主机之间的映射　　97\n6.9.1　单主机多服务　　97\n6.9.2　应用程序容器　　99\n6.9.3　每个主机一个服务　　100\n6.9.4　平台即服务　　101\n6.10　自动化　　101\n6.11　从物理机到虚拟机　　102\n6.11.1　传统的虚拟化技术　　103\n6.11.2　Vagrant　　104\n6.11.3　Linux容器　　104\n6.11.4　Docker　　106\n6.12　一个部署接口　　107\n6.13　小结　　109\n第7章　测试　　110\n7.1　测试类型　　110\n7.2　测试范围　　111\n7.2.1　单元测试　　112\n7.2.2　服务测试　　113\n7.2.3　端到端测试　　114\n7.2.4　权衡　　114\n7.2.5　比例　　115\n7.3　实现服务测试　　115\n7.3.1　mock还是打桩　　115\n7.3.2　智能的打桩服务　　116\n7.4　微妙的端到端测试　　117\n7.5　端到端测试的缺点　　118\n7.6　脆弱的测试　　118\n7.6.1　谁来写这些测试　　119\n7.6.2　测试多长时间　　119\n7.6.3　大量的堆积　　120\n7.6.4　元版本　　120\n7.7　测试场景，而不是故事　　121\n7.8　拯救消费者驱动的测试　　121\n7.8.1　Pact　　123\n7.8.2　关于沟通　　124\n7.9　还应该使用端到端测试吗　　124\n7.10　部署后再测试　　125\n7.10.1　区分部署和上线　　125\n7.10.2　金丝雀发布　　126\n7.10.3　平均修复时间胜过平均故障间隔时间　　127\n7.11　跨功能的测试　　128\n7.12　小结　　129\n第8章　监控　　131\n8.1　单一服务，单一服务器　　132\n8.2　单一服务，多个服务器　　132\n8.3　多个服务，多个服务器　　133\n8.4　日志，日志，更多的日志　　134\n8.5　多个服务的指标跟踪　　135\n8.6　服务指标　　135\n8.7　综合监控　　136\n8.8　关联标识　　137\n8.9　级联　　139\n8.10　标准化　　139\n8.11　考虑受众　　140\n8.12　未来　　140\n8.13　小结　　141\n第9章　安全　　143\n9.1　身份验证和授权　　143\n9.1.1　常见的单点登录实现　　144\n9.1.2　单点登录网关　　145\n9.1.3　细粒度的授权　　146\n9.2　服务间的身份验证和授权　　146\n9.2.1　在边界内允许一切　　146\n9.2.2　HTTP(S) 基本身份验证　　147\n9.2.3　使用SAML或OpenID Connect　　148\n9.2.4　客户端证书　　148\n9.2.5　HTTP之上的HMAC　　149\n9.2.6　API密钥　　149\n9.2.7　代理问题　　150\n9.3　静态数据的安全　　152\n9.3.1　使用众所周知的加密算法　　152\n9.3.2　一切皆与密钥相关　　153\n9.3.3　选择你的目标　　153\n9.3.4　按需解密　　153\n9.3.5　加密备份　　153\n9.4　深度防御　　154\n9.4.1　防火墙　　154\n9.4.2　日志　　154\n9.4.3　入侵检测（和预防）系统　　154\n9.4.4　网络隔离　　155\n9.4.5　操作系统　　155\n9.5　一个示例　　156\n9.6　保持节俭　　158\n9.7　人的因素　　158\n9.8　黄金法则　　158\n9.9　内建安全　　159\n9.10　外部验证　　159\n9.11　小结　　159\n第10章　康威定律和系统设计　　161\n10.1　证据　　161\n10.1.1　松耦合组织和紧耦合组织　　162\n10.1.2　Windows Vista　　162\n10.2　Netflix和Amazon　　162\n10.3　我们可以做什么　　163\n10.4　适应沟通途径　　163\n10.5　服务所有权　　164\n10.6　共享服务的原因　　164\n10.6.1　难以分割　　164\n10.6.2　特性团队　　164\n10.6.3　交付瓶颈　　165\n10.7　内部开源　　166\n10.7.1　守护者的角色　　166\n10.7.2　成熟　　166\n10.7.3　工具　　167\n10.8　限界上下文和团队结构　　167\n10.9　孤儿服务　　167\n10.10　案例研究：RealEstate.com.au　　168\n10.11　反向的康威定律　　169\n10.12　人　　170\n10.13　小结　　170\n第11章　规模化微服务　　171\n11.1　故障无处不在　　171\n11.2　多少是太多　　172\n11.3　功能降级　　173\n11.4　架构性安全措施　　174\n11.5　反脆弱的组织　　175\n11.5.1　超时　　176\n11.5.2　断路器　　176\n11.5.3　舱壁　　178\n11.5.4　隔离　　179\n11.6　幂等　　179\n11.7　扩展　　180\n11.7.1　更强大的主机　　181\n11.7.2　拆分负载　　181\n11.7.3　分散风险　　181\n11.7.4　负载均衡　　182\n11.7.5　基于worker的系统　　184\n11.7.6　重新设计　　184\n11.8　扩展数据库　　185\n11.8.1　服务的可用性和数据的持久性　　185\n11.8.2　扩展读取　　185\n11.8.3　扩展写操作　　186\n11.8.4　共享数据库基础设施　　187\n11.8.5　CQRS　　187\n11.9　缓存　　188\n11.9.1　客户端、 代理和服务器端缓存　　188\n11.9.2　HTTP缓存　　189\n11.9.3　为写使用缓存　　190\n11.9.4　为弹性使用缓存　　190\n11.9.5　隐藏源服务　　191\n11.9.6　保持简单　　191\n11.9.7　缓存中毒：一个警示　　192\n11.10　自动伸缩　　192\n11.11　CAP定理　　193\n11.11.1　牺牲一致性　　194\n11.11.2　牺牲可用性　　195\n11.11.3　牺牲分区容忍性　　195\n11.11.4　AP还是CP　　196\n11.11.5　这不是全部或全不　　196\n11.11.6　真实世界　　197\n11.12　服务发现　　197\n11.13　动态服务注册　　199\n11.13.1　Zookeeper　　199\n11.13.2　Consul　　200\n11.13.4　构造你自己的系统　　201\n11.13.5　别忘了人　　201\n11.14　文档服务　　201\n11.14.1　Swagger　　202\n11.14.2　HAL 和HAL浏览器　　202\n11.15　自描述系统　　203\n11.16　小结　　203\n第12章　总结　　204\n12.1　微服务的原则　　204\n12.1.1　围绕业务概念建模　　205\n12.1.2　接受自动化文化　　205\n12.1.3　隐藏内部实现细节　　205\n12.1.4　让一切都去中心化　　206\n12.1.5　可独立部署　　206\n12.1.6　隔离失败　　206\n12.1.7　高度可观察　　207\n12.2　什么时候你不应该使用微服务　　207\n12.3　临别赠言　　208\n关于作者　　209\n关于封面　　209",
    "ebook_url": "https://read.douban.com/ebook/52188224/",
    "pages": "228",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28626997.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28626997.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28626997.jpg"
    },
    "alt": "https://book.douban.com/subject/26772677/",
    "id": "26772677",
    "publisher": "人民邮电出版社",
    "isbn10": "7115420262",
    "isbn13": "9787115420268",
    "title": "微服务设计",
    "url": "https://api.douban.com/v2/book/26772677",
    "alt_title": "",
    "author_intro": "作者简介：\nSam Newman\n是ThoughtWorks公司的技术专家、ThoughtWorks内部系统架构师，同时还为全球的客户提供咨询服务。他在开发和IT运维方面与全球多个领域的公司有过合作。\n译者简介：\n崔力强\n阿里巴巴技术专家，目前专注于持续交付相关的产品开发。曾在ThoughtWorks任职多年，从事软件定制开发、敏捷软件开发的相关咨询等工作，帮助过数个团队和项目进行精益需求管理、软件设计、自动化测试和持续集成等实践。微信号：blade_1986\n张骏\n2010年加入ThoughtWorks公司。作为开发人员、项目经理、资深敏捷教练和资深咨询师，在金融、电信和能源服务行业的大型复杂业务系统的设计、开发、管理、咨询等方面有丰富的经验。曾为国内外诸多客户提供软件设计、开发以及咨询服务。拥有10年工作经验，在Scrum、看板、规模化敏捷等方法论，以及精益需求管理、自动化测试、持续集成、领域驱动设计、微服务等具体实践方面都有丰富的积累。微信号：zhangjun695339",
    "summary": "本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。主要内容包括认识微服务在保证系统设计与组织目标统一上的重要性，学会把服务集成到已有系统中，采用递增手段拆分单块大型应用，通过持续集成部署微服务，等等。",
    "ebook_price": "29.99",
    "price": "69.00元"
  },
  "9787111526285": {
    "rating": { "max": 10, "numRaters": 61, "average": "9.3", "min": 0 },
    "subtitle": "",
    "author": [
      "艾伦A.A.多诺万 (Alan A.A.Donovan)",
      "布莱恩W.柯尼汉 (Brian W.Kemighan)"
    ],
    "pubdate": "2016-1-1",
    "tags": [
      { "count": 50, "name": "Go", "title": "Go" },
      { "count": 39, "name": "golang", "title": "golang" },
      { "count": 26, "name": "编程", "title": "编程" },
      { "count": 20, "name": "计算机", "title": "计算机" },
      { "count": 20, "name": "编程语言", "title": "编程语言" },
      { "count": 13, "name": "软件开发", "title": "软件开发" },
      { "count": 7, "name": "程序设计", "title": "程序设计" },
      { "count": 7, "name": "Programming", "title": "Programming" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29140891.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "",
    "pages": "366",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29140891.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29140891.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29140891.jpg"
    },
    "alt": "https://book.douban.com/subject/26859123/",
    "id": "26859123",
    "publisher": "机械工业出版社",
    "isbn10": "7111526287",
    "isbn13": "9787111526285",
    "title": "Go程序设计语言(英文版)",
    "url": "https://api.douban.com/v2/book/26859123",
    "alt_title": "",
    "author_intro": "",
    "summary": "",
    "price": "CNY 79.00"
  },
  "9787115445353": {
    "rating": { "max": 10, "numRaters": 184, "average": "7.7", "min": 0 },
    "subtitle": "",
    "author": [
      "威廉·肯尼迪 (William Kennedy)",
      "布赖恩·克特森 (Brian Ketelsen)",
      "埃里克·圣马丁 (Erik St.Martin)"
    ],
    "pubdate": "2017-3-1",
    "tags": [
      { "count": 99, "name": "Go", "title": "Go" },
      { "count": 87, "name": "Golang", "title": "Golang" },
      { "count": 54, "name": "编程", "title": "编程" },
      { "count": 41, "name": "编程语言", "title": "编程语言" },
      { "count": 33, "name": "计算机", "title": "计算机" },
      { "count": 24, "name": "计算机科学", "title": "计算机科学" },
      { "count": 23, "name": "Programming", "title": "Programming" },
      { "count": 17, "name": "开发", "title": "开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29421285.jpg",
    "binding": "平装",
    "translator": ["李兆海"],
    "catalog": "第1章　关于Go语言的介绍　1\n1．1　用Go解决现代编程难题　2\n1．1．1　开发速度　2\n1．1．2　并发　3\n1．1．3　Go语言的类型系统　5\n1．1．4　内存管理　7\n1．2　你好，Go　7\n1．3　小结　8\n第2章　快速开始一个Go程序　9\n2．1　程序架构　9\n2．2　main包　11\n2．3　search包　13\n2．3．1　search．go　13\n2．3．2　feed．go　21\n2．3．3　match．go default．go　24\n2．4　RSS匹配器　30\n2．5　小结　36\n第3章　打包和工具链　37\n3．1　包　37\n3．1．1　包名惯例　38\n3．1．2　main包　38\n3．2　导入　39\n3．2．1　远程导入　40\n3．2．2　命名导入　40\n3．3　函数init　41\n3．4　使用Go的工具　42\n3．5　进一步介绍Go开发工具　44\n3．5．1　go vet　44\n3．5．2　Go代码格式化　45\n3．5．3　Go语言的文档　45\n3．6　与其他Go开发者合作　48\n3．7　依赖管理　48\n3．7．1　第三方依赖　49\n3．7．2　对gb的介绍　50\n3．8　小结　52\n第4章　数组、切片和映射　53\n4．1　数组的内部实现和基础功能　53\n4．1．1　内部实现　53\n4．1．2　声明和初始化　54\n4．1．3　使用数组　55\n4．1．4　多维数组　58\n4．1．5　在函数间传递数组　59\n4．2　切片的内部实现和基础功能　60\n4．2．1　内部实现　60\n4．2．2　创建和初始化　61\n4．2．3　使用切片　63\n4．2．4　多维切片　74\n4．2．5　在函数间传递切片　75\n4．3　映射的内部实现和基础功能　76\n4．3．1　内部实现　76\n4．3．2　创建和初始化　78\n4．3．3　使用映射　79\n4．3．4　在函数间传递映射　81\n4．4　小结　82\n第5章　Go语言的类型系统　83\n5．1　用户定义的类型　83\n5．2　方法　87\n5．3　类型的本质　90\n5．3．1　内置类型　91\n5．3．2　引用类型　91\n5．3．3　结构类型　93\n5．4　接口　95\n5．4．1　标准库　96\n5．4．2　实现　98\n5．4．3　方法集　99\n5．4．4　多态　103\n5．5　嵌入类型　105\n5．6　公开或未公开的标识符　113\n5．7　小结　121\n第6章　并发　122\n6．1　并发与并行　122\n6．2　goroutine　125\n6．3　竞争状态　132\n6．4　锁住共享资源　135\n6．4．1　原子函数　135\n6．4．2　互斥锁　138\n6．5　通道　140\n6．5．1　无缓冲的通道　141\n6．5．2　有缓冲的通道　146\n6．6　小结　149\n第7章　并发模式　150\n7．1　runner　150\n7．2　pool　158\n7．3　work　168\n7．4　小结　174\n第8章　标准库　176\n8．1　文档与源代码　177\n8．2　记录日志　178\n8．2．1　log包　179\n8．2．2　定制的日志记录器　182\n8．2．3　结论　186\n8．3　编码 解码　187\n8．3．1　解码JSON　187\n8．3．2　编码JSON　192\n8．3．3　结论　193\n8．4　输入和输出　193\n8．4．1　Writer和Reader接口　194\n8．4．2　整合并完成工作　195\n8．4．3　简单的curl　199\n8．4．4　结论　200\n8．5　小结　200\n第9章　测试和性能　201\n9．1　单元测试　201\n9．1．1　基础单元测试　202\n9．1．2　表组测试　205\n9．1．3　模仿调用　208\n9．1．4　测试服务端点　212\n9．2　示例　217\n9．3　基准测试　220\n9．4　小结　224",
    "pages": "224",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29421285.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29421285.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29421285.jpg"
    },
    "alt": "https://book.douban.com/subject/27015617/",
    "id": "27015617",
    "publisher": "人民邮电出版社",
    "isbn10": "7115445354",
    "isbn13": "9787115445353",
    "title": "Go语言实战",
    "url": "https://api.douban.com/v2/book/27015617",
    "alt_title": "",
    "author_intro": "William Kennedy，是一位熟练的软件开发者，也是博客GoingGo.Net的作者。\nBrian Ketelsen和Erik St. Martin是全球Go语言大会GopherCon的组织者，也是Go语言框架Skynet的联合作者。\n李兆海，多年专注于后端分布式网络服务开发，曾使用过多个流行后端技术和相关架构实践，是Go语言和Docker的早期使用者和推广者，《第1本Docker书》的译者。作为项目技术负责人，成功开发了百万用户级直播系统。",
    "summary": "Go语言结合了底层系统语言的能力以及现代语言的高级特性，旨在降低构建简单、可靠、高效软件的门槛。本书向读者提供一个专注、全面且符合语言习惯的视角。Go语言实战同时关注语言的规范和实现，涉及的内容包括语法、类型系统、并发、管道、测试，以及其他一些主题。",
    "price": "CNY 59.00"
  },
  "9787115290366": {
    "rating": { "max": 10, "numRaters": 511, "average": "7.1", "min": 0 },
    "subtitle": "",
    "author": ["许式伟"],
    "pubdate": "2012-8",
    "tags": [
      { "count": 311, "name": "go语言", "title": "go语言" },
      { "count": 280, "name": "Go", "title": "Go" },
      { "count": 175, "name": "编程", "title": "编程" },
      { "count": 110, "name": "编程语言", "title": "编程语言" },
      { "count": 109, "name": "程序设计", "title": "程序设计" },
      { "count": 101, "name": "golang", "title": "golang" },
      { "count": 98, "name": "计算机", "title": "计算机" },
      { "count": 75, "name": "programming", "title": "programming" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s11162016.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "序 为什么我们需要一门新的语言？\n第1章 初识Go语言\n1.1 Go语言简史\n1.2 语言特性\n1.3 “Hello, world!”\n1.4 编译环境\n1.5 开发工具\n1.6 工程管理\n1.7 问题追踪和调试\n1.8 如何寻求帮助\n本章小结\n第2章 顺序编程\n2.1 变量、常量和类型\n2.1.1 变量\n2.1.2 常量\n2.1.3 类型\n2.2 流程控制\n2.2.1 条件语句\n2.2.2 选择语句\n2.2.3 循环\n2.2.4 跳转语句\n2.3 函数\n2.3.1 函数调用\n2.3.2 不定参数\n2.3.3 多返回值\n2.3.4 匿名函数与闭包\n2.4 错误处理\n2.4.1 error接口\n2.4.2 defer\n2.4.3 panic和recover\n本章小结\n第3章 面向对象编程\n3.1 类型系统\n3.1.1 给类型添加方法\n3.1.2 值语义和引用语义\n3.2 结构体\n3.2.1 初始化\n3.2.2 匿名组合\n3.2.3 成员可访问性\n3.3 接口\n3.3.1 其他语言中的接口\n3.3.2 非侵入式接口\n3.3.3 接口赋值\n3.3.4 接口查询\n3.3.5 类型查询\n3.3.6 Any类型\n本章小结\n第4章 工程管理\n4.1 Go命令行工具\n4.2 代码风格\n4.3 工程组织\n4.4 单元测试\n4.5 文档管理\n4.6 工程构建\n4.7 包的管理与分发\n4.8 跨平台开发\n4.8.1 Go语言的跨平台能力\n4.8.2 交叉编译\n4.8.3 Android支持\n本章小结\n第5章 并发编程\n5.1 初识Goroutine\n5.1.1 基本用法\n5.1.2 Goroutine通信\n5.2 Channel\n5.2.1 基本用法\n5.2.2 关闭\n5.2.3 变量的传递\n5.2.4 单向Channel\n5.2.5 超时处理\n5.3 多核并行化\n5.4 同步机制\n5.4.1 sync包简介\n5.4.2 同步锁\n5.4.3 Once类型\n本章小结\n第6章 网络编程\n6.1 HTTP编程\n6.1.1 客户端编程\n6.1.2 开发HTTP服务器\n6.2 JSON\n6.2.1 JSON简介\n6.2.2 编码\n6.2.3 解码\n6.2.4 未知类型的解码\n6.2.5 流式读写\n6.3 网站开发\n6.3.1 一个最简单的网站\n6.3.2 开发一个相册网站\n6.3.2.1 新建工程\n6.3.2.2 实现网络服务\n6.3.2.3 网页模板渲染\n6.3.2.4 缓存\n6.3.2.5 错误处理\n6.3.2.6 防止程序崩溃\n6.3.2.7 资源分离\n6.3.2.8 重构\n6.4 更多资源\n本章小结\n第7章 进阶话题\n7.1 Go语言中的内存管理\n7.2 反射\n7.3 语言交互性CGO\n7.4 链接符号\n7.5 Goroutine实现机制\n7.6 接口的奥秘\n本章小结\n第8章 开发工具\n8.1 Go语言开发工具\n8.2 gEdit\n8.3 Goclipse - 使用Eclipse开发和调试Go程序\n8.4 VIM\n8.5 Nodepad++，Windows上的Go开发环境搭建\n8.6 GolangIDE\n本章小结\n附录 Go语言包参考",
    "pages": "300",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s11162016.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s11162016.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s11162016.jpg"
    },
    "alt": "https://book.douban.com/subject/11577300/",
    "id": "11577300",
    "publisher": "人民邮电出版社",
    "isbn10": "7115290369",
    "isbn13": "9787115290366",
    "title": "Go语言编程",
    "url": "https://api.douban.com/v2/book/11577300",
    "alt_title": "",
    "author_intro": "许式伟\n七牛云存储CEO，曾任盛大创新院资深研究员、金山软件技术总监、WPS Office 2005首席架构师。开源爱好者，发布过包括WINX、TPL等十余个C++开源项目，拥有超过15年的C/C++开发经验。在接触Go语言后即可被其大道至简、少即是多的设计哲学所倾倒。七牛云存储是国内第一个吃螃蟹的团队，核心服务完全采用Go语言实现。\n吕桂华\n七牛云存储联合创始人，曾在金山软件、盛大游戏等公司担任架构师和部门经理等职务，在企业级系统和大型网游平台领域有较多涉猎。拥有十余年的C/C++大型项目开发经验，也曾在Java和.NET平台上探索多年。同样被Go语言的魅力所吸引而不可自拔，希望能为推广这门优秀的语言尽自己的绵薄之力。",
    "summary": "这本书从整体的写作风格来说，会以介绍 Go 语言特性为主，示例则尽量采用作者平常的实践，而不是一个没有太大实际意义的语法示范样例。\n本书作者背景极强，许式伟为原金山WPS首席架构师、曾是盛大创新院研究员，目前是国内Go语言实践圈子公认的Go语言专家。参与本书写作的几位作者都是实际用Go语言开发的项目的开发人员，有较强的实战经验。\n本书以介绍Go语言特性为主，示例则尽量采用作者开发团队平常的实践，内容涉及内存管理（堆和栈）、错误处理、OOP、并发编程等关键话题。 这本书面向的读者是所有打算用Go语言的开发者，主要包括目前使用C、C++、Java、C#的开发人员，甚至一些Python、PHP开发人员也可能转为 Go 程序员。",
    "series": { "id": "13000", "title": "图灵原创" },
    "price": "49.00元"
  },
  "9787121328428": {
    "rating": { "max": 10, "numRaters": 30, "average": "9.4", "min": 0 },
    "subtitle": "",
    "author": [
      "【德】Martin Odersky（马丁.奥德斯基）",
      "【美】Lex Spoon（莱·斯彭）",
      "【美】Bill Venners（比尔·凡纳斯）"
    ],
    "pubdate": "2018-1-1",
    "tags": [
      { "count": 31, "name": "Scala", "title": "Scala" },
      { "count": 13, "name": "计算机", "title": "计算机" },
      { "count": 12, "name": "编程", "title": "编程" },
      { "count": 8, "name": "程序设计", "title": "程序设计" },
      { "count": 6, "name": "FP", "title": "FP" },
      { "count": 2, "name": "思维", "title": "思维" },
      { "count": 1, "name": "软件设计", "title": "软件设计" },
      { "count": 1, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29620622.jpg",
    "binding": "平装",
    "translator": ["高宇翔"],
    "catalog": "序.XXIV\n致谢.XXVI\n引言.XXIX\n第1章　一门可伸缩的语言.1\n1.1　一门按需伸缩的语言 2\n1.2　是什么让Scala能屈能伸？ 7\n1.3　为什么要用Scala？.11\n1.4　Scala寻根 17\n1.5　结语 19\n第2章　Scala入门 20\n第1步　使用Scala解释器 21\n第2步　定义变量 22\n第3步　定义函数 24\n第4步　编写Scala脚本 26\n第5步　用while做循环；用if做判断 27\n第6步　用foreach和for遍历 30\n结语 32\n第3章　Scala入门（续）.33\n第7步　用类型参数化数组 33\n第8步　使用列表 38\n第9步　使用元组 42\n第10步使用集和映射 43\n第11步　识别函数式编程风格 48\n第12步　从文件读取文本行 51\n结语 55\n第4章　类和对象.56\n4.1　类、字段和方法 56\n4.2　分号推断 61\n4.3　单例对象 62\n4.4　Scala应用程序 65\n4.5　App特质 68\n4.6　结语 68\n第5章　基础类型和操作69\n5.1　一些基础类型 69\n5.2　字面量 70\n5.3　字符串插值 77\n5.4　操作符即方法 78\n5.5　算术操作 81\n5.6　关系和逻辑操作 83\n5.7　位运算操作 85\n5.8　对象相等性 86\n5.9　操作符优先级和结合性 88\n5.10　富包装类 91\n5.11　结语 91\n第6章　函数式对象.93\n6.1　Rational类的规格定义 93\n6.2　构建Rational 94\n6.3　重新实现toString方法 96\n6.4　检查前置条件 97\n6.5　添加字段 98\n6.6　自引用.100\n6.7　辅助构造方法.101\n6.8　私有字段和方法.102\n6.9　定义操作符 104\n6.10　Scala中的标识符.106\n6.11　方法重载.108\n6.12　隐式转换.111\n6.13　注意事项.112\n6.14　结语 112\n第7章　内建的控制结构 114\n7.1　if表达式.115\n7.2　while循环 116\n7.3　for表达式 119\n7.4　用try表达式实现异常处理125\n7.5　match表达式129\n7.6　没有break和continue的日子.131\n7.7　变量作用域 134\n7.8　对指令式代码进行重构.137\n7.9　结语.139\n第8章　函数和闭包 140\n8.1　方法.140\n8.2　局部函数142\n8.3　一等函数144\n8.4　函数字面量的简写形式.147\n8.5　占位符语法 147\n8.6　部分应用的函数.149\n8.7　闭包.152\n8.8　特殊的函数调用形式 156\n8.9　尾递归.159\n8.10　结语 163\n第9章　控制抽象 164\n9.1　减少代码重复.164\n9.2　简化调用方代码.169\n9.3　柯里化.170\n9.4　编写新的控制结构173\n9.5　传名参数176\n9.6　结语.178\n第10章　组合和继承179\n10.1　一个二维的布局类库179\n10.2　抽象类 180\n10.3　定义无参方法 182\n10.4　扩展类 184\n10.5　重写方法和字段 186\n10.6　定义参数化字段 188\n10.7　调用超类构造方法.189\n10.8　使用override修饰符 190\n10.9　多态和动态绑定 192\n10.10　声明final成员.195\n10.11　使用组合和继承196\n10.12　实现above、beside和toString.198\n10.13　定义工厂对象.201\n10.14　增高和增宽.204\n10.15　放在一起 206\n10.16　结语207\n第11章　Scala的继承关系208\n11.1　Scala的类继承关系208\n11.2　基本类型的实现机制212\n11.3　底类型（bottom types）.215\n11.4　定义自己的值类型.216\n11.5　结语219\n第12章　特质.220\n12.1　特质如何工作 220\n12.2　瘦接口和富接口 224\n12.3　示例：矩形对象 225\n12.4　Ordered特质 227\n12.5　作为可叠加修改的特质229\n12.6　为什么不用多重继承？234\n12.7　要特质还是不要特质？238\n12.8　结语 238\n第13章　包和引入240\n13.1　将代码放进包里 240\n13.2　对相关代码的精简访问242\n13.3　引入 246\n13.4　隐式引入.249\n13.5　访问修饰符250\n13.6　包对象 256\n13.7　结语 257\n第14章　断言和测试258\n14.1　断言 258\n14.2　用Scala写测试 260\n14.3　翔实的失败报告 262\n14.4　作为规格说明的测试263\n14.5　基于性质的测试 267\n14.6　组织和运行测试 268\n14.7　结语 270\n第15章　样例类和模式匹配.271\n15.1　一个简单的例子 271\n15.2　模式的种类276\n15.3　模式守卫.286\n15.4　模式重叠.287\n15.5　密封类 289\n15.6　Option类型.291\n15.7　到处都是模式 293\n15.8　一个复杂的例子 298\n15.9　结语 306\n第16章　使用列表307\n16.1　List字面量 307\n16.2　List类型 308\n16.3　构建列表.309\n16.4　列表的基本操作 309\n16.5　列表模式.310\n16.6　List类的初阶方法 312\n16.7　List类的高阶方法 324\n16.8　List对象的方法333\n16.9　同时处理多个列表.335\n16.10　理解Scala的类型推断算法 336\n16.11　结语.339\n第17章　使用其他集合类 340\n17.1　序列 340\n17.2　集和映射.344\n17.3　在可变和不可变集合类之间选择352\n17.4　初始化集合355\n17.5　元组 358\n17.6　结语 361\n第18章　可变对象362\n18.1　什么样的对象是可变的？ 362\n18.2　可被重新赋值的变量和属性.365\n18.3　案例分析：离散事件模拟 368\n18.4　用于描述数字电路的语言 369\n18.5　Simulation API.372\n18.6　电路模拟.376\n18.7　结语 384\n第19章　类型参数化385\n19.1　函数式队列385\n19.2　信息隐藏.389\n19.3　型变注解.392\n19.4　检查型变注解 397\n19.5　下界 400\n19.6　逆变 402\n19.7　对象私有数据 405\n19.8　上界 407\n19.9　结语 410\n第20章　抽象成员 411\n20.1　抽象成员概览 411\n20.2　类型成员.412\n20.3　抽象的val413\n20.4　抽象的var414\n20.5　初始化抽象的val.415\n20.6　抽象类型.423\n20.7　路径依赖类型 425\n20.8　改良类型.428\n20.9　枚举 429\n20.10　案例分析：货币431\n20.11 结语.441\n第21章　隐式转换和隐式参数.442\n21.1　隐式转换.442\n21.2　隐式规则.445\n21.3　隐式转换到一个预期的类型.448\n21.4　转换接收端450\n21.5　隐式参数.454\n21.6　上下文界定460\n21.7　当有多个转换可选时463\n21.8　调试 465\n21.9　结语 467\n第22章　实现列表468\n22.1　List类的原理.468\n22.2　ListBuffer类 475\n22.3　List类的实践.476\n22.4　外部可见的函数式.479\n22.5　结语 480\n第23章　重访for表达式 481\n23.1　for表达式483\n23.2　N皇后问题.484\n23.3　用for推导式进行查询 487\n23.4　用for推导式进行翻译 489\n23.5　反过来 494\n23.6　泛化for表达式 495\n23.7　结语 497\n第24章　深入集合类498\n24.1　可变和不可变集合.499\n24.2　集合的一致性 501\n24.3　Traversable特质 503\n24.4　Iterable特质508\n24.5　序列型特质Seq、IndexedSeq和LinearSeq.512\n24.6　集517\n24.7　映射 521\n24.8　具体的不可变集合类525\n24.9　具体的可变集合类.532\n24.10　数组539\n24.11　字符串544\n24.12　性能特征 545\n24.13　相等性547\n24.14　视图548\n24.15　迭代器554\n24.16　从头创建集合.561\n24.17　Java和Scala集合互转.563\n24.18　结语564\n第25章　Scala集合架构565\n25.1　集合构建器565\n25.2　抽取公共操作 567\n25.3　集成新的集合 572\n25.4　结语 588\n第26章　提取器589\n26.1　示例：提取电子邮箱地址 589\n26.2　提取器 591\n26.3　提取0或1个变量的模式 594\n26.4　提取可变长度参数的模式 596\n26.5　提取器和序列模式.598\n26.6　提取器和样例类的对比599\n26.7　正则表达式601\n26.8　结语 604\n第27章　注解.606\n27.1　为什么要有注解？.606\n27.2　注解的语法607\n27.3　标准注解.609\n27.4　结语 613\n第28章　使用XML614\n28.1　半结构化数据 614\n28.2　XML概览615\n28.3　XML字面量 616\n28.4　序列化 618\n28.5　拆解XML620\n28.6　反序列化.622\n28.7　加载和保存623\n28.8　对XML做模式匹配624\n28.9　结语 628\n第29章　用对象实现模块化编程.629\n29.1　问题描述.630\n29.2　食谱应用程序 631\n29.3　抽象 634\n29.4　将模块拆分成特质.638\n29.5　运行时链接640\n29.6　跟踪模块实例 642\n29.7　结语 643\n第30章　对象相等性645\n30.1　Scala中的相等性.645\n30.2　编写相等性方法 646\n30.3　为参数化类型定义相等性 660\n30.4　如何编写equals和hashCode方法.664\n30.5　结语 668\n第31章　结合Scala和Java 669\n31.1　从Java使用Scala.669\n31.2　注解 672\n31.3　通配类型.678\n31.4　同时编译Scala和Java680\n31.5　基于Scala 2.12特性的Java 8集成681\n31.6　结语 685\n第32章　Future和并发编程 686\n32.1　天堂里的烦恼 687\n32.2　异步执行和Try.688\n32.3　使用Future.690\n32.4　测试Future.705\n32.5　结语 708\n第33章　组合子解析709\n33.1　示例：算术表达式.710\n33.2　运行你的解析器 712\n33.3　基本的正则表达式解析器 713\n33.4　另一个示例：JSON 714\n33.5　解析器输出717\n33.6　实现组合子解析器.723\n33.7　字符串字面量和正则表达式.732\n33.8　词法分析和解析 733\n33.9　错误报告.734\n33.10　回溯和LL(1)736\n33.11　结语.737\n第34章　GUI编程.740\n34.1　第一个Swing应用程序.740\n34.2　面板和布局743\n34.3　处理事件.745\n34.4　示例：摄氏/华氏转换器.748\n34.5　结语 750\n第35章　SCells试算表 752\n35.1　可视化框架752\n35.2　将数据录入和显示分开755\n35.3　公式 758\n35.4　解析公式.760\n35.5　求值 765\n35.6　操作类库.768\n35.7　变更通知.771\n35.8　结语 775\n附录A　Unix和Windows环境的Scala脚本.777\n关于作者 798",
    "pages": "832页",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29620622.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29620622.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29620622.jpg"
    },
    "alt": "https://book.douban.com/subject/27591387/",
    "id": "27591387",
    "publisher": "电子工业出版社",
    "isbn10": "7121328429",
    "isbn13": "9787121328428",
    "title": "Scala编程（第3版）",
    "url": "https://api.douban.com/v2/book/27591387",
    "alt_title": "",
    "author_intro": "Martin Odersky 是Scala 编程语言的缔造者。他是瑞士洛桑理工学院（EPFL）的教授，同时也是Typesafe, Inc.（已更名为Lightbend）的创始人。他的研究方向是编程语言和系统，更具体地说，就是如何将面向对象和函数式编程风格有机地结合在一起。自2001 年起，他的主要精力集中在设计、实现和改进Scala 上。在此之前，他作为Java 泛型的合作设计者参与了Java 编程语言的开发，同时也是当前javac 参考实现的作者。他还是ACM 院士。\nLex Spoon是Semmle Ltd 的一名软件工程师。他在EPFL 作为博士后围绕着Scala 开展了两年的工作。他拥有Georgia Tech 的博士学位，在那里他的主攻方向是动态编程语言的静态分析。除Scala 外，他还帮助开发了各类编程语言，包括动态语言Smalltalk、科学计算语言X10，以及支撑Semmle 的逻辑编程语言。他和他的夫人一起生活在Atlanta，他们有两只猫和一只吉娃娃。\nBill Venners 是Artima Inc 的主席，Artima 开发者网站（ww.artima.com）的发行人，以及Escalate Software, LLC 的联合创始人。他著有《Inside theJava Virtual Machine》，这是一本面向程序员讲解Java 平台架构和内部实现原理的书。他在《JavaWorld》杂志上的专栏很受欢迎，主题涵盖Java 内部实现、面向对象的设计和Jini。Bill 从Jini 社区创立之初便十分活跃，领导了Jini 社区的ServiceUI 项目，其API 成为Jini 服务事实上的UI 标准。他还是ScalaTest 的主要开发者和设计者，一个面向Scala 和Java 开发者的开源测试工具。\n译者简介\n高宇翔，资深软件开发工程师和系统架构师，同时也是Scala在国内的早期布道者和实践者，曾译有《快学Scala（第2版）》、《快学Scala》（第1版）和《Scala编程》（第1版）等专业书籍。",
    "summary": "《Scala编程（第3版）》由直接参与Scala开发的一线人员编写，因而对原理的解读和应用的把握更加值得信赖。《Scala编程（第3版）》面向具有一定编程经验的开发者，目标是让读者能够全面了解和掌握Scala编程语言的核心特性，并能够深入理解Scala这门语言在设计取舍背后的动因。即便是不直接使用Scala或从事一线编程工作的读者，也能从《Scala编程（第3版）》学到大量关于函数式和面向对象的编程概念和技巧。",
    "price": "144.00元"
  },
  "9787115355645": {
    "rating": { "max": 10, "numRaters": 76, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["[日]千叶 滋"],
    "pubdate": "2014-6",
    "tags": [
      { "count": 154, "name": "编译原理", "title": "编译原理" },
      { "count": 75, "name": "编译器", "title": "编译器" },
      { "count": 69, "name": "计算机", "title": "计算机" },
      { "count": 60, "name": "脚本语言", "title": "脚本语言" },
      { "count": 47, "name": "编程", "title": "编程" },
      { "count": 35, "name": "计算机科学", "title": "计算机科学" },
      { "count": 20, "name": "软件开发", "title": "软件开发" },
      { "count": 17, "name": "编程艺术", "title": "编程艺术" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27306068.jpg",
    "binding": "平装",
    "translator": ["陈筱烟"],
    "catalog": "第1部分 　基础篇\n第1天 来，我们一起做些什么吧　　1\n1.1 机器语言与汇编语言　　2\n1.2 解释器与编译器　　3\n1.3 开发语言处理器　　5\n1.4 语言处理器的结构与本书的框架　　6\n第2天 设计程序设计语言　　10\n2.1 麻雀虽小、五脏俱全的程序设计语言　　11\n2.2 句尾的分号　　12\n2.3 含糊不得的语言　　14\n第3天 分割单词　　17\n3.1 Token对象　　18\n3.2 通过正则表达式定义单词　　19\n3.3 借助java.util.regex设计词法分析器　　22\n3.4 词法分析器试运行　　27\n第4天 用于表示程序的对象　　30\n4.1 抽象语法树的定义　　31\n4.2 设计节点类　　34\n4.3 BNF　　38\n4.4 语法分析与抽象语法树　　42\n第5天 设计语法分析器　　44\n5.1 Stone语言的语法　　45\n5.2 使用解析器与组合子　　46\n5.3 由语法分析器生成的抽象语法树　　53\n5.4 测试语法分析器　　59\n第6天 通过解释器执行程序　　62\n6.1 eval方法与环境对象　　63\n6.2 各种类型的eval方法　　65\n6.3 关于GluonJ　　69\n6.4 执行程序　　72\n第7天 添加函数功能　　75\n7.1 扩充语法规则　　76\n7.2 作用域与生存周期　　81\n7.3 执行函数　　83\n7.4 计算斐波那契数　　89\n7.5 为闭包提供支持　　90\n7.6 实现闭包　　92\n第8天 关联Java语言　　95\n8.1 原生函数　　96\n8.2 编写使用原生函数的程序　　98\n第9天 设计面向对象语言　　101\n9.1 设计用于操作类与对象的语法　　102\n9.2 实现类所需的语法规则　　103\n9.3 实现eval方法　　104\n9.4 通过闭包表示对象　　110\n9.5 运行包含类的程序　　114\n第10天 无法割舍的数组　　115\n10.1 扩展语法分析器　　116\n10.2 仅通过修改器来实现数组　　119\n第2部分 　性能优化篇\n第11天 优化变量读写性能　　123\n11.1 通过简单数组来实现环境　　124\n11.2 用于记录全局变量的环境　　127\n11.3 事先确定变量值的存放位置　　130\n11.4 修正eval方法并最终完成性能优化　　134\n第12天 优化对象操作性能　　137\n12.1 减少内存占用　　138\n12.2 能否通过事先查找变量的保存位置来优化性能　　141\n12.3 定义lookup方法　　144\n12.4 整合所有修改并执行　　147\n12.5 内联缓存　　152\n第13天 设计中间代码解释器　　156\n13.1 中间代码与机器语言　　157\n13.2 Stone虚拟机　　158\n13.3 通过栈实现环境　　167\n13.4 寄存器的使用　　170\n13.5 引用变量的值　　173\n13.6 if语句与while语句　　173\n13.7 函数的定义与调用　　175\n13.8 转换为虚拟机器语言　　177\n13.9 通过虚拟机执行　　184\n第14天 为Stone语言添加静态类型支持以优化性能　　187\n14.1 指定变量类型　　188\n14.2 通过数据类型检查发现错误　　193\n14.3 运行程序时执行类型检查　　204\n14.4 对类型省略的变量进行类型推论　　208\n14.5 Java二进制代码转换　　214\n14.6 综合所有修改再次运行程序　　226\n第3部分 　解说篇（自习时间）\n第15天 手工设计词法分析器 229\n15.1 修改自动机　　230\n15.2 自动机程序　　233\n15.3 正则表达式的极限　　235\n第16天 语法分析方式　　236\n16.1 正则表达式与BNF　　237\n16.2 语法分析算法　　238\n16.3 LL语法分析　　239\n16.4 算符优先分析法与自底向上语法分析　　244\n第17天 Parser库的内部结构　　251\n17.1 组合子分析　　252\n17.2 解析器组合子的内部　　252\n第18天 GluonJ的使用方法　　263\n18.1 设定类路径　　264\n18.2 启动设定　　265\n18.3 GluonJ语言　　267\n18.4 功能总结　　268\n第19天 抽象语法树与设计模式　　271\n19.1 理想的设计　　272\n19.2 Interpreter模式　　273\n19.3 Visitor模式　　276\n19.4 使用反射　　282\n19.5 面向切面语言　　284",
    "ebook_url": "https://read.douban.com/ebook/12189111/",
    "pages": "300",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27306068.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27306068.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27306068.jpg"
    },
    "alt": "https://book.douban.com/subject/25908672/",
    "id": "25908672",
    "publisher": "人民邮电出版社",
    "isbn10": "7115355649",
    "isbn13": "9787115355645",
    "title": "两周自制脚本语言",
    "url": "https://api.douban.com/v2/book/25908672",
    "alt_title": "",
    "author_intro": "作者简介：\n千叶滋\n东京工业大学研究生院信息技术理工系研究科教授，兼任东京大学研究生院信息技术理工系研究科教授。著有《面向切面入门——从Java语言・面向对象步入AspectJ语言程序设计》《简明Java程序设计——Great Ideas for Java Programming》《GUI库机制——软件设计案例研习》等。\n译者简介：\n陈筱烟\n毕业于复旦大学计算机科学与技术系，主要研究方向为跨设备人机交互理论。从大学时期开始接触Java、JavaScript程序开发，目前对Web应用及智能手机应用开发有浓厚兴趣，并参与Android开发文档翻译项目。业余开发的移动应用在Google Play商店中已有数十万次下载。译作有《JavaScript编程全解》《App，这样设计才好卖》等。",
    "summary": "《两周自制脚本语言》是一本优秀的编译原理入门读物。全书穿插了大量轻松风趣的对话，读者可以随书中的人物一起从最简单的语言解释器开始，逐步添加新功能，最终完成一个支持函数、数组、对象等高级功能的语言编译器。本书与众不同的实现方式不仅大幅简化了语言处理器的复杂度，还有助于拓展读者的视野。\n《两周自制脚本语言》适合对编译原理及语言处理器设计有兴趣的读者以及正在学习相关课程的大中专院校学生。同时，已经学习过相关知识、有一定经验的开发者，也一定能从本书新颖的实现方式中受益良多。",
    "ebook_price": "29.99",
    "series": { "id": "34137", "title": "自制系列" },
    "price": "59.00元"
  },
  "9787115480170": {
    "rating": { "max": 10, "numRaters": 30, "average": "8.7", "min": 0 },
    "subtitle": "",
    "author": [
      "[美] Gene Kim",
      "[美] Jez Humble",
      "[美] Patrick Debois",
      "[美] John Willis"
    ],
    "pubdate": "2018-4",
    "tags": [
      { "count": 82, "name": "DevOps", "title": "DevOps" },
      { "count": 28, "name": "运维", "title": "运维" },
      { "count": 18, "name": "计算机", "title": "计算机" },
      { "count": 15, "name": "软件工程", "title": "软件工程" },
      { "count": 14, "name": "产品研发管理", "title": "产品研发管理" },
      { "count": 10, "name": "软件开发", "title": "软件开发" },
      { "count": 9, "name": "计算科学", "title": "计算科学" },
      { "count": 8, "name": "理论", "title": "理论" }
    ],
    "origin_title": "The DevOps Handbook: How to Create World-Class Agility, Reliability, and Security in Technology Organizations",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29731195.jpg",
    "binding": "平装",
    "translator": ["刘征", "王磊", "马博文", "曾朝京"],
    "catalog": "第一部分　DevOps介绍\n第1章　敏捷、持续交付和三步法　　4\n1.1　制造业价值流　　4\n1.2　技术价值流　　4\n1.2.1　聚焦于部署前置时间　　5\n1.2.2　关注返工指标——%C/A　　7\n1.3　三步工作法：DevOps的基础原则　　7\n1.4　小结　　8\n第2章　第一步：流动原则　　9\n2.1　使工作可见　　9\n2.2　限制在制品数　　10\n2.3　减小批量大小　　11\n2.4　减少交接次数　　13\n2.5　持续识别和改善约束点　　14\n2.6　消除价值流中的困境和浪费　　15\n2.7　小结　　16\n第3章　第二步：反馈原则　　17\n3.1　在复杂系统中安全地工作　　17\n3.2　及时发现问题　　18\n3.3　群策群力，战胜问题获取新知　　19\n3.4　在源头保障质量　　21\n3.5　为下游工作中心而优化　　22\n3.6　小结　　22\n第4章　第三步：持续学习与实验原则　　23\n4.1　建立学习型组织和安全文化　　23\n4.2　将日常工作的改进制度化　　25\n4.3　把局部发现转化为全局优化　　26\n4.4　在日常工作中注入弹性模式　　27\n4.5　领导层强化学习文化　　27\n4.6　小结　　29\n4.7　第一部分总结　　29\n第二部分　从何处开始\n第5章　选择合适的价值流作为切入点　　32\n5.1　绿地项目与棕地项目　　34\n5.2　兼顾记录型系统和交互型系统　　35\n5.3　从最乐于创新的团队开始　　36\n5.4　扩大DevOps的范围　　37\n5.5　小结　　38\n第6章　理解、可视化和运用价值流　　39\n6.1　确定创造客户价值所需的团队　　40\n6.2　针对团队工作绘制价值流图　　40\n6.3　组建专门的转型团队　　42\n6.3.1　拥有共同的目标　　43\n6.3.2　保持小跨度的改进计划　　44\n6.3.3　为非功能性需求预留20%的\n开发时间，减少技术债务　　44\n6.3.4　提高工作的可视化程度　　47\n6.4　用工具强化预期行为　　47\n6.5　小结　　48\n第7章　参考康威定律设计组织结构　　49\n7.1　组织原型　　51\n7.2　过度职能导向的危害（“成本优化”）　　51\n7.3　组建以市场为导向的团队（“速度优化”）　　52\n7.4　使职能导向有效　　53\n7.5　将测试、运维和信息安全融入日常工作　　54\n7.6　使团队成员都成为通才　　54\n7.7　投资于服务和产品，而非项目　　56\n7.8　根据康威定律设定团队边界　　56\n7.9　创建松耦合架构，提高生产力和安全性　　57\n7.10　小结　　60\n第8章　将运维融入日常开发工作　　61\n8.1　创建共享服务，提高开发生产力　　62\n8.2　将运维工程师融入服务团队　　63\n8.3　为每个服务团队分派运维联络人　　64\n8.4　邀请运维工程师参加开发团队的会议　　65\n8.4.1　邀请运维工程师参加每日站会　　65\n8.4.2　邀请运维工程师参加回顾会议　　66\n8.4.3　使用看板图展示运维工作　　66\n8.5　小结　　67\n8.6　第二部分总结　　67\n第三部分　第一步：流动的技术实践\n第9章　为部署流水线奠定基础　　70\n9.1　按需搭建开发环境、测试环境和生产环境　　71\n9.2　应用统一的代码仓库　　72\n9.3　使基础设施的重建更容易　　74\n9.4　运行在类生产环境里才算“完成”　　75\n9.5　小结　　76\n第10章　实现快速可靠的自动化测试　　77\n10.1　对代码和环境做持续构建、测试和集成　　79\n10.2　构建快速可靠的自动化测试套件　　81\n10.2.1　在自动化测试中尽早发现\n错误　　83\n10.2.2　尽可能并行地快速执行测试　　84\n10.2.3　先编写自动化测试　　84\n10.2.4　尽量将手动测试自动化　　85\n10.2.5　在测试套件中集成性能测试　　86\n10.2.6　在测试套件中集成非功能性需求测试　　86\n10.3　在部署流水线失败时拉下安灯绳　　87\n10.4　小结　　89\n第11章　应用和实践持续集成　　90\n11.1　小批量开发与大批量合并　　92\n11.2　应用基于主干的开发实践　　93\n11.3　小结　　95\n第12章　自动化和低风险发布　　96\n12.1　自动化部署流程　　97\n12.1.1　应用自动化的自助式部署　　100\n12.1.2　在部署流水线中集成代码部署　　101\n12.2　将部署与发布解耦　　104\n12.2.1　基于环境的发布模式　　105\n12.2.2　基于应用的发布模式更安全　　109\n12.3　持续交付和持续部署实践的调查　　112\n12.4　小结　　113\n第13章　降低发布风险的架构　　114\n13.1　能提高生产力、可测试性和安全性的架构　　115\n13.2　架构原型：单体架构与微服务　　116\n13.3　安全地演进企业架构　　118\n13.4　小结　　121\n13.5　第三部分总结　　121\n第四部分　第二步：反馈的技术实践\n第14章　建立能发现并解决问题的遥测系统　　125\n14.1　建设集中式监控架构　　127\n14.2　建立生产环境的应用程序日志遥测　　129\n14.3　使用遥测指导问题的解决　　131\n14.4　将建立生产遥测融入日常工作　　132\n14.5　建立自助访问的遥测和信息辐射器　　133\n14.6　发现和填补遥测的盲区　　135\n14.6.1　应用程序和业务度量指标　　136\n14.6.2　基础架构度量指标　　137\n14.6.3　显示叠加的指标组合　　138\n14.7　小结　　139\n第15章　分析遥测数据以更好地预测故障和实现目标　　140\n15.1　用均值和标准差识别潜在问题　　141\n15.2　异常状态的处理和告警　　142\n15.3　非高斯分布遥测数据的问题　　143\n15.4　应用异常检测技术　　146\n15.5　小结　　149\n第16章　应用反馈实现安全部署　　150\n16.1　通过遥测使部署更安全　　151\n16.2　开发和运维共同承担值班工作　　153\n16.3　让开发人员跟踪工作对下游的影响　　153\n16.4　让开发人员自行管理生产服务　　155\n16.5　小结　　159\n第17章　将假设驱动的开发和A/B测试融入日常工作　　160\n17.1　A/B测试简史　　161\n17.2　在功能测试中集成A/B测试　　162\n17.3　在发布中集成A/B测试　　162\n17.4　在功能规划中集成A/B测试　　163\n17.5　小结　　165\n第18章　建立评审和协作流程以提升当前工作的质量　　166\n18.1　变更审批流程的危险　　168\n18.2 “过度控制变更”的潜在危险　　168\n18.3　变更的协调和排程　　170\n18.4　变更的同行评审　　170\n18.5　人工测试和变更冻结的潜在危害　　173\n18.6　利用结对编程改进代码变更　　173\n18.7　消除官僚流程　　176\n18.8　小结　　177\n18.9　第四部分总结　　178\n第五部分　第三步：持续学习与实验的技术实践\n第19章　将学习融入日常工作　　180\n19.1　建立公正和学习的文化　　181\n19.2　举行不指责的事后分析会议　　182\n19.3　尽可能广泛地公开事后分析会议结果　　184\n19.4　降低事故容忍度，寻找更弱的故障信号　　185\n19.5　重新定义失败，鼓励评估风险　　186\n19.6　在生产环境注入故障来恢复和学习　　186\n19.7　创建故障演练日　　187\n19.8　小结　　189\n第20章　将局部经验转化为全局改进　　190\n20.1　使用聊天室和聊天机器人自动积累组织知识　　190\n20.2　软件中便于重用的自动化、标准化流程　　192\n20.3　创建全组织共享的单一源代码库　　192\n20.4　运用自动化测试记录和交流实践来传播知识　　194\n20.5　通过确定非功能性需求来设计运维　　194\n20.6　把可重用的运维用户故事纳入开发　　195\n20.7　确保技术选型有助于实现组织目标　　195\n20.8　小结　　197\n第21章　预留组织学习和改进的时间　　198\n21.1　偿还技术债务的制度化惯例　　199\n21.2　让所有人教学相长　　200\n21.3　在DevOps会议中分享经验　　201\n21.4　传播实践的内部顾问和教练　　203\n21.5　小结　　204\n21.6　第五部分总结　　204\n第六部分　集成信息安全、变更管理和合规性的技术实践\n第22章　将信息安全融入每个人的日常工作　　207\n22.1　将安全集成到开发迭代的演示中　　207\n22.2　将安全集成到缺陷跟踪和事后分析会议中　　208\n22.3　将预防性安全控制集成到共享源代码库及共享服务中　　208\n22.4　将安全集成到部署流水线中　　209\n22.5　保证应用程序的安全性　　210\n22.6　确保软件供应链的安全　　214\n22.7　确保环境的安全　　215\n22.8　将信息安全集成到生产环境遥测中　　216\n22.9　在应用程序中建立安全遥测系统　　217\n22.10　在环境中建立安全遥测系统　　217\n22.11　保护部署流水线　　219\n22.12　小结　　219\n第23章　保护部署流水线　　220\n23.1　将安全和合规性集成到变更批准流程中　　220\n23.2　将大量低风险变更重新归类为标准变更　　221\n23.3　如何处理常规变更　　222\n23.4　减少对职责分离的依赖　　224\n23.5　确保为审计人员和合规人员留存文档和证据　　226\n23.6　小结　　228\n23.7　第六部分总结　　228行动起来——本书总结　　229\n附加材料\n附　　录　　232\n附录1　DevOps的大融合　　232\n附录2　约束理论和核心的长期\n冲突　　234\n附录3　恶性循环列表　　235\n附录4　交接和队列的危害　　235\n附录5　工业安全神话　　236\n附录6　丰田安灯绳　　237\n附录7　软件包产品　　238\n附录8　事后分析会议　　238\n附录9　猿猴军团　　239\n附录10　上线时间透明化　　240\n参考资源　　241\n致　　谢　　243\nEXIN DevOps Professional认证备考\n指南 & 模拟题①　　245",
    "pages": "328",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29731195.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29731195.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29731195.jpg"
    },
    "alt": "https://book.douban.com/subject/30186150/",
    "id": "30186150",
    "publisher": "人民邮电出版社",
    "isbn10": "7115480176",
    "isbn13": "9787115480170",
    "title": "DevOps实践指南",
    "url": "https://api.douban.com/v2/book/30186150",
    "alt_title": "The DevOps Handbook: How to Create World-Class Agility, Reliability, and Security in Technology Organizations",
    "author_intro": "作者简介：\nGene Kim\nTripwire创始人、前CTO，IT Revolution创始人，DevOps企业峰会主办人，畅销书《凤凰项目》合著者。\nJez Humble\nDevOps Research and Assessment公司CTO，加州大学伯克利分校信息学院讲师；曾任ThoughtWorks首席顾问。《精益企业》和Jolt大奖图书《持续交付》的合著者。\nPatrick Debois\nDevOps之父，致力于通过在开发、项目管理和系统管理之中应用敏捷技术来填补项目和运维之间的鸿沟。\nJohn Willis\nChain Bridge System创始人，曾任Docker公司布道师，现就职于SJ Technologies公司。\n译者简介：\n刘征\nNutanix路坦力资深架构师，EXIN首批国内DevOps Master和DevOps Professional认证讲师，持有红帽RHCA认证和AWS高级架构师认证，谙熟企业数据中心的IT服务管理。目前致力于推广DevOps相关的理念和实践，在DevOps社区中积极地参与培训和研讨会等活动，是DevOpsDays大会社区在中国的核心组织者和志愿工作者。\n王磊\n前ThoughtWorks咨询师，EXIN首批国内DevOps Master认证讲师。拥有10多年软件行业经验，以及服务化架构、持续交付和DevOps转型等方面的丰富实践经验。国内较早倡导和实践微服务的先行者，著有国内首本微服务架构相关图书《微服务架构与实践》，是西安DevOps Meetup活动的联合发起人。\n马博文\n前ThoughtWorks咨询师，AWS认证助理架构师、开发者。拥有多年Web开发和DevOps经验，熟悉持续交付、微服务。曾参与翻译《Scala编程实战》《DevOps实践》等书，是西安DevOps Meetup活动的发起人。\n曾朝京\nMicro Focus资深解决方案顾问，曾参加EXIN首批国内Devops Master讲师认证培训。长期从事IT运维管理领域咨询工作，曾为能源、金融、航空运输、政府行业中的多个大型企业提供IT运维管理规划。目前致力于探索DevOps理念在企业IT部门的实践。",
    "summary": "本书共分为6个部分：第一部分概述DevOps的历史和三个基本原则，即“三步工作法”；第二部分介绍开启DevOps转型的过程；第三到五部分深入探讨“三步工作法”的各个要素；第六部分关注如何将安全性和合规性正确集成到日常工作中。全书涵盖40余个DevOps案例，以谷歌、亚马逊、Facebook等全球知名企业和组织的实际调查结果为依据，展示如何通过现代化的运维管理提升管理效率，进而为企业赢得更大市场、创造更多利润。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "89.00元"
  },
  "9787115449573": {
    "rating": { "max": 10, "numRaters": 13, "average": "8.7", "min": 0 },
    "subtitle": "",
    "author": ["[英] Adrian Mouat"],
    "pubdate": "2017-4",
    "tags": [
      { "count": 20, "name": "docker", "title": "docker" },
      { "count": 11, "name": "DevOps", "title": "DevOps" },
      { "count": 6, "name": "运维", "title": "运维" },
      { "count": 4, "name": "编程", "title": "编程" },
      { "count": 3, "name": "Docker", "title": "Docker" },
      { "count": 2, "name": "●2018", "title": "●2018" },
      { "count": 1, "name": "♥自学编程", "title": "♥自学编程" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29419090.jpg",
    "binding": "平装",
    "translator": ["黄彦邦"],
    "catalog": "前言　　xi\n第一部分　背景与基础\n第1章　何谓容器，为何需要它　　3\n1.1　容器与虚拟机的比较　　4\n1.2　Docker与容器　　5\n1.3　Docker的历史　　7\n1.4　插件与基础设施　　8\n1.5　64位Linux　　9\n第2章　安装　　10\n2.1　在Linux上安装 Docker　　10\n2.1.1　将SELinux置于宽容模式下运行　　11\n2.1.2　不使用sudo命令执行 Docker　　11\n2.2　在 Mac OS及Windows上安装 Docker　　12\n2.3　快速确认　　13\n第3章　迈出第一步　　15\n3.1　运行第一个镜像　　15\n3.2　基本命令　　16\n3.3　通过Dockerfile创建镜像　　20\n3.4　使用寄存服务　　22\n3.5　使用Redis官方镜像　　24\n3.6　总结　　27\n第4章　Docker基本概念　　28\n4.1　Docker系统架构　　28\n4.1.1　底层技术　　29\n4.1.2　周边技术　　30\n4.1.3　Docker托管　　31\n4.2　镜像是如何生成的　　32\n4.2.1　构建环境的上下文　　32\n4.2.2　镜像层　　33\n4.2.3　缓存　　35\n4.2.4　基础镜像　　35\n4.2.5　Dockerfile指令　　37\n4.3　使容器与世界相连　　39\n4.4　容器互联　　40\n4.5　利用数据卷和数据容器管理数据　　41\n4.5.1　共享数据　　43\n4.5.2　数据容器　　44\n4.6　Docker常用命令　　45\n4.6.1　run命令　　46\n4.6.2　容器管理　　48\n4.6.3　Docker信息　　50\n4.6.4　容器信息　　50\n4.6.5　镜像管理　　52\n4.6.6　使用寄存服务器　　54\n4.7　总结　　55\n第二部分　Docker与软件生命周期\n第5章　在开发中应用Docker　　59\n5.1　说声“Hello World!”　　59\n5.2　通过Compose实现自动化　　67\n5.3　总结　　69\n第6章　创建一个简单的Web应用　　71\n6.1　创建一个基本网页　　72\n6.2　利用现有镜像　　73\n6.3　实现缓存功能　　78\n6.4　微服务　　81\n6.5　总结　　81\n第7章　镜像分发　　82\n7.1　镜像及镜像库的命名方式　　82\n7.2　Docker Hub　　83\n7.3　自动构建　　85\n7.4　私有分发　　86\n7.4.1　运行自己的寄存服务　　86\n7.4.2　商业寄存服务　　92\n7.5　缩减镜像大小　　92\n7.6　镜像出处　　94\n7.7　总结　　94\n第8章　Docker持续集成与测试　　95\n8.1　为identidock添加单元测试　　95\n8.2　创建Jenkins容器　　100\n8.3　推送镜像　　106\n8.3.1　给镜像正确的标签　　106\n8.3.2　准生产及生产环境　　108\n8.3.3　镜像数量激增的问题　　108\n8.3.4　使用Docker部署Jenkins slaves　　109\n8.4　备份Jenkins数据　　109\n8.5　持续集成的托管解决方案　　109\n8.6　测试与微服务　　110\n8.7　总结　　111\n第9章　部署容器　　113\n9.1　通过Docker Machine配置资源　　114\n9.2　使用代理　　117\n9.3　执行选项　　122\n9.3.1　shell脚本　　122\n9.3.2　使用进程管理器（或用systemd控制所有进程）　　124\n9.3.3　使用配置管理工具　　127\n9.4　主机配置　　130\n9.4.1　选择操作系统　　130\n9.4.2　选择存储驱动程序　　130\n9.5　专门的托管方案　　132\n9.5.1　Triton　　132\n9.5.2　谷歌容器引擎　　134\n9.5.3　亚马逊EC2容器服务　　135\n9.5.4　Giant Swarm　　136\n9.6　持久性数据和生产环境容器　　138\n9.7　分享秘密信息　　139\n9.7.1　在镜像中保存秘密信息　　139\n9.7.2　通过环境变量传递密钥　　139\n9.7.3　通过数据卷传递密钥　　140\n9.7.4　使用键值存储　　140\n9.8　网络连接　　141\n9.9　生产环境的寄存服务　　141\n9.10　持续部署/交付　　141\n9.11　总结　　142\n第10章　日志记录和监控　　143\n10.1　日志记录　　144\n10.1.1　Docker默认的日志记录　　144\n10.1.2　日志汇总　　145\n10.1.3　使用ELK 进行日志记录　　146\n10.1.4　通过syslog实现日志管理　　155\n10.1.5　从文件抓取日志　　160\n10.2　监控和警报　　161\n10.2.1　使用Docker工具进行监测　　161\n10.2.2　cAdvisor　　162\n10.2.3　集群解决方案　　163\n10.3　商用的监听及日志记录解决方案　　166\n10.4　总结　　166\n第三部分　工具和技术\n第11章　联网和服务发现　　169\n11.1　大使容器　　170\n11.2　服务发现　　173\n11.2.1　etcd　　173\n11.2.2　SkyDNS　　177\n11.2.3　Consul　　181\n11.2.4　服务注册　　185\n11.2.5　其他解决方案　　186\n11.3　联网选项　　187\n11.3.1　网桥模式　　187\n11.3.2　主机模式　　188\n11.3.3　容器模式　　188\n11.3.4　 未联网模式　　188\n11.4　全新的Docker联网功能　　188\n11.5　网络解决方案　　190\n11.5.1　Overlay　　191\n11.5.2　Weave　　193\n11.5.3　Flannel　　196\n11.5.4　Calico项目　　201\n11.6　总结　　205\n第12章　编排、集群和管理　　207\n12.1　集群和编排工具　　208\n12.1.1　Swarm　　208\n12.1.2　fleet　　214\n12.1.3　Kubernetes　　219\n12.1.4　Mesos和Marathon　　226\n12.2　容器管理平台　　235\n12.2.1　Rancher　　236\n12.2.2　Clocker　　237\n12.2.3　Tutum　　238\n12.3　总结　　239\n第13章　容器安全与限制容器　　241\n13.1　需要考虑的事项　　242\n13.2　纵深防御　　244\n13.3　如何保护identidock　　245\n13.4　以主机隔离容器　　246\n13.5　进行更新　　246\n13.6　镜像出处　　249\n13.6.1　Docker摘要　　250\n13.6.2　Docker的内容信任机制　　250\n13.6.3　可复制及可信任的Dockerfile　　254\n13.7　安全建议　　256\n13.7.1　设置用户　　256\n13.7.2　限制容器联网　　257\n13.7.3　删除setuid和setgid的二进制文件　　258\n13.7.4　限制内存使用　　259\n13.7.5　限制CPU 使用　　260\n13.7.6　限制重新启动　　261\n13.7.7　限制文件系统　　261\n13.7.8　限制内核能力　　262\n13.7.9　应用资源限制　　263\n13.8　运行加固内核　　264\n13.9　Linux安全模块　　265\n13.9.1　SELinux　　265\n13.9.2　AppArmor　　268\n13.10　审核　　268\n13.11　事件响应　　269\n13.12　未来特性　　269\n13.13　总结　　270\n作者简介　　271\n关于封面　　271",
    "pages": "288",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29419090.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29419090.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29419090.jpg"
    },
    "alt": "https://book.douban.com/subject/27013734/",
    "id": "27013734",
    "publisher": "人民邮电出版社",
    "isbn10": "7115449570",
    "isbn13": "9787115449573",
    "title": "Docker开发指南",
    "url": "https://api.douban.com/v2/book/27013734",
    "alt_title": "",
    "author_intro": "作者简介：\nAdrian Mouat\nContainer Solutions公司首席科学家。参与过很多软件项目，既有小型的Web应用，也有大型数据分析软件。\n译者简介 ：\n黄彦邦（Anthony Wong）\nLinux开发专家，热衷于开源技术，从事Linux相关开发工作十多年，曾参与多个大型开源项目，如Debian GNU/Linux和Ubuntu，提交补丁无数。以推动Debian系统中文化以及网站和文档翻译为目标，1998年成为中国首位Debian计划官方开发者。",
    "summary": "Docker容器轻量和可移植的特性尤其适用于动态和分布式的环境，它的兴起给软件开发流程带来了一场革命。本书对Docker进行了全面讲解，包括开发、生产以至维护的整个软件生命周期，并对其中可能出现的一些问题进行了探讨，如软件版本差异、开发环境与生产环境的差异、系统安全问题，等等。",
    "price": "79.00元"
  },
  "9787115264596": {
    "rating": { "max": 10, "numRaters": 318, "average": "8.6", "min": 0 },
    "subtitle": "发布可靠软件的系统方法",
    "author": ["Jez Humble", "David Farley"],
    "pubdate": "2011-10",
    "tags": [
      { "count": 465, "name": "软件工程", "title": "软件工程" },
      { "count": 412, "name": "持续交付", "title": "持续交付" },
      { "count": 297, "name": "敏捷开发", "title": "敏捷开发" },
      { "count": 248, "name": "项目管理", "title": "项目管理" },
      { "count": 134, "name": "软件开发", "title": "软件开发" },
      { "count": 74, "name": "计算机", "title": "计算机" },
      { "count": 59, "name": "IT", "title": "IT" },
      { "count": 55, "name": "agile", "title": "agile" }
    ],
    "origin_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
    "image": "https://img3.doubanio.com/view/subject/m/public/s27996261.jpg",
    "binding": "平装",
    "translator": ["乔梁"],
    "catalog": "第一部分  基础篇\n第1 章  软件交付的问题　　 2\n1.1  引言　　2\n1.2  一些常见的发布反模式　　 3\n1.2.1  反模式：手工部署软件　　 4\n1.2.2  反模式：开发完成之后才向类生产环境部署　　 5\n1.2.3  反模式：生产环境的手工配置管理　　7\n1.2.4  我们能做得更好吗　　 8\n1.3  如何实现目标　　 9\n1.3.1  每次修改都应该触发反馈流程　　10\n1.3.2  必须尽快接收反馈　　 11\n1.3.3  交付团队必须接收反馈并作出反应　　 12\n1.3.4  这个流程可以推广吗　　12\n1.4  收效　　12\n1.4.1  授权团队　　13\n1.4.2  减少错误　　13\n1.4.3  缓解压力　　15\n1.4.4  部署的灵活性　　16\n1.4.5  多加练习，使其完美　　17\n1.5  候选发布版本　　17\n1.6  软件交付的原则　　19\n1.6.1  为软件的发布创建一个可重复且可靠的过程　　19\n1.6.2  将几乎所有事情自动化　　19\n1.6.3  把所有的东西都纳入版本控制　　20\n1.6.4  提前并频繁地做让你感到痛苦的事　　20\n1.6.5  内建质量　　21\n1.6.6  “DONE”意味着“已发布” 　　 21\n1.6.7  交付过程是每个成员的责任　　 22\n1.6.8  持续改进　　22\n1.7  小结　　 23\n第2 章  配置管理　　24\n2.1  引言　　24\n2.2  使用版本控制　　25\n2.2.1  对所有内容进行版本控制　　26\n2.2.2  频繁提交代码到主干　　28\n2.2.3  使用意义明显的提交注释　　29\n2.3  依赖管理　　30\n2.3.1  外部库文件管理　　30\n2.3.2  组件管理　　30\n2.4  软件配置管理　　31\n2.4.1  配置与灵活性　　31\n2.4.2  配置的分类　　 33\n2.4.3  应用程序的配置管理　　33\n2.4.4  跨应用的配置管理　　36\n2.4.5  管理配置信息的原则　　 37\n2.5  环境管理　　 38\n2.5.1  环境管理的工具　　41\n2.5.2  变更过程管理　　41\n2.6  小结　　 42\n第3 章  持续集成　　43\n3.1  引言　　43\n3.2  实现持续集成　　44\n3.2.1  准备工作　　44\n3.2.2  一个基本的持续集成系统　　45\n3.3  持续集成的前提条件　　46\n3.3.1  频繁提交　　46\n3.3.2  创建全面的自动化测试套件　　47\n3.3.3  保持较短的构建和测试过程　　47\n3.3.4  管理开发工作区　　 49\n3.4  使用持续集成软件　　49\n3.4.1  基本操作　　 49\n3.4.2  铃声和口哨　　 50\n3.5  必不可少的实践　　 52\n3.5.1  构建失败之后不要提交新代码　　52\n3.5.2  提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事　　53\n3.5.3  等提交测试通过后再继续工作　　54\n3.5.4  回家之前，构建必须处于成功状态　　 54\n3.5.5  时刻准备着回滚到前一个版本　　55\n3.5.6  在回滚之前要规定一个修复时间　　56\n3.5.7  不要将失败的测试注释掉　　 56\n3.5.8  为自己导致的问题负责　　56\n3.5.9  测试驱动的开发　　57\n3.6  推荐的实践　　 57\n3.6.1  极限编程开发实践　　57\n3.6.2  若违背架构原则，就让构建失败　　 58\n3.6.3  若测试运行变慢，就让构建失败　　 58\n3.6.4  若有编译警告或代码风格问题，就让测试失败　　59\n3.7  分布式团队　　60\n3.7.1  对流程的影响　　60\n3.7.2  集中式持续集成　　 61\n3.7.3  技术问题　　61\n3.7.4  替代方法　　 62\n3.8  分布式版本控制系统　　63\n3.9  小结　　66\n第4 章  测试策略的实现　　 67\n4.1  引言　　 67\n4.2  测试的分类　　 68\n4.2.1  业务导向且支持开发过程的测试　　69\n4.2.2  技术导向且支持开发过程的测试　　72\n4.2.3  业务导向且评价项目的测试　　72\n4.2.4  技术导向且评价项目的测试　　73\n4.2.5  测试替身　　74\n4.3  现实中的情况与应对策略　　75\n4.3.1  新项目　　75\n4.3.2  项目进行中　　 76\n4.3.3  遗留系统　　 77\n4.3.4  集成测试　　78\n4.4  流程　　80\n4.5  小结　　82\n第二部分  部署流水线\n第5 章  部署流水线解析　　84\n5.1  引言　　 84\n5.2  什么是部署流水线　　85\n5.3  部署流水线的相关实践　　91\n5.3.1  只生成一次二进制包　　 91\n5.3.2  对不同环境采用同一部署方式　　93\n5.3.3  对部署进行冒烟测试　　 94\n5.3.4  向生产环境的副本中部署　　94\n5.3.5  每次变更都要立即在流水线中传递　　 95\n5.3.6  只要有环节失败，就停止整个流水线　　96\n5.4  提交阶段　　96\n5.5  自动化验收测试之门　　99\n5.6  后续的测试阶段　　102\n5.6.1  手工测试　　 103\n5.6.2  非功能测试　　103\n5.7  发布准备　　104\n5.7.1  自动部署与发布　　 104\n5.7.2  变更的撤销　　106\n5.7.3  在成功的基础上构建　　 107\n5.8  实现一个部署流水线　　 107\n5.8.1  对价值流进行建模并创建简单的可工作框架　　 107\n5.8.2  构建和部署过程的自动化　　108\n5.8.3  自动化单元测试和代码分析　　109\n5.8.4  自动化验收测试　　 109\n5.8.5  部署流水线的演进　　 110\n5.9  度量　　111\n5.10  小结　　113\n第6 章  构建与部署的脚本化　　 115\n6.1  引言　　115\n6.2  构建工具概览　　116\n6.2.1  Make　　118\n6.2.2  Ant　　118\n6.2.3  NAnt 与 MSBuild　　119\n6.2.4  Maven　　120\n6.2.5  Rake 　　121\n6.2.6  Buildr 　　121\n6.2.7  Psake 　　121\n6.3  构建部署脚本化的原则与实践　　 122\n6.3.1  为部署流水线的每个阶段创建脚本　　122\n6.3.2  使用恰当的技术部署应用程序　　 122\n6.3.3  使用同样的脚本向所有环境部署　　123\n6.3.4  使用操作系统自带的包管理工具　　124\n6.3.5  确保部署流程是幂等的（Idempotent）　　125\n6.3.6  部署系统的增量式演进　　126\n6.4  面向JVM 的应用程序的项目结构　　126\n6.5  部署脚本化　　129\n6.5.1  多层的部署和测试　　130\n6.5.2  测试环境配置　　131\n6.6  小贴士　　132\n6.6.1  总是使用相对路径　　132\n6.6.2  消除手工步骤　　132\n6.6.3  从二进制包到版本控制库的内建可追溯性　　133\n6.6.4  不要把二进制包作为构建的一部分放到版本控制库中　　133\n6.6.5  “test”不应该让构建失败　　134\n6.6.6  用集成冒烟测试来限制应用程序　　134\n6.6.7  .NET 小贴士　　135\n6.7  小结　　135\n第7 章  提交阶段　　137\n7.1  引言　　137\n7.2  提交阶段的原则和实践　　138\n7.2.1  提供快速有用的反馈　　138\n7.2.2  何时令提交阶段失败　　139\n7.2.3  精心对待提交阶段　　140\n7.2.4  让开发人员也拥有所有权　　140\n7.2.5  在超大项目团队中指定一个构建负责人　　141\n7.3  提交阶段的结果　　141\n7.4  提交测试套件的原则与实践　　144\n7.4.1  避免用户界面　　145\n7.4.2  使用依赖注入　　145\n7.4.3  避免使用数据库　　145\n7.4.4  在单元测试中避免异步　　146\n7.4.5  使用测试替身　　 146\n7.4.6  最少化测试中的状态　　 149\n7.4.7  时间的伪装　　150\n7.4.8  蛮力　　150\n7.5  小结　　 151\n第8 章  自动化验收测试　　152\n8.1  引言　　 152\n8.2  为什么验收测试是至关重要的　　 153\n8.2.1  如何创建可维护的验收测试套件　　155\n8.2.2  GUI 上的测试　　 156\n8.3  创建验收测试　　157\n8.3.1  分析人员和测试人员的角色　　157\n8.3.2  迭代开发项目中的分析工作　　157\n8.3.3  将验收条件变成可执行的规格说明书　　 158\n8.4  应用程序驱动层　　161\n8.4.1  如何表述验收条件　　 163\n8.4.2  窗口驱动器模式：让测试与GUI 解耦　　164\n8.5  实现验收测试　　166\n8.5.1  验收测试中的状态　　 166\n8.5.2  过程边界、封装和测试　　 168\n8.5.3  管理异步与超时问题　　 169\n8.5.4  使用测试替身对象　　 171\n8.6  验收测试阶段　　174\n8.6.1  确保验收测试一直处于通过状态　　175\n8.6.2  部署测试　　177\n8.7  验收测试的性能　　178\n8.7.1  重构通用任务　　 178\n8.7.2  共享昂贵资源　　 179\n8.7.3  并行测试　　180\n8.7.4  使用计算网格　　 180\n8.8  小结　　181\n第9 章  非功能需求的测试　　183\n9.1  引言　　183\n9.2  非功能需求的管理　　184\n9.3  如何为容量编程　　186\n9.4  容量度量　　188\n9.5  容量测试环境　　191\n9.6  自动化容量测试　　194\n9.6.1  通过UI 的容量测试　　195\n9.6.2  基于服务或公共API 来录制交互操作　　196\n9.6.3  使用录制的交互模板　　 197\n9.6.4  使用容量测试桩开发测试　　198\n9.7  将容量测试加入到部署流水线中　　199\n9.8  容量测试系统的附加价值　　 201\n9.9  小结　　 202\n第10 章  应用程序的部署与发布　　 203\n10.1  引言　　203\n10.2  创建发布策略　　 204\n10.2.1  发布计划　　205\n10.2.2  发布产品　　205\n10.3  应用程序的部署和晋级　　 206\n10.3.1  首次部署　　206\n10.3.2  对发布过程进行建模并让构建晋级　　 207\n10.3.3  配置的晋级　　209\n10.3.4  联合环境　　209\n10.3.5  部署到试运行环境　　 210\n10.4  部署回滚和零停机发布　　211\n10.4.1  通过重新部署原有的正常版本来进行回滚　　211\n10.4.2  零停机发布　　212\n10.4.3  蓝绿部署　　 212\n10.4.4  金丝雀发布　　213\n10.5  紧急修复　　216\n10.6  持续部署　　216\n10.7  小贴士和窍门　　 219\n10.7.1  真正执行部署操作的人应该参与部署过程的创建　　219\n10.7.2  记录部署活动　　 220\n10.7.3  不要删除旧文件，而是移动到别的位置　　 220\n10.7.4  部署是整个团队的责任　　 220\n10.7.5  服务器应用程序不应该有GUI 　　220\n10.7.6  为新部署留预热期　　 221\n10.7.7  快速失败　　 221\n10.7.8  不要直接对生产环境进行修改　　222\n10.8  小结　　222\n第三部分  交付生态圈\n第11 章  基础设施和环境管理　　 224\n11.1  引言　　 224\n11.2  理解运维团队的需要　　 225\n11.2.1  文档与审计　　 226\n11.2.2  异常事件的告警　　 227\n11.2.3  保障IT 服务持续性的计划　　227\n11.2.4  使用运维团队熟悉的技术　　 228\n11.3  基础设施的建模和管理　　229\n11.3.1  基础设施的访问控制　　 230\n11.3.2  对基础设施进行修改　　 231\n11.4  服务器的准备及其配置的管理　　 232\n11.4.1  服务器的准备　　 233\n11.4.2  服务器的持续管理　　 234\n11.5  中间件的配置管理　　239\n11.5.1  管理配置项　　 239\n11.5.2  产品研究　　 241\n11.5.3  考查中间件是如何处理状态的　　 242\n11.5.4  查找用于配置的API 　　 242\n11.5.5  使用更好的技术　　 243\n11.6  基础设施服务的管理　　243\n11.7  虚拟化　　245\n11.7.1  虚拟环境的管理　　 247\n11.7.2  虚拟环境和部署流水线　　249\n11.7.3  用虚拟环境做高度的并行测试　　251\n11.8  云计算　　252\n11.8.1  云中基础设施　　253\n11.8.2  云中平台　　254\n11.8.3  没有普适存在　　255\n11.8.4  对云计算的批评　　256\n11.9  基础设施和应用程序的监控　　256\n11.9.1  收集数据　　257\n11.9.2  记录日志　　259\n11.9.3  建立信息展示板　　259\n11.9.4  行为驱动的监控　　261\n11.10  小结　　261\n第12 章  数据管理　　263\n12.1  引言　　263\n12.2  数据库脚本化　　264\n12.3  增量式修改　　265\n12.3.1  对数据库进行版本控制　　265\n12.3.2  联合环境中的变更管理　　267\n12.4  数据库回滚和无停机发布　　268\n12.4.1  保留数据的回滚　　268\n12.4.2  将应用程序部署与数据库迁移解耦　　269\n12.5  测试数据的管理　　270\n12.5.1  为单元测试进行数据库模拟　　271\n12.5.2  管理测试与数据之间的耦合　　272\n12.5.3  测试独立性　　272\n12.5.4  建立和销毁　　273\n12.5.5  连贯的测试场景　　273\n12.6  数据管理和部署流水线　　274\n12.6.1  提交阶段的测试数据　　274\n12.6.2  验收测试中的数据　　275\n12.6.3  容量测试的数据　　276\n12.6.4  其他测试阶段的数据　　277\n12.7  小结　　278\n第13 章  组件和依赖管理　　280\n13.1  引言　　280\n13.2  保持应用程序可发布　　281\n13.2.1  将新功能隐蔽起来，直到它完成为止　　282\n13.2.2  所有修改都是增量式的　　 283\n13.2.3  通过抽象来模拟分支　　 284\n13.3  依赖　　285\n13.3.1  依赖地狱　　 286\n13.3.2  库管理　　 287\n13.4  组件　　289\n13.4.1  如何将代码库分成多个组件　　289\n13.4.2  将组件流水线化　　 292\n13.4.3  集成流水线　　 293\n13.5  管理依赖关系图　　295\n13.5.1  构建依赖图　　 295\n13.5.2  为依赖图建立流水线　　 297\n13.5.3  什么时候要触发构建　　 299\n13.5.4  谨慎乐观主义　　 300\n13.5.5  循环依赖　　302\n13.6  管理二进制包　　303\n13.6.1  制品库是如何运作的　　 303\n13.6.2  部署流水线如何与制品库相结合　　 304\n13.7  用Maven 管理依赖　　304\n13.8  小结　　 308\n第14 章  版本控制进阶　　 309\n14.1  引言　　309\n14.2  版本控制的历史　　310\n14.2.1  CVS 　　310\n14.2.2  SVN 　　311\n14.2.3  商业版本控制系统　　 312\n14.2.4  放弃悲观锁　　 313\n14.3  分支与合并　　 314\n14.3.1  合并　　 316\n14.3.2  分支、流和持续集成　　 317\n14.4  DVCS 　　319\n14.4.1  什么是DVCS 　　 319\n14.4.2  DVCS 简史　　 321\n14.4.3  企业环境中的DVCS　　 321\n14.4.4  使用DVCS　　 322\n14.5  基于流的版本控制系统　　 324\n14.5.1  什么是基于流的版本控制系统　　324\n14.5.2  使用流的开发模型　　 326\n14.5.3  静态视图和动态视图　　 327\n14.5.4  使用基于流的版本控制系统做持续集成　　 328\n14.6  主干开发　　329\n14.7  按发布创建分支　　332\n14.8  按功能特性分支　　333\n14.9  按团队分支　　335\n14.10  小结　　338\n第15 章  持续交付管理　　340\n15.1  引言　　 340\n15.2  配置与发布管理成熟度模型　　341\n15.3  项目生命周期　　 343\n15.3.1  识别阶段　　344\n15.3.2  启动阶段　　345\n15.3.3  初始阶段　　346\n15.3.4  开发与发布　　347\n15.3.5  运营阶段　　 349\n15.4  风险管理流程　　 350\n15.4.1  风险管理基础篇　　 350\n15.4.2  风险管理时间轴　　 351\n15.4.3  如何做风险管理的练习　　352\n15.5  常见的交付问题、症状和原因　　353\n15.5.1  不频繁的或充满缺陷的部署　　353\n15.5.2  较差的应用程序质量　　 354\n15.5.3  缺乏管理的持续集成工作流程　　355\n15.5.4  较差的配置管理　　 355\n15.6  符合度与审计　　356\n15.6.1  文档自动化　　356\n15.6.2  加强可跟踪性　　 357\n15.6.3  在筒仓中工作　　 358\n15.6.4  变更管理　　358\n15.7  小结　　360\n参考书目　　361",
    "pages": "362",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s27996261.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s27996261.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s27996261.jpg"
    },
    "alt": "https://book.douban.com/subject/6862062/",
    "id": "6862062",
    "publisher": "人民邮电出版社",
    "isbn10": "7115264597",
    "isbn13": "9787115264596",
    "title": "持续交付",
    "url": "https://api.douban.com/v2/book/6862062",
    "alt_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
    "author_intro": "Jez Humble ToughtWorks公司首席咨询顾问，致力于帮助企业快速、可靠地交付高质量软件，经常在各种敏捷技术大会上发表演讲，拥有牛津大学物理学学士学位和 伦敦大学民族音乐学的 硕士学位。2000年至今，他曾在各行业和不同技术领域担任系统管理员、开发人员、培训人员、咨询师和经理人员。\nDavid Farley 正在帮助构建伦敦多资产交易所（LMAE）。他具有20年的大型分布式系统开发经验，是采用敏捷开发技术的先行者，曾作为技术负责人参加了ThoughtWorks公司许多极具挑战性的软件项目。",
    "summary": "Jez Humble编著的《持续交付(发布可靠软件的系统方法)》讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。《持续交付(发布可靠软件的系统方法)》由三部分组成。第一部分阐述了持续交付背后的一些原则，以及支持这些原则的实践。第二部分是本书的核心，全面讲述了部署流水线。第三部分围绕部署流水线的投入产出讨论了更多细节，包括增量开发技术、高级版本控制模式，以及基础设施、环境和数据的管理和组织治理。    《持续交付(发布可靠软件的系统方法)》适合所有开发人员、测试人员、运维人员和项目经理学习参考。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "89.00元"
  },
  "9787115422187": {
    "rating": { "max": 10, "numRaters": 33, "average": "8.2", "min": 0 },
    "subtitle": "",
    "author": ["[日] 青木峰郎"],
    "pubdate": "2016-6",
    "tags": [
      { "count": 91, "name": "编译原理", "title": "编译原理" },
      { "count": 59, "name": "编译器", "title": "编译器" },
      { "count": 47, "name": "计算机", "title": "计算机" },
      { "count": 29, "name": "编译", "title": "编译" },
      { "count": 25, "name": "编程", "title": "编程" },
      { "count": 21, "name": "自制系列", "title": "自制系列" },
      { "count": 14, "name": "compiler", "title": "compiler" },
      { "count": 12, "name": "计算机科学", "title": "计算机科学" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28768045.jpg",
    "binding": "平装",
    "translator": ["严圣逸", "绝云"],
    "catalog": "目　录\n第1章　开始制作编译器　　1\n1.1　本书的概要　　2\n本书的主题　　2\n本书制作的编译器　　 2\n编译示例　　2\n可执行文件　　3\n编译　　4\n程序运行环境　　6\n1.2　编译过程　　8\n编译的4 个阶段　　8\n语法分析　　8\n语义分析　　9\n生成中间代码　　9\n代码生成　　10\n优化　　10\n总结　　10\n1.3　使用CЬ编译器进行编译　　11\nCЬ编译器的必要环境　　11\n安装CЬ编译器　　11\nCЬ的Hello, World!　　12\n第2章　CЬ和cbc　　13\n2.1　CЬ语言的概要　　14\nCЬ的Hello, World ！　　14\nCЬ中删减的功能　　 14\nimport 关键字　　15\n导入文件的规范　　16\n2.2　CЬ编译器cbc 的构成　　17\ncbc 的代码树　　17\ncbc 的包　　18\ncompiler 包中的类群　　18\nmain 函数的实现　　 19\ncommandMain 函数的实现　　19\nJava5 泛型　　20\nbuild 函数的实现　　 20\nJava 5 的foreach 语句　　21\ncompile 函数的实现　　21\n第1部分　代码分析\n第3章　语法分析的概要　　24\n3.1　语法分析的方法　　25\n代码分析中的问题点　　25\n代码分析的一般规律　　25\n词法分析、语法分析、语义分析　　25\n扫描器的动作　　26\n单词的种类和语义值　　27\ntoken　　28\n抽象语法树和节点　　29\n3.2　解析器生成器　　30\n什么是解析器生成器　　30\n解析器生成器的种类　　30\n解析器生成器的选择　　31\n3.3　JavaCC 的概要　　33\n什么是JavaCC　　33\n语法描述文件　　33\n语法描述文件的例子　　34\n运行JavaCC　　35\n启动JavaCC 所生成的解析器　　36\n中文的处理　　37\n第4章　词法分析　　39\n4.1　基于JavaCC 的扫描器的描述　　40\n本章的目的　　40\nJavaCC 的正则表达式　　40\n固定字符串　　41\n连接　　41\n字符组　　41\n排除型字符组　　41\n重复1 次或多次　　42\n重复0 次或多次　　42\n重复n 次到m 次　　 42\n正好重复n 次　　43\n可以省略　　43\n选择　　43\n4.2　扫描没有结构的单词　　44\nTOKEN 命令　　44\n扫描标识符和保留字　　44\n选择匹配规则　　45\n扫描数值　　46\n4.3　扫描不生成token 的单词　　48\nSKIP 命令和SPECIAL_TOKEN 命令　　48\n跳过空白符　　48\n跳过行注释　　49\n4.4 扫描具有结构的单词　　50\n最长匹配原则和它的问题　　50\n基于状态迁移的扫描　　50\nMORE 命令　　51\n跳过块注释　　52\n扫描字符串字面量　　53\n扫描字符字面量　　53\n第5章　基于JavaCC 的解析器的描述　　55\n5.1　基于EBNF 语法的描述　　56\n本章的目的　　56\n基于JavaCC 的语法描述　　56\n终端符和非终端符　　57\nJavaCC 的EBNF 表示法　　58\n连接　　58\n重复0 次或多次　　59\n重复1 次或多次　　59\n选择　　60\n可以省略　　60\n5.2　语法的二义性和token 的超前扫描　　61\n语法的二义性　　61\nJavaCC 的局限性　　62\n提取左侧共通部分　　63\ntoken 的超前扫描　　63\n可以省略的规则和冲突　　64\n重复和冲突　　65\n更灵活的超前扫描　　66\n超前扫描的相关注意事项　　66\n第6章　语法分析　　68\n6.1　定义的分析　　69\n表示程序整体的符号　　69\n语法的单位　　69\nimport 声明的语法　　70\n各类定义的语法　　71\n变量定义的语法　　72\n函数定义的语法　　73\n结构体定义和联合体定义的语法　　74\n结构体成员和联合体成员的语法　　75\ntypedef 语句的语法　　76\n类型的语法　　76\nC 语言和CЬ在变量定义上的区别　　77\n基本类型的语法　　77\n6.2　语句的分析　　79\n语句的语法　　79\nif 语句的语法　　80\n省略if 语句和大括号　　80\nwhile 语句的语法　　81\nfor 语句的语法　　81\n各类跳转语句的语法　　82\n6.3　表达式的分析　　83\n表达式的整体结构　　83\nexpr 的规则　　83\n条件表达式　　84\n二元运算符　　85\n6.4　项的分析　　88\n项的规则　　88\n前置运算符的规则　　88\n后置运算符的规则　　89\n字面量的规则　　89\n第2部分　抽象语法树和中间代码\n第7章　JavaCC 的action 和抽象语法树　　92\n7.1　JavaCC 的action　　93\n本章的目的　　93\n简单的action　　93\n执行action 的时间点　　93\n返回语义值的action　　95\n获取终端符号的语义值　　95\nToken 类的属性　　96\n获取非终端符号的语义值　　98\n语法树的结构　　99\n选择和action　　99\n重复和action　　100\n本节总结　　102\n7.2　抽象语法树和节点　　103\nNode 类群　　103\nNode 类的定义　　105\n抽象语法树的表示　　105\n基于节点表示表达式的例子　　107\n第8章　抽象语法树的生成　　110\n8.1　表达式的抽象语法树　　111\n字面量的抽象语法树　　111\n类型的表示　　112\n为什么需要TypeRef 类　　113\n一元运算的抽象语法树　　114\n二元运算的抽象语法树　　116\n条件表达式的抽象语法树　　117\n赋值表达式的抽象语法树　　118\n8.2　语句的抽象语法树　　121\nif 语句的抽象语法树　　121\nwhile 语句的抽象语法树　　122\n程序块的抽象语法树　　123\n8.3　声明的抽象语法树　　125\n变量声明列表的抽象语法树　　125\n函数定义的抽象语法树　　126\n表示声明列表的抽象语法树　　127\n表示程序整体的抽象语法树　　128\n外部符号的import　　128\n总结　　129\n8.4　cbc 的解析器的启动　　132\nParser 对象的生成　　132\n文件的解析　　133\n解析器的启动　　134\n第9章　语义分析（1）引用的消解　　135\n9.1　语义分析的概要　　136\n本章目的　　136\n抽象语法树的遍历　　137\n不使用Visitor 模式的抽象语法树的处理　　137\n基于Visitor 模式的抽象语法树的处理　　138\nVistor 模式的一般化　　140\ncbc 中Visitor 模式的实现　　141\n语义分析相关的cbc 的类　　142\n9.2　变量引用的消解　　144\n问题概要　　144\n实现的概要　　144\nScope 树的结构　　145\nLocalResolver 类的属性　　146\nLocalResolver 类的启动　　146\n变量定义的添加　　147\n函数定义的处理　　148\npushScope 方法　　149\ncurrentScope 方法　　149\npopScope 方法　　150\n添加临时作用域　　150\n建立VariableNode 和变量定义的关联　　151\n从作用域树取得变量定义　　151\n9.3　类型名称的消解　　153\n问题概要　　153\n实现的概要　　153\nTypeResolver 类的属性　　153\nTypeResolver 类的启动　　154\n类型的声明　　154\n类型和抽象语法树的遍历　　155\n变量定义的类型消解　　156\n函数定义的类型消解　　157\n第10章　语义分析（2）静态类型检查　　159\n10.1　类型定义的检查　　160\n问题概要　　160\n实现的概要　　161\n检测有向图中的闭环的算法　　162\n结构体、联合体的循环定义检查　　163\n10.2　表达式的有效性检查　　165\n问题概要　　165\n实现的概要　　165\nDereferenceChecker 类的启动　　166\nSemanticError 异常的捕获　　167\n非指针类型取值操作的检查　　167\n获取非左值表达式地址的检查　　168\n隐式的指针生成　　169\n10.3　静态类型检查　　170\n问题概要　　170\n实现的概要　　170\nCЬ中操作数的类型　　171\n隐式类型转换　　172\nTyperChecker 类的启动　　173\n二元运算符的类型检查　　174\n隐式类型转换的实现　　175\n第11章　中间代码的转换　　178\n11.1　cbc 的中间代码　　179\n组成中间代码的类　　180\n中间代码节点类的属性　　181\n中间代码的运算符和类型　　182\n各类中间代码　　183\n中间代码的意义　　184\n11.2　IRGenerator 类的概要　　185\n抽象语法树的遍历和返回值　　185\nIRGenerator 类的启动　　185\n函数本体的转换　　186\n作为语句的表达式的判别　　187\n11.3　流程控制语句的转换　　189\nif 语句的转换（1）概要　　189\nif 语句的转换（2）没有else 部分的情况　　190\nif 语句的转换（3）存在else 部分的情况　　191\nwhile 语句的转换　　191\nbreak 语句的转换（1）问题的定义　　192\nbreak 语句的转换（2）实现的方针　　193\nbreak 语句的转换（3）实现　　194\n11.4　没有副作用的表达式的转换　　196\nUnaryOpNode 对象的转换　　196\nBinaryOpNode 对象的转换　　197\n指针加减运算的转换　　198\n11.5　左值的转换　　200\n左边和右边　　200\n左值和右值　　200\ncbc 中左值的表现　　201\n结构体成员的偏移　　202\n成员引用（expr.memb）的转换　　203\n左值转换的例外：数组和函数　　204\n成员引用的表达式（ptr->memb）的转换　　205\n11.6　存在副作用的表达式的转换　　206\n表达式的副作用　　206\n有副作用的表达式的转换方针　　206\n简单赋值表达式的转换（1）语句　　207\n临时变量的引入　　208\n简单赋值表达式的转换（2）表达式　　209\n后置自增的转换　　210\n第3部分　汇编代码\n第12章　x86 架构的概要　　214\n12.1　计算机的系统结构　　215\nCPU 和存储器　　215\n寄存器　　215\n地址　　216\n物理地址和虚拟地址　　216\n各类设备　　217\n缓存　　218\n12.2　x86 系列CPU 的历史　　220\nx86 系列CPU　　220\n32 位CPU　　220\n指令集　　221\nIA-32 的变迁　　222\nIA-32 的64 位扩展——AMD64　　222\n12.3　IA-32 的概要　　224\nIA-32 的寄存器　　224\n通用寄存器　　225\n机器栈　　226\n机器栈的操作　　227\n机器栈的用途　　227\n栈帧　　228\n指令指针　　229\n标志寄存器　　229\n12.4　数据的表现形式和格式　　231\n无符号整数的表现形式　　231\n有符号整数的表现形式　　231\n负整数的表现形式和二进制补码　　232\n字节序　　233\n对齐　　233\n结构体的表现形式　　234\n第13章　x86 汇编器编程　　236\n13.1　基于GNU 汇编器的编程　　237\nGNU 汇编器　　237\n汇编语言的Hello, World!　　237\n基于GNU 汇编器的汇编代码　　238\n13.2　GNU 汇编器的语法　　240\n汇编版的Hello, World!　　240\n指令　　241\n汇编伪操作　　241\n标签　　241\n注释　　242\n助记符后缀　　242\n各种各样的操作数　　243\n间接内存引用　　244\nx86 指令集的概要　　245\n13.3　传输指令　　246\nmov 指令　　246\npush 指令和pop 指令　　247\nlea 指令　　248\nmovsx 指令和movzx 指令　　249\n符号扩展和零扩展　　250\n13.4　算术运算指令　　251\nadd 指令　　251\n进位标志　　252\nsub 指令　　252\nimul 指令　　252\nidiv 指令和div 指令　　253\ninc 指令　　254\ndec 指令　　255\nneg 指令　　255\n13.5　位运算指令　　256\nand 指令　　256\nor 指令　　257\nxor 指令　　257\nnot 指令　　257\nsal 指令　　258\nsar 指令　　258\nshr 指令　　259\n13.6　流程的控制　　260\njmp 指令　　260\n条件跳转指令（jz、jnz、je、jne、……）　　261\ncmp 指令　　262\ntest 指令　　263\n标志位获取指令（SETcc）　　263\ncall 指令　　264\nret 指令　　265\n第14章　函数和变量　　266\n14.1　程序调用约定　　267\n什么是程序调用约定　　267\nLinux/x86 下的程序调用约定　　267\n14.2　Linux/x86 下的函数调用　　269\n到函数调用完成为止　　269\n到函数开始执行为止　　270\n到返回原处理流程为止　　271\n到清理操作完成为止　　271\n函数调用总结　　272\n14.3　Linux/x86 下函数调用的细节　　274\n寄存器的保存和复原　　274\ncaller-save 寄存器和callee-save 寄存器　　274\ncaller-save 寄存器和callee-save 寄存器的灵活应用　　275\n大数值和浮点数的返回方法　　276\n其他平台的程序调用约定　　277\n第15章　编译表达式和语句　　278\n15.1　确认编译结果　　279\n利用cbc 进行确认的方法　　279\n利用gcc 进行确认的方法　　280\n15.2　x86 汇编的对象与DSL　　282\n表示汇编的类　　282\n表示汇编对象　　283\n15.3　cbc 的x86 汇编DSL　　285\n利用DSL 生成汇编对象　　285\n表示寄存器　　286\n表示立即数和内存引用　　287\n表示指令　　287\n表示汇编伪操作、标签和注释　　288\n15.4　CodeGenerator 类的概要　　290\nCodeGenerator 类的字段　　290\nCodeGenerator 类的处理概述　　290\n实现compileStmts 方法　　291\ncbc 的编译策略　　 292\n15.5　编译单纯的表达式　　294\n编译Int 节点　　294\n编译Str 节点　　294\n编译Uni 节点(1) 按位取反　　295\n编译Uni 节点(2) 逻辑非　　297\n15.6　编译二元运算　　298\n编译Bin 节点　　298\n实现compileBinaryOp 方法　　299\n实现除法和余数　　300\n实现比较运算　　300\n15.7　引用变量和赋值　　301\n编译Var 节点　　301\n编译Addr 节点　　302\n编译Mem 节点　　 303\n编译Assign 节点　　303\n15.8　编译jump 语句　　305\n编译LabelStmt 节点　　305\n编译Jump 节点　　305\n编译CJump 节点　　305\n编译Call 节点　　306\n编译Return 节点　　307\n第16章　分配栈帧　　308\n16.1　操作栈　　309\ncbc 中的栈帧　　309\n栈指针操作原则　　310\n函数体编译顺序　　310\n16.2　参数和局部变量的内存分配　　312\n本节概述　　312\n参数的内存分配　　312\n局部变量的内存分配：原则　　313\n局部变量的内存分配　　314\n处理作用域内的局部变量　　315\n对齐的计算　　316\n子作用域变量的内存分配　　316\n16.3　利用虚拟栈分配临时变量　　318\n虚拟栈的作用　　318\n虚拟栈的接口　　319\n虚拟栈的结构　　319\nvirtualPush 方法的实现　　320\nVirtualStack#extend 方法的实现　　320\nVirtualStack#top 方法的实现　　321\nvirtualPop 方法的实现　　321\nVirtualStack#rewind 方法的实现　　321\n虚拟栈的运作　　322\n16.4　调整栈访问的偏移量　　323\n本节概要　　323\nStackFrameInfo 类　　323\n计算正在使用的callee-save 寄存器　　324\n计算临时变量区域的大小　　325\n调整局部变量的偏移量　　325\n调整临时变量的偏移量　　326\n16.5　生成函数序言和尾声　　327\n本节概要　　327\n生成函数序言　　327\n生成函数尾声　　328\n16.6　alloca 函数的实现　　330\n什么是alloca 函数　　330\n实现原则　　330\nalloca 函数的影响　　331\nalloca ��数的实现　　331\n第17章　优化的方法 333\n17.1　什么是优化　　334\n各种各样的优化　　334\n优化的案例　　334\n常量折叠　　334\n代数简化　　335\n降低运算强度　　335\n削除共同子表达式　　335\n消除无效语句　　336\n函数内联　　336\n17.2　优化的分类　　337\n基于方法的优化分类　　337\n基于作用范围的优化分类　　337\n基于作用阶段的优化分类　　338\n17.3　cbc 中的优化　　339\ncbc 中的优化原则　　339\ncbc 中实现的优化　　339\ncbc 中优化的实现　　339\n17.4　更深层的优化　　341\n基于模式匹配选择指令　　341\n分配寄存器　　342\n控制流分析　　342\n大规模的数据流分析和SSA 形式　　342\n总结　　343\n第4部分　链接和加载\n第18章　生成目标文件 346\n18.1　ELF 文件的结构　　347\nELF 的目的　　347\nELF 的节和段　　348\n目标文件的主要ELF 节　　348\n使用readelf 命令输出节头　　349\n使用readelf 命令输出程序头　　350\n使用readelf 命令输出符号表　　351\nreadelf 命令的选项　　351\n什么是DWARF 格式　　352\n18.2　全局变量及其在ELF 文件中的表示　　354\n分配给任意ELF 节　　354\n分配给通用ELF 节　　354\n分配.bss 节　　355\n通用符号　　355\n记录全局变量对应的符号　　357\n记录符号的附加信息　　357\n记录通用符号的附加信息　　358\n总结　　358\n18.3　编译全局变量　　360\ngenerate 方法的实现　　360\ngenerateAssemblyCode 方法的实现　　360\n编译全局变量　　361\n编译立即数　　362\n编译通用符号　　363\n编译字符串字面量　　364\n生成函数头　　365\n计算函数的代码大小　　366\n总结　　366\n18.4　生成目标文件　　367\nas 命令调用的概要　　367\n引用GNUAssembler 类　　367\n调用as 命令　　367\n第19章　链接和库　　369\n19.1　链接的概要　　370\n链接的执行示例　　370\ngcc 和GNU ld　　371\n链接器处理的文件　　372\n常用库　　374\n链接器的输入和输出　　374\n19.2　什么是链接　　375\n链接时进行的处理　　375\n合并节　　375\n重定位　　376\n符号消解　　377\n19.3　动态链接和静态链接　　379\n两种链接方法　　379\n动态链接的优点　　379\n动态链接的缺点　　380\n动态链接示例　　380\n静态链接示例　　381\n库的检索规则　　381\n19.4　生成库　　383\n生成静态库　　383\nLinux 中共享库的管理　　383\n生成共享库　　384\n链接生成的共享库　　385\n第20章　加载程序　　387\n20.1 加载ELF 段　　388\n利用mmap 系统调用进行文件映射　　388\n进程的内存镜像　　389\n内存空间的属性　　390\nELF 段对应的内存空间　　390\n和ELF 文件不对应的内存空间　　392\nELF 文件加载的实现　　393\n20.2　动态链接过程　　395\n动态链接加载器　　395\n程序从启动到终止的过程　　395\n启动ld.so　　396\n系统内核传递的信息　　397\nAUX 矢量　　397\n读入共享库　　398\n符号消解和重定位　　399\n运行初始化代码　　400\n执行主程序　　401\n执行终止处理　　402\nld.so 解析的环境变量　　402\n20.3　动态加载　　404\n所谓动态加载　　404\nLinux 下的动态加载　　404\n动态加载的架构　　405\n20.4　GNU ld 的链接　　406\n用于cbc 的ld 选项的结构　　406\nC 运行时　　407\n生成可执行文件　　408\n生成共享库　　408\n第21章　生成地址无关代码　　410\n21.1　地址无关代码　　411\n什么是地址无关代码　　411\n全局偏移表（GOT）　　412\n获取GOT 地址　　412\n使用GOT 地址访问全局变量　　413\n访问使用GOT 地址的文件内部的全局变量　　414\n过程链接表（PLT）　　414\n调用PLT 入口　　416\n地址无关的可执行文件：PIE　　416\n21.2　全局变量引用的实现　　418\n获取GOT 地址　　418\nPICThunk 函数的实现　　418\n删除重复函数并设置不可见属性　　419\n加载GOT 地址　　420\nlocateSymbols 函数的实现　　421\n全局变量的引用　　421\n访问全局变量：地址无关代码的情况下　　 422\n函数的符号　　423\n字符串常量的引用　　424\n21.3　链接器调用的实现　　425\n生成可执行文件　　425\ngenerateSharedLibrary 方法　　426\n21.4　从程序解析到执行　　428\nbuild 和加载的过程　　428\n词法分析　　429\n语法分析　　429\n生成中间代码　　430\n生成代码　　431\n汇编　　432\n生成共享库　　432\n生成可执行文件　　433\n加载　　433\n第22章　扩展阅读　　434\n22.1 参考书推荐　　435\n编译器相关　　435\n语法分析相关　　435\n汇编语言相关　　436\n22.2 链接、加载相关　　437\n22.3 各种编程语言的功能　　438\n异常封装相关的图书　　438\n垃圾回收　　438\n垃圾回收相关的图书　　439\n面向对象编程语言的实现　　439\n函数式语言　　440\n附　　录　　441\nA.1 参考文献　　442\nA.2 在线资料　　444\nA.3 源代码　　445",
    "pages": "472",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28768045.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28768045.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28768045.jpg"
    },
    "alt": "https://book.douban.com/subject/26806041/",
    "id": "26806041",
    "publisher": "人民邮电出版社",
    "isbn10": "7115422184",
    "isbn13": "9787115422187",
    "title": "自制编译器",
    "url": "https://api.douban.com/v2/book/26806041",
    "alt_title": "",
    "author_intro": "作者简介：\n青木峰郎\n程序员，著有《Ruby程序设计268技（第2版）》《Ruby源代码完全解说》《Linux程序设计》等多部编程相关著作。并积极参与标准库维护、文档维护等各种各样的活动。\n译者简介：\n严圣逸\n毕业于上海交通大学。8年软件开发经验，期间赴日本工作。现就职于想能信息科技（上海）有限公司，从事基于云平台的客户关系管理及各类营销自动化系统的开发工作。译有《高效团队开发：工具与方法》。\n\n绝云\n毕业于清华大学软件学院。曾在日本创意公司KAYAC从事即时通讯软件及社交游戏的开发工作，现任蚂蚁金服前端架构专家。译有《图解简单算法》等图书，曾参与《像外行一样思考，像专家一样实践（修订版）》的审校。",
    "summary": "本书将带领读者从头开始制作一门语言的编译器。笔者特意为本书设计了CЬ语言，CЬ可以说是C语言的子集，实现了包括指针运算等在内的C语言的主要部分。本书所实现的编译器就是C Ь语言的编译器， 是实实在在的编译器，而非有诸多限制的玩具。另外，除编译器之外，本书对以编译器为中心的编程语言的运行环境，即编译器、汇编器、链接器、硬件、运行时环境等都有所提及，介绍了程序运行的所有环节。",
    "series": { "id": "34137", "title": "自制系列" },
    "price": "99.00元"
  },
  "9787115394095": {
    "rating": { "max": 10, "numRaters": 341, "average": "8.0", "min": 0 },
    "subtitle": "",
    "author": ["[日] 大塚弘记"],
    "pubdate": "2015-7",
    "tags": [
      { "count": 457, "name": "GitHub", "title": "GitHub" },
      { "count": 201, "name": "编程", "title": "编程" },
      { "count": 185, "name": "计算机", "title": "计算机" },
      { "count": 105, "name": "软件开发", "title": "软件开发" },
      { "count": 95, "name": "IT", "title": "IT" },
      { "count": 90, "name": "github", "title": "github" },
      { "count": 81, "name": "软件工程", "title": "软件工程" },
      { "count": 78, "name": "版本控制", "title": "版本控制" }
    ],
    "origin_title": "GitHub実践入門",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28147406.jpg",
    "binding": "平装",
    "translator": ["支鹏浩", "刘斌"],
    "catalog": "第1章　欢迎来到GitHub的世界　　1\n1.1　什么是GitHub　　2\nGitHub公司与octocat　　2\n并不只是Git仓库的托管服务　　3\nGitHub的使用情况　　3\nColumn 专栏：GitHub与Git的区别　　4\n1.2　使用GitHub会带来哪些变化　　4\n协作形式变化　　4\n在开发者之间引发化学反应的Pull Request　　5\n对特定用户进行评论　　6\nGitHub Flavored Markdown　　7\nColumn 专栏：还可以这样写!!　　7\n能看到更多其他团队的软件　　7\n与开源软件相同的开发模式　　8\n1.3　社会化编程　　9\n1.4　为什么需要社会化编程　　10\n不要闭目塞听，要接触不同的文化　　10\n会写代码的程序员更受青睐　　11\nGitHub最大的特征是“面向人”　　11\n1.5　GitHub提供的主要功能　　12\nGit仓库　　12\nOrganization　　12\nIssue　　13\nWiki　　13\nPull Request　　13\nColumn 专栏：GitHub上受到瞩目的软件　　14\n1.6　小结　　14\n参考资料　　14\n第2章　Git的导入　　17\n2.1　诞生背景　　18\n2.2　什么是版本管理　　18\n集中型与分散型　　19\n集中型　　19\n分散型　　19\n集中型与分散型哪个更好　　20\n2.3　安装　　21\nMac与Linux　　21\nWindows　　21\n组件的选择　　22\n设置环境变量　　22\n换行符的处理　　23\nGit Bash　　23\n本书所用的环境　　24\n2.4　初始设置　　24\n设置姓名和邮箱地址　　24\n提高命令输出的可读性　　25\n2.5　小结　　25\n第3章　使用GitHub的前期准备　　27\n3.1　使用前的准备　　28\n创建账户　　28\n设置头像　　29\n设置SSH Key　　29\n添加公开密钥　　30\n使用社区功能　　31\n3.2　实际动手使用　　31\n创建仓库　　31\nRepository name　　32\nDescription　　32\nPublic、Private　　32\nInitialize this repository with a README　　32\nAdd .gitignore　　33\nAdd a license　　33\n连接仓库　　33\nREADME.md　　33\nGitHub Flavored Markdown　　34\n公开代码　　34\nclone已有仓库　　34\n编写代码　　35\n提交　　36\nColumn 专栏：公开时的许可协议　　37\n进行push　　37\n3.3　小结　　38\n第4章　通过实际操作学习Git　　39\n4.1　基本操作　　40\ngit init——初始化仓库　　40\ngit status——查看仓库的状态　　40\ngit add——向暂存区中添加文件　　41\ngit commit——保存仓库的历史记录　　42\n记述一行提交信息　　42\n记述详细提交信息　　42\n中止提交　　43\n查看提交后的状态　　43\ngit log——查看提交日志　　43\n只显示提交信息的第一行　　44\n只显示指定目录、文件的日志　　44\n显示文件的改动　　45\ngit diff——查看更改前后的差别　　45\n查看工作树和暂存区的差别　　45\n查看工作树和最新提交的差别　　46\n4.2　分支的操作　　47\ngit branch——显示分支一览表　　48\ngit checkout -b——创建、切换分支　　48\n切换到feature-A分支并进行提交　　48\n切换到master分支　　49\n切换回上一个分支　　50\n特性分支　　50\n主干分支　　51\ngit merge——合并分支　　51\ngit log --graph——以图表形式查看分支　　52\n4.3　更改提交的操作　　53\ngit reset——回溯历史版本　　53\n回溯到创建feature-A分支前　　53\n创建fix-B分支　　54\n推进至feature-A分支合并后的状态　　55\n消除冲突　　56\n查看冲突部分并将其解决　　57\n提交解决后的结果　　57\ngit commit --amend——修改提交信息　　58\ngit rebase -i——压缩历史　　59\n创建feature-C分支　　59\n修正拼写错误　　60\n更改历史　　61\n合并至master分支　　63\n4.4　推送至远程仓库　　63\ngit remote add——添加远程仓库　　64\ngit push——推送至远程仓库　　64\n推送至master分支　　64\n推送至master以外的分支　　65\n4.5　从远程仓库获取　　65\ngit clone——获取远程仓库　　65\n获取远程仓库　　65\n获取远程的feature-D分支　　66\n向本地的feature-D分支提交更改　　67\n推送feature-D分支　　67\ngit pull——获取最新的远程仓库分支　　67\n4.6　帮助大家深入理解Git的资料　　68\nPro Git　　68\nLearnGitBranching　　69\ntryGit　　69\n4.7　小结　　70\n第5章　详细解说GitHub的功能　　71\n5.1　键盘快捷键　　72\n5.2　工具栏　　73\n关于UI　　73\n1LOGO　　73\n2Notifications　　73\n3 搜索窗口　　73\n4Explore　　73\n5Gist　　74\n6Blog　　74\n7Help　　74\n8 头像、用户名　　74\n9 Create a new　　74\nAccount settings　　75\nSign out　　75\n5.3　控制面板　　75\n关于UI　　75\n①News Feed　　76\n②Pull Requests　　76\n③Issues　　76\n④Stars　　76\n⑤Broadcast　　76\n⑥Repositories you contribute to　　76\n⑦Your Repositories　　76\n5.4　个人信息　　77\n关于UI　　77\n1 用户信息　　77\n2Popular Repositories　　78\n3Repositories contributed to　　78\n4Public contributions　　78\n5Contribution Activity　　78\n6Repositories　　78\n7Public Activity　　79\n5.5　仓库　　80\n关于UI　　80\n①用户名（组织名）/仓库名　　80\n②Watch/Star/Fork　　80\n③Code　　81\n④Issue　　81\n⑤Pull Requests　　81\n⑥Wiki　　82\n⑦Pulse　　82\n⑧Graphs　　82\n⑨Network　　82\n⑩Settings　　82\n⑪SSH clone URL　　82\n⑫Clone in Desktop　　82\n⑬Download ZIP　　83\nacommits　　83\nbbranches　　83\ncreleases　　83\ndcontributors　　83\neCompare & review　　83\nfbranch　　83\ngpath　　84\nhFork this project and Create a new file　　84\nifiles　　84\n文件的相关操作　　84\nColumn专栏：通过部分名称搜索文件　　85\n查看差别　　85\n查看分支间的差别　　85\n查看与几天前的差别　　86\n查看与指定日期之间的差别　　87\n5.6　Issue　　87\n简洁且表现力丰富的描述方法　　88\n语法高亮　　89\n添加图片　　90\n添加标签以便整理　　90\n添加里程碑以便管理　　91\nColumn 专栏：了解贡献时的规则！　　92\nTasklist语法　　92\n通过提交信息操作Issue　　93\n在相关Issue中显示提交　　93\nClose Issue　　93\n将特定的Issue转换为Pull Request　　94\n5.7　Pull Request　　94\nColumn 专栏：获取diff格式与patch格式的文件　　96\nConversation　　96\nColumn 专栏：引用评论　　96\nCommits　　97\nColumn 专栏：在评论中应用表情　　98\nFiles Changed　　98\n5.8　Wiki　　99\nPages　　100\nHistory　　101\nColumn 专栏：在Wiki中显示侧边栏　　101\n5.9　Pulse　　102\nactive pull requests　　103\nactive issue　　103\ncommits　　104\nReleases published　　104\nUnresolved Conversations　　104\n5.10　Graphs　　105\nContributors　　105\nCommit Activity　　106\nCode Frequency　　106\nPunchcard　　108\n5.11　Network　　108\n5.12　Settings　　109\nOptions　　109\n①Settings　　109\n②Features　　110\n③GitHub Pages　　111\n④Danger Zone　　111\nCollaborators　　111\nWebhooks & Services　　112\nDeploy Keys　　112\n5.13　Notifications　　112\n5.14　其他功能　　114\nGitHub Pages　　114\nGitHub Jobs　　114\nGitHub Enterprise　　114\nGitHub API　　115\n5.15　小结　　115\nColumn 专栏：在Mac的通知中心查看GitHub的Notifications　　115\n第6章　尝试Pull Request　　117\n6.1　Pull Request的概要　　118\n什么是Pull Request　　118\nPull Request的流程　　118\n6.2　发送Pull Request前的准备　　119\n查看要修正的源代码　　120\nFork　　120\nclone　　120\nbranch　　121\n为何要在特性分支中进行作业　　121\n确认分支　　121\n创建特性分支　　121\n添加代码　　122\n提交修改　　122\n创建远程分支　　123\n6.3　发送Pull Request　　123\n6.4　让Pull Request更加有效的方法　　126\n在开发过程中发送Pull Request进行讨论　　126\n明确标出“正在开发过程中”　　127\n不进行Fork直接从分支发送Pull Request　　128\n6.5　仓库的维护　　128\n仓库的Fork与clone　　129\n给原仓库设置名称　　129\n获取最新数据　　130\n6.6　小结　　130\n第7章　接收Pull Request　　131\n7.1　采纳Pull Request的方法　　132\n7.2　采纳Pull Request前的准备　　133\n代码审查　　133\n查看图片的差别　　134\n2-up　　134\nSwipe　　135\nOnion Skin　　135\nDifference　　136\n在本地开发环境中反映Pull Request的内容　　136\n将接收方的本地仓库更新至最新状态　　136\n获取发送方的远程仓库　　137\n创建用于检查的分支　　138\n合并　　138\n删除分支　　139\nColumn 专栏：如何提升代码管理技术　　139\n7.3　采纳Pull Request　　139\n合并到主分支　　140\npush修改内容　　141\n7.4　小结　　142\nColumn 专栏：请协助我们共同创建互相学习的场所　　142\n第8章　与GitHub相互协作的工具及服务　　143\n8.1　hub命令　　144\n概要　　144\n安装　　144\n安装　　145\n确认运行情况　　145\n设置别名　　145\n实现shell上的功能补全　　146\n~/.config/hub　　146\n命令　　146\nhub clone　　146\nhub remote add　　147\nhub fetch　　147\nhub cherry-pick　　147\nhub fork　　148\nhub pull-request　　148\nhub checkout　　148\nhub create　　149\nhub push　　149\nhub browse　　150\nhub compare　　150\nColumn 专栏：让GitHub Enterprise支持hub命令　　151\n8.2　Travis CI　　151\n概要　　151\n实际尝试　　152\n编写配置文件　　152\n检测配置文件是否有问题　　152\n与GitHub集成　　153\n将Travis CI的结果添加至README.md　　155\n8.3　Coveralls　　156\n概要　　156\n安装　　157\n注册　　157\n添加对象仓库　　158\n编写配置文件　　158\n添加gem　　159\n查看报告　　160\n8.4　Gemnasium　　160\n8.5　Code Climate　　161\n8.6　Jenkins　　162\n概要　　162\n安装　　164\n创建bot账户　　165\nbot账户的权限设置　　165\n对象为个人账户时　　165\n对象为Organization账户时　　165\n检查设置　　167\n给Jenkins设置SSH密钥　　167\n初次使用Jenkins时　　167\n已经在使用Jenkins时　　168\nGitHub pull request builder plugin的安装　　169\nGit plugin的设置　　170\nGithub Pull Requests Builder的设置　　170\nGithub server api URL　　171\nAccess Token　　171\nAdmin list　　172\njob的创建与设置　　172\nGitHub project　　172\n源码管理　　172\n构建触发器　　173\n构建　　174\n通知结果　　174\n测试执行中的状态　　175\nFailed　　175\nAll is well　　175\ncommit status　　175\n通过评论进行控制　　176\n执行任务　　176\n添加至White list　　176\n重新执行任务　　176\n变更指定评论　　177\n8.7　小结　　177\nColumn 专栏：用Coderwall生成GitHub上的个人信息　　178\n第9章　使用GitHub的开发流程　　179\n9.1　团队使用GitHub时的注意事项　　180\n一切从简　　180\n项目管理工具与GitHub的区别　　180\n项目管理工具与GitHub相异的原因　　181\n不Fork仓库的方法　　182\n9.2　GitHub Flow——以部署为中心的开发模式　　183\n9.3　GitHub Flow的流程　　184\n随时部署，没有发布的概念　　184\n进行新的作业时要从master分支创建新分支　　185\n在新创建的分支中进行提交　　186\n定期push　　186\n使用Pull Request　　187\n务必让其他开发者进行审查　　187\n合并后立刻部署　　187\n9.4　实践GitHub Flow的前提条件　　188\n部署作业完全自动化　　188\n使用部署工具　　189\n通过Web界面进行部署的工具　　189\n导入开发时的注意事项　　190\n重视测试　　190\n让测试自动化　　190\n编写测试代码，通过全部测试　　190\n维护测试代码　　190\n9.5　模拟体验GitHub Flow　　191\nFizzbuzz的说明　　191\n添加新功能　　192\n创建新的分支　　192\n如果尚未clone仓库　　192\n如果之前clone过仓库　　193\n创建特性分支　　193\n实现新功能　　194\n创建Pull Request　　196\n接收反馈　　196\n修正缩进　　197\n添加测试　　199\n培育Pull Request　　202\nPull Request被合并　　202\n9.6　团队实践GitHub Flow时的几点建议　　203\n减小Pull Request的体积　　204\n准备可供试运行的环境　　204\n不要让Pull Request中有太多反馈　　205\n不要积攒Pull Request　　206\n9.7　GitHub Flow的小结　　206\n9.8　Git Flow——以发布为中心的开发模式　　207\n便于理解的标准流程　　207\n有时显得过于复杂　　209\n9.9　导入Git Flow前的准备　　209\n安装git-flow　　209\nMac下的安装　　209\nLinux下的安装　　210\n确认运行状况　　210\n仓库的初始设置　　210\n创建仓库　　210\n进行git flow的初始设置　　211\n在远程仓库中也创建develop分支　　212\n9.10　模拟体验Git Flow　　212\nmaster分支与develop分支的区别　　213\nmaster分支　　213\ndevelop分支　　213\n在feature中进行的工作　　213\n创建分支　　214\n在分支中进行作业　　215\n发送Pull Request　　216\n通过代码审查提高代码质量　　217\n更新本地的develop分支　　219\n在release分支中进行的工作　　220\nColumn 专栏：设置默认分支　　220\n创建分支　　221\n分支内的工作　　222\n进行发布与合并　　222\n查看版本标签　　224\n更新到远程仓库　　225\n在hotfix分支中进行的工作　　226\n创建分支　　226\n创建标签和进行发布　　228\n从hotfix分支合并至develop分支　　230\n9.11　Git Flow的小结　　232\nColumn 专栏：版本号的分配规则　　232\n第10章　将GitHub应用到企业　　233\n10.1　将世界标准的开发环境引入企业现场　　234\n企业引入GitHub的好处　　234\n使用Organization　　235\n确认Github的安全性　　235\n注意维护时间　　235\n查看故障信息　　236\n10.2　GitHub Enterprise　　237\n概述　　238\n引入的好处　　238\n引入的弊端　　239\n适合引入GitHub Enterprise的几种情况　　239\n源代码不可外传　　239\nColumn 专栏：将GitHub的仓库作为Subversion仓库使用　　240\n希望维护与故障时间可控　　240\n10.3　能实现Git托管的软件　　241\nColumn 专栏：Bitbucket　　241\n10.4　小结　　242\n附录A　支持GitHub的GUI客户端　　243\nA.1　GitHub for Mac，GitHub for Windows　　244\nA.2　SourceTree　　246\n附录B　通过Gist轻松实现代码共享　　247\nB.1　Gist的特点　　248\nB.2　创建Gist　　248\nUI讲解　　249\n1　Gist description　　249\n2　name this file　　　　249\n3���language　　250\n4　ACE Editor 　　250\n5　文件　　250\n6　Add another File　　251\n7　Create Secret Gist　　251\n8　Create Public Gist　　251\nB.3　查看Gist　　252\nGist 的菜单　　252\n①Gist Detail　　253\n②Revisions　　253\n③Download Gist　　253\n④Clone this gist　　253\n⑤Embed this gist　　253\n⑥Link to this gist 　　253\n文件的菜单 　　254\nB.4　Your Gists 　　254\nB.5　小结　　255",
    "pages": "280",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28147406.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28147406.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28147406.jpg"
    },
    "alt": "https://book.douban.com/subject/26462816/",
    "id": "26462816",
    "publisher": "人民邮电出版社",
    "isbn10": "7115394091",
    "isbn13": "9787115394095",
    "title": "GitHub入门与实践",
    "url": "https://api.douban.com/v2/book/26462816",
    "alt_title": "GitHub実践入門",
    "author_intro": "大塚弘记\n将敏捷软件开发导入开发现场的领军人物，以顾问身份就Web应用的开发及服务指导过多家企业和团队。曾为多家企业和团队导入GitHub，在建立一天之内多次部署的开发体制方面拥有丰富经验。",
    "summary": "本书从Git的基本知识和操作方法入手，详细介绍了GitHub的各种功能，GitHub与其他工具或服务的协作，使用GitHub的开发流程以及如何将GitHub引入到企业中。在讲解GitHub的代表功能Pull Request时，本书专门搭建了供各位读者实践的仓库，邀请各位读者进行Pull Request并共同维护。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "39.00元"
  },
  "9787115317513": {
    "rating": { "max": 10, "numRaters": 799, "average": "7.8", "min": 0 },
    "subtitle": "代码的未来",
    "author": ["[日] 松本行弘"],
    "pubdate": "2013-6",
    "tags": [
      { "count": 548, "name": "编程", "title": "编程" },
      { "count": 419, "name": "松本行弘", "title": "松本行弘" },
      { "count": 312, "name": "计算机", "title": "计算机" },
      { "count": 271, "name": "编程语言", "title": "编程语言" },
      { "count": 166, "name": "计算机科学", "title": "计算机科学" },
      { "count": 132, "name": "软件开发", "title": "软件开发" },
      { "count": 129, "name": "Programming", "title": "Programming" },
      { "count": 115, "name": "程序员", "title": "程序员" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s26393136.jpg",
    "binding": "平装",
    "translator": ["周自恒"],
    "catalog": "第一章 编程的时间和空间\n1.1 　编程的本质　　3\n编程的本质是思考　　4\n创造世界的乐趣　　4\n快速提高的性能改变了社会　　5\n以不变应万变　　8\n摩尔定律的局限　　9\n社会变化与编程　　10\n1.2 　未来预测　　13\n科学的未来预测　　14\nIT 未来预测　　14\n极限未来预测　　16\n从价格看未来　　16\n从性能看未来　　17\n从容量看未来　　18\n从带宽看未来　　19\n小结　　20\n第二章　编程语言的过去、现在和未来\n2.1 　编程语言的世界　　23\n被历史埋没的先驱　　25\n编程语言的历史　　26\n编程语言的进化方向　　30\n未来的编程语言　　32\n20 年后的编程语言　　34\n学生们的想象　　34\n2.2 　DSL（特定领域语言）　　36\n外部DSL　　37\n内部DSL　　38\nDSL 的优势　　39\nDSL 的定义　　39\n适合内部DSL 的语言　　40\n外部DSL 实例　　42\nDSL 设计的构成要素　　43\nSinatra　　46\n小结　　47\n2.3 　元编程　　48\nMeta, Reflection　　48\n类对象　　51\n类的操作　　52\nLisp　　53\n数据和程序　　54\nLisp 程序　　56\n宏　　56\n宏的功与过　　57\n元编程的可能性与危险性　　59\n小结　　60\n2.4 　内存管理　　61\n看似无限的内存　　61\nGC 的三种基本方式　　62\n术语定义　　62\n标记清除方式　　63\n复制收集方式　　64\n引用计数方式　　65\n引用计数方式的缺点　　65\n进一步改良的应用方式　　66\n分代回收　　66\n对来自老生代的引用进行记录　　67\n增量回收　　68\n并行回收　　69\nGC 大统一理论　　69\n2.5 　异常处理　　71\n“一定没问题的”　　71\n用特殊返回值表示错误　　72\n容易忽略错误处理　　72\nRuby 中的异常处理　　73\n产生异常　　74\n更高级的异常处理　　75\nRuby 中的后处理保证　　76\n其他语言中的异常处理　　77\nJava 的检查型异常　　77\nIcon 的异常和真假值　　78\nEiffel 的Design by Contract　　80\n异常与错误值　　80\n小结　　81\n2.6 　闭包　　82\n函数对象　　82\n高阶函数　　83\n用函数参数提高通用性　　84\n函数指针的局限　　85\n作用域：变量可见范围　　87\n生存周期：变量的存在范围　　88\n闭包与面向对象　　89\nRuby 的函数对象　　89\nRuby 与JavaScript 的区别　　90\nLisp-1 与Lisp-2　　91\n第三章　编程语言的新潮流\n3.1 　语言的设计　　97\n客户端与服务器端　　97\n向服务器端华丽转身　　98\n在服务器端获得成功的四大理由　　99\n客户端的JavaScript　　100\n性能显著提升　　101\n服务器端的Ruby　　102\nRuby on Rails 带来的飞跃　　102\n服务器端的Go　　103\n静态与动态　　104\n动态运行模式　　105\n何谓类型　　105\n静态类型的优点　　106\n动态类型的优点　　106\n有鸭子样的就是鸭子　　107\nStructural Subtyping　　108\n小结　　108\n3.2 　Go　　109\nNew（新的）　　109\nExperimental（实验性的）　　109\nConcurrent（并发的）　　110\nGarbage-collected（带垃圾回收的）　　110\nSystems（系统）　　111\nGo 的创造者们　　111\nHello World　　112\nGo 的控制结构　　113\n类型声明　　116\n无继承式面向对象　　118\n多值与多重赋值　　120\n并发编程　　122\n小结　　124\n3.3 　Dart　　126\n为什么要推出Dart ？　　126\nDart 的设计目标　　129\n代码示例　　130\nDart 的特征　　132\n基于类的对象系统　　132\n非强制性静态类型　　133\nDart 的未来　　134\n3.4 　CoffeeScript　　135\n最普及的语言　　135\n被误解最多的语言　　135\n显著高速化的语言　　136\n对JavaScript 的不满　　138\nCoffeeScript　　138\n安装方法　　139\n声明和作用域　　139\n分号和代码块　　141\n省略记法　　142\n字符串　　143\n数组和循环　　143\n类　　145\n小结　　146\n3.5 　Lua　　148\n示例程序　　149\n数据类型　　149\n函数　　150\n表　　150\n元表　　151\n方法调用的实现　　153\n基于原型编程　　155\n和Ruby 的比较（语言篇）　　157\n嵌入式语言Lua　　157\n和Ruby 的比较（实现篇）　　158\n嵌入式Ruby　　159\n第四章　云计算时代的编程\n4.1 　可扩展性　　163\n信息的尺度感　　163\n大量数据的查找　　164\n二分法查找　　165\n散列表　　167\n布隆过滤器　　169\n一台计算机的极限　　170\nDHT（分布式散列表）　　171\nRoma　　172\nMapReduce　　173\n小结　　174\n4.2 　C10K 问题　　175\n何为C10K 问题　　175\nC10K 问题所引发的“想当然”　　177\n使用epoll 功能　　180\n使用libev 框架　　181\n使用EventMachine　　183\n小结　　185\n4.3 　HashFold　　186\nHashFold 库的实现（Level 1）　　187\n运用多核的必要性　　190\n目前的Ruby 实现所存在的问题　　191\n通过进程来实现HashFold（Level 2）　　191\n抖动　　193\n运用进程池的HashFold（Level 3）　　194\n小结　　197\n4.4 　进程间通信　　198\n进程与线程　　198\n同一台计算机上的进程间通信　　199\nTCP　　IP 协议　　201\n用C 语言进行套接字编程　　202\n用Ruby 进行套接字编程　　204\nRuby 的套接字功能　　205\n用Ruby 实现网络服务器　　208\n小结　　209\n4.5　Rack 与Unicorn　　210\nRack 中间件　　211\n应用程序服务器的问题　　212\nUnicorn 的架构　　215\nUnicorn 的解决方案　　215\n性能　　219\n策略　　220\n小结　　221\n第五章　支撑大数据的数据存储技术\n5.1 　键- 值存储　　225\nHash 类　　225\nDBM 类　　226\n数据库的ACID 特性　　226\nCAP 原理　　227\nCAP 解决方案——BASE　　228\n不能舍弃可用性　　229\n大规模环境下的键- 值存储　　230\n访问键- 值存储　　230\n键- 值存储的节点处理　　231\n存储器　　232\n写入和读取　　233\n节点追加　　233\n故障应对　　233\n终止处理　　235\n其他机制　　235\n性能与应用实例　　236\n小结　　236\n5.2 　NoSQL　　237\nRDB 的极限　　237\nNoSQL 数据库的解决方案　　238\n形形色色的NoSQL 数据库　　239\n面向文档数据库　　240\nMongoDB 的安装　　241\n启动数据库服务器　　243\nMongoDB 的数据库结构　　244\n数据的插入和查询　　244\n用JavaScript 进行查询　　245\n高级查询　　246\n数据的更新和删除　　249\n乐观并发控制　　250\n5.3 　用Ruby 来操作MongoDB　　251\n使用Ruby 驱动　　251\n对数据库进行操作　　253\n数据的插入　　253\n数据的查询　　253\n高级查询　　254\nfind 方法的选项　　256\n原子操作　　257\nActiveRecord　　259\nOD Mapper　　260\n5.4 　SQL 数据库的反击　　264\n“云”的定义　　264\nSQL 数据库的极限　　264\n存储引擎Spider　　265\nSQL 数据库之父的反驳　　265\nSQL 数据库VoltDB　　268\nVoltDB 的架构　　269\nVoltDB 中的编程　　270\nHello VoltDB!　　271\n性能测试　　273\n小结　　275\n5.5 　memcached 和它的伙伴们　　276\n用于高速访问的缓存　　276\nmemcached　　277\n示例程序　　278\n对memcached 的不满　　279\nmemcached 替代服务器　　280\n另一种键- 值存储Redis　　282\nRedis 的数据类型　　284\nRedis 的命令与示例　　285\n小结　　289\n第六章　多核时代的编程\n6.1 　摩尔定律　　293\n呈几何级数增长　　293\n摩尔定律的内涵　　294\n摩尔定律的结果　　295\n摩尔定律所带来的可能性　　296\n为了提高性能　　297\n摩尔定律的极限　　302\n超越极限　　303\n不再有免费的午餐　　304\n6.2 　UNIX 管道　　305\n管道编程　　306\n多核时代的管道　　308\nxargs——另一种运用核心的方式　　309\n注意瓶颈　　311\n阿姆达尔定律　　311\n多核编译　　312\nccache　　313\ndistcc　　313\n编译性能测试　　314\n小结　　315\n6.3 　非阻塞I/O　　316\n何为非阻塞I　　O　　316\n使用read(2) 的方法　　317\n边沿触发与电平触发　　319\n使用read(2) + select 的方法　　319\n使用read+O_NONBLOCK 标志　　321\nRuby 的非阻塞I　　O　　322\n使用aio_read 的方法　　323\n6.4 　node.js　　330\n减负　　330\n拖延　　331\n委派　　332\n非阻塞编程　　333\nnode.js 框架　　333\n事件驱动编程　　334\n事件循环的利弊　　335\nnode.js 编程　　335\nnode.js 网络编程　　337\nnode.js 回调风格　　339\nnode.js 的优越性　　340\nEventMachine 与Rev　　341\n6.5 　ZeroMQ　　342\n多CPU 的必要性　　342\n阿姆达尔定律　　343\n多CPU 的运用方法　　343\n进程间通信　　345\n管道　　345\nSysV IPC　　346\n套接字　　347\nUNIX 套接字　　349\nZeroMQ　　349\nZeroMQ 的连接模型　　350\nZeroMQ 的安装　　352\nZeroMQ 示例程序　　352\n小结　　354\n版权声明　　356",
    "ebook_url": "https://read.douban.com/ebook/3208566/",
    "pages": "356",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s26393136.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s26393136.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s26393136.jpg"
    },
    "alt": "https://book.douban.com/subject/24536403/",
    "id": "24536403",
    "publisher": "人民邮电出版社",
    "isbn10": "7115317518",
    "isbn13": "9787115317513",
    "title": "代码的未来",
    "url": "https://api.douban.com/v2/book/24536403",
    "alt_title": "",
    "author_intro": "松本行弘（Yukihiro Matsumoto）\nRuby语言发明者，亦是亚洲首屈一指的编程语言发明者。现兼任网络应用通信研究所（NaCl）研究员、乐天技术研究所研究员、Heroku首席架构师等。昵称“Matz”。讨厌东京，喜欢温泉。\n译者简介：\n周自恒\nIT、编程爱好者，技术宅，初中时曾在NOI（国家信息学奥赛）天津赛区获一等奖，大学毕业后曾任IT咨询顾问，精通英语和日语，译著有《30天自制操作系统》、《大数据的冲击》、《Android应用开发入门》。",
    "summary": "《代码的未来》是Ruby之父松本行弘的又一力作。作者对云计算、大数据时代下的各种编程语言以及相关技术进行了剖析，并对编程语言的未来发展趋势做出预测，内容涉及Go、VoltDB、node.js、CoffeeScript、Dart、MongoDB、摩尔定律、编程语言、多核、NoSQL等当今备受关注的话题。\n　　《代码的未来》面向各层次程序设计人员和编程爱好者，也可供相关技术人员参考。",
    "ebook_price": "40.00",
    "price": "79.00元"
  },
  "9787115404404": {
    "rating": { "max": 10, "numRaters": 495, "average": "8.8", "min": 0 },
    "subtitle": "",
    "author": ["Robin Williams"],
    "pubdate": "2016-1",
    "tags": [
      { "count": 381, "name": "设计", "title": "设计" },
      { "count": 153, "name": "艺术/设计", "title": "艺术/设计" },
      { "count": 137, "name": "入门", "title": "入门" },
      { "count": 127, "name": "平面设计", "title": "平面设计" },
      { "count": 116, "name": "设计思维", "title": "设计思维" },
      { "count": 102, "name": "艺术", "title": "艺术" },
      { "count": 74, "name": "Design", "title": "Design" },
      { "count": 44, "name": "科普", "title": "科普" }
    ],
    "origin_title": "The Non-Designer's Design Book(4th Edition)",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28340357.jpg",
    "binding": "平装",
    "translator": ["苏金国", "李盼"],
    "catalog": "第一部分　设计原则\n第1章　引言　　3\n约书亚树　　3\n4大基本原则　　5\n第2章　亲密性　　7\n把问题说出来　　 22\n亲密性小结　　24\n根本目的　　24\n如何实现　　24\n要避免的问题　　24\n第3章　对齐　　25\n到处看看　　 44\n对齐小结　　46\n根本目的　　46\n如何实现　　46\n要避免的问题　　46\n第4章　重复　　47\n重复小结　　60\n根本目的　　60\n如何实现　　60\n要避免的问题　　60\n第5章　对比　　61\n对比小结　　76\n根本目的　　76\n如何实现　　76\n要避免的问题　　76\n第6章　4大基本原则复习　　77\n亲密性　　78\n对齐　　79\n重复　　80\n对比　　81\n小测验#1：设计原则　　82\n小测验#2：重新设计广告　　83\n小结　　86\n第7章　颜色运用　　87\n不同凡响的色轮　　88\n颜色关系　　89\n互补　　90\n三色组　　91\n分裂互补三色组　　92\n类似色　　93\n暗色和亮色　　94\n建立你自己的暗色和亮色　　95\n单色　　96\n暗色和亮色的组合　　97\n注意色质　　98\n暖色与冷色　　99\n如何取舍　　100\nCMYK与RGB，印刷与Web　　102\n印刷与Web 颜色模型　　104\n小测验#3：颜色　　104\n第8章　更多提示与技巧　　105\n创建包装或品牌　　106\n企业名片　　109\n关于设计企业名片的提示　　112\n信笺和信封　　113\n关于设计信笺和信封的提示　　116\n传单　　117\n关于设计传单的提示　　120\n新闻简报　　121\n关于设计新闻简报的提示　　124\n宣传册　　125\n关于设计宣传册的提示　　128\n明信片　　129\n关于设计明信片的提示　　132\n报纸广告　　133\n关于设计报纸广告的提示　　136\n简历　　137\n关于设计简历的提示　　140\n第二部分　字体设计\n第9章　字体的基本规则　　143\n标点后面一个空格　　144\n引号　　145\n撇号　　146\n小测验#4：撇号　　147\n连接号　　148\n特殊符号　　150\n重音符号　　152\n大写字母　　153\n下划线　　154\n字距调整　　155\n寡妇和孤儿　　156\n其他　　157\n第10章　字体（与人生）　　159\n协调　　160\n冲突　　162\n对比　　164\n小结　　166\n第11章　字体类别　　167\nOldstyle（旧式体）　　168\nModern（现代体）　　169\nSlab serif（粗衬线体）　　170\nSans serif（无衬线体）　　171\nScript（手写体）　　173\nDecorative（花体）　　174\n有意识地去做　　175\n小测验#5：字体类别　　175\n小测验#6：粗/细过渡　　176\n小测验#7：截线　　177\n小结　　178\n第12章　字体对比　　179\n大小　　180\n粗细　　184\n结构　　188\n形状　　192\n方向　　196\n颜色　　200\n结合多种对比　　206\n小结　　207\n小测验#8：对比还是冲突　　208\n小测验#9：可做与不可做　　209\n结合多种对比的练习　　210\n第三部分　其他\n第13章　你掌握了吗　　213\n过程　　214\n练习　　215\n好的——重新设计!　　216\n第14章　测验答案和建议　　217\n测试答案　　217\n设计师之眼建议　　220\n第15章　本书所用字体　　225\n附录A：迷你术语表和资源　　231\n附录B：我永远是一名教师　　232\n附录C：生活就要设计　　237\n索引　　238",
    "ebook_url": "https://read.douban.com/ebook/18692011/",
    "pages": "252",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28340357.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28340357.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28340357.jpg"
    },
    "alt": "https://book.douban.com/subject/26664522/",
    "id": "26664522",
    "publisher": "人民邮电出版社",
    "isbn10": "7115404402",
    "isbn13": "9787115404404",
    "title": "写给大家看的设计书（第4版）",
    "url": "https://api.douban.com/v2/book/26664522",
    "alt_title": "The Non-Designer's Design Book(4th Edition)",
    "author_intro": "Robin　Williams\n世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。\n她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。\n图灵社区对她做过访谈，感兴趣的读者可以看看被豆瓣网友评为J.K.罗琳似的艰苦奋斗代表是如何自我定位的：ituring.cn/article/41065。",
    "summary": "畅销设计入门书最新版，让每个人都能成为设计师\n在这个创意无处不在的时代，越来越多的人成为设计师。简历、论文、PPT、个人主页、博客、活动海报、给客人的邮件、名片……，处处都在考验你的设计能力。\n美术功课不好？没有艺术细胞？毫无设计经验？\n没关系！在设计大师RobinWilliams看来，设计其实很简单。在这部畅销全球多年、影响了一代设计师的经典著作中，RobinWilliams将优秀设计的秘诀归纳为对比、重复、对齐和亲密性四条基本原则，并用简洁通俗、幽默生动的文笔，同时配以大量经过修改进行前后对比的实例图解和设计练习（并提供解答），直观清晰地传授给读者。通过本书，普通读者很快就能够自信地设计出专业级别的作品，而专业设计师也将从中获得灵感和解决问题的途径。\nRobin　Williams　　世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。图灵社区对她做过访谈，收录在本书内，感兴趣的读者看看被豆瓣网友评为“J.K.罗琳似的艰苦奋斗代表”的Robin是如何自我定位的。访谈电子版地址：ituring.cn/article/41065。",
    "ebook_price": "18.00",
    "price": "59.00元"
  },
  "9787115400413": {
    "rating": { "max": 10, "numRaters": 116, "average": "7.5", "min": 0 },
    "subtitle": "",
    "author": ["[美] Neal Ford"],
    "pubdate": "2015-8",
    "tags": [
      { "count": 112, "name": "函数式编程", "title": "函数式编程" },
      { "count": 58, "name": "编程", "title": "编程" },
      { "count": 43, "name": "函数式", "title": "函数式" },
      { "count": 29, "name": "计算机", "title": "计算机" },
      { "count": 17, "name": "编程思想", "title": "编程思想" },
      { "count": 15, "name": "编程艺术", "title": "编程艺术" },
      { "count": 12, "name": "programming", "title": "programming" },
      { "count": 12, "name": "Java", "title": "Java" }
    ],
    "origin_title": "Functional Thinking",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28271089.jpg",
    "binding": "平装",
    "translator": ["郭晓刚"],
    "catalog": "译者序　　ix\n前言　　xi\n第1章　为什么　　1\n1.1　范式转变　　2\n1.2　跟上语言发展的潮流　　4\n1.3　把控制权让渡给语言/ 运行时　　4\n1.4　简洁　　5\n第2章　转变思维　　9\n2.1　普通的例子　　9\n2.1.1　命令式解法　　9\n2.1.2　函数式解法　　10\n2.2　案例研究：完美数的分类问题　　15\n2.2.1　完美数分类的命令式解法　　15\n2.2.2　稍微向函数式靠拢的完美数分类解法　　16\n2.2.3　完美数分类的Java 8实现　　18\n2.2.4　完美数分类的Functional Java实现　　19\n2.3　具有普遍意义的基本构造单元　　21\n2.3.1　筛选　　22\n2.3.2　映射　　23\n2.3.3　折叠/ 化约　　25\n2.4　函数的同义异名问题　　28\n2.4.1　筛选　　28\n2.4.2　映射　　31\n2.4.3　折叠/ 化约　　33\n第3章　权责让渡　　37\n3.1　迭代让位于高阶函数　　37\n3.2　闭包　　38\n3.3　柯里化和函数的部分施用　　41\n3.3.1　定义与辨析　　41\n3.3.2　Groovy的情况　　42\n3.3.3　Clojure的情况　　44\n3.3.4　Scala的情况　　44\n3.3.5　一般用途　　47\n3.4　递归　　48\n3.5　Stream 和作业顺序重排　　53\n第4章　用巧不用蛮　　55\n4.1　记忆　　55\n4.1.1　缓存　　56\n4.1.2　引入“记忆”　　59\n4.2　缓求值　　65\n4.2.1　Java语言下的缓求值迭代子　　65\n4.2.2　使用Totally Lazy框架的完美数分类实现　　67\n4.2.3　Groovy语言的缓求值列表　　69\n4.2.4　构造缓求值列表　　72\n4.2.5　缓求值的好处　　74\n4.2.6　缓求值的字段初始化　　76\n第5章　演化的语言　　79\n5.1　少量的数据结构搭配大量的操作　　79\n5.2　让语言去迎合问题　　81\n5.3　对分发机制的再思考　　82\n5.3.1　Groovy对分发机制的改进　　82\n5.3.2　“身段柔软”的Clojure 语言　　83\n5.3.3　Clojure的多重方法和基于任意特征的多态　　85\n5.4　运算符重载　　87\n5.4.1　Groovy　　87\n5.4.2　Scala　　89\n5.5　函数式的数据结构　　91\n5.5.1　函数式的错误处理　　91\n5.5.2　Either类　　92\n5.5.3　Option类　　100\n5.5.4　Either树和模式匹配　　100\n第6章　模式与重用　　107\n6.1　函数式语言中的设计模式　　107\n6.2　函数级别的重用　　108\n6.2.1　Template Method模式　　109\n6.2.2　Strategy模式　　 111\n6.2.3　Flyweight模式和记忆　　113\n6.2.4　Factory模式和柯里化　　116\n6.3　结构化重用和函数式重用的对比　　117\n第7章　现实应用　　125\n7.1　Java 8　　125\n7.1.1　函数式接口　　126\n7.1.2　Optional类型　　128\n7.1.3　Java 8的stream　　128\n7.2　函数式的基础设施　　129\n7.2.1　架构　　129\n7.2.2　Web 框架　　132\n7.2.3　数据库　　133\n第8章　多语言与多范式　　135\n8.1　函数式与元编程的结合　　136\n8.2　利用元编程在数据类型之间建立映射　　137\n8.3　多范式语言的后顾之忧　　140\n8.4　上下文型抽象与复合型抽象的对比　　141\n8.5　函数式金字塔　　143\n作者简介　　147\n封面介绍　　147",
    "pages": "162",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28271089.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28271089.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28271089.jpg"
    },
    "alt": "https://book.douban.com/subject/26587213/",
    "id": "26587213",
    "publisher": "人民邮电出版社",
    "isbn10": "7115400415",
    "isbn13": "9787115400413",
    "title": "函数式编程思维",
    "url": "https://api.douban.com/v2/book/26587213",
    "alt_title": "Functional Thinking",
    "author_intro": "Neal Ford\n在跨国IT咨询公司ThoughtWorks担任总监、软件架构师和文化基因传播人。他精通各种编程语言，主要的咨询业务是大规模企业应用的设计、构建和工程实践。他还是一位国际知名的讲师，登上过全世界各种开发者会议的讲台。",
    "summary": "本书脱离特定的语言特性，关注各种OOP语言的共同实践做法，展示如何通过函数式语言解决问题。例如，如何利用函数式语言，通过高阶函数、多元方法等完成代码重用。知名软件架构师Neal Ford为我们展示不同的编程范式，帮我们完成从Java命令式编程人员，到使用Java、Clojure、Scala函数式编程人员的完美转变，建立对函数式语言的语法和语义的良好理解。",
    "price": "49.00元"
  },
  "9787108011114": {
    "rating": { "max": 10, "numRaters": 7091, "average": "8.9", "min": 0 },
    "subtitle": "科学顽童的故事",
    "author": ["费曼"],
    "pubdate": "1997-12",
    "tags": [
      { "count": 4356, "name": "传记", "title": "传记" },
      { "count": 3207, "name": "费曼", "title": "费曼" },
      { "count": 1792, "name": "科普", "title": "科普" },
      { "count": 1469, "name": "物理", "title": "物理" },
      {
        "count": 1416,
        "name": "别闹了，费曼先生",
        "title": "别闹了，费曼先生"
      },
      { "count": 990, "name": "人物", "title": "人物" },
      { "count": 936, "name": "科学家", "title": "科学家" },
      { "count": 917, "name": "自传", "title": "自传" }
    ],
    "origin_title": "“Surely You’re Joking,Mr. Feynman!” - Adventures of a Curious Character",
    "image": "https://img3.doubanio.com/view/subject/m/public/s1027286.jpg",
    "binding": "平装",
    "translator": ["吴程远"],
    "catalog": "目录\n序\n天才中的小飞侠\n作者序――\n费曼自述\n作者序二\n带来无限灵感\n第一部 小顽童的成长\n他单靠想便把收音机修好\n我切，我切，我切切切！\n谁偷了我的门？\n你在说什么鬼话？\n好险，又过关了！\n伟大的化学部主任\n第二部 误闯普林斯顿\n“别闹了 费曼先生！”\n我啦！我啦！\n有没有猫体构造图？\n当科学大师碰上菜鸟\n真正男子汉\n跟数学家抬杠\n看穿你的心\n草履虫 蜻蜓・蚁\n第三部 从军记\n我要报效国家\n猎犬能，我也能\n原子弹外传\n开锁英雄惜英雄\n山姆大叔不要你\n第四部 堂堂大教授\n眼中无“物’，心中有“理’\n有什么问题吗？\n还我一块钱！\n你就这样问她们？\n运气，其实不简单\n美国佬在巴西\n语不惊人誓不休\n费曼大闹赌城\n对不起 薪水太高了\n第五部 笑闹中的真智慧\n桃太郎，我投降！\n不要太相信专家\n我就是不要签\n会议在哪里？\n如果科学就是艺术\n假聪明，真笨蛋\n你们就这样选书？\n诺贝尔奖害人不浅\n无心插柳变专家\n教授鼓手上舞台\n真真假假，假假真真\n草包族科学\n",
    "pages": "449",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s1027286.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s1027286.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s1027286.jpg"
    },
    "alt": "https://book.douban.com/subject/1037602/",
    "id": "1037602",
    "publisher": "生活·读书·新知三联书店",
    "isbn10": "7108011115",
    "isbn13": "9787108011114",
    "title": "别闹了，费曼先生",
    "url": "https://api.douban.com/v2/book/1037602",
    "alt_title": "“Surely You’re Joking,Mr. Feynman!” - Adventures of a Curious Character",
    "author_intro": "理查德・曼（Richard P.Feyrman）1918年出生，1939年于麻省理工学院毕业后，进入普林斯顿大学研究院，又加入罗拉拉摩斯实验室，对原子弹的发展贡献卓著。1956年与薛温格和朝永振一郎共获诺贝尔物理奖。1988年2月困患癌症辞世。费曼的思想如天马行空，喜自辟蹊径，且从不固执，求知欲极强。他很爱恶作剧，但往往只为点出世间许多荒谬之处。确如《洛杉矶时报》所说的，“任何读这本书而不大笑出声的人，心理一定有毛病。”",
    "summary": "费曼得过诺贝尔奖，是现代最伟大的理论物理学家之一。但他同时也可能是历史上唯一被按摩院请去画裸体画、偷偷打开放着原子弹机密文件的保险箱，在巴西桑巴乐团担任鼓手的科学家。他曾跟爱因斯坦和波尔等大师讨论物理问题，也曾在赌城跟职业赌徒研究输赢机率。",
    "series": { "id": "1682", "title": "科学人文" },
    "price": "22.00"
  },
  "9787115483669": {
    "rating": { "max": 10, "numRaters": 12, "average": "8.4", "min": 0 },
    "subtitle": "从零开始打造产品、技术和团队",
    "author": ["[美]叶夫根尼·布里克曼（Yevgeniy Brikman）"],
    "pubdate": "2018-7",
    "tags": [
      { "count": 17, "name": "创业", "title": "创业" },
      { "count": 9, "name": "计算机", "title": "计算机" },
      { "count": 7, "name": "互联网", "title": "互联网" },
      { "count": 5, "name": "软件工程", "title": "软件工程" },
      { "count": 5, "name": "编程", "title": "编程" },
      { "count": 4, "name": "程序设计", "title": "程序设计" },
      { "count": 4, "name": "技术", "title": "技术" },
      { "count": 3, "name": "软件开发", "title": "软件开发" }
    ],
    "origin_title": "Hello, Startup: A Programmer's Guide to Building Products, Technology, and Teams",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29816092.jpg",
    "binding": "平装",
    "translator": ["吴晓嘉"],
    "catalog": "对本书的赞誉　　v\n前言　　xiii\n第一部分　产品\n第1章　为何创业　　2\n1.1　科技创业的时代　　2\n1.2　什么是科技创业公司　　2\n1.3　为什么应该在创业公司中工作　　4\n1.3.1　更多的机会　　4\n1.3.2　更多的所有权　　8\n1.3.3　更多的乐趣　　10\n1.4　为什么不应该在创业公司工作　　12\n1.4.1　创业并不是那么光鲜亮丽　　12\n1.4.2　创业就是牺牲　　14\n1.4.3　你可能不会变得富有　　15\n1.4.4　加入创业公司和自己创业的比较　　16\n1.5　小结　　18\n第2章　创业点子　　20\n2.1　点子从何而来　　20\n2.1.1　知识　　22\n2.1.2　点子的产生　　24\n2.1.3　培养创造力的环境　　25\n2.1.4　秘密模式　　31\n2.1.5　点子和执行力　　32\n2.2　验证　　33\n2.2.1　速度制胜　　34\n2.2.2　客户开发　　38\n2.2.3　验证问题　　39\n2.3　小结　　44\n第3章　产品设计　　47\n3.1　设计　　47\n3.1.1　设计是迭代的　　48\n3.1.2　以用户为中心的设计　　50\n3.1.3　视觉设计　　64\n3.1.4　视觉设计快速回顾　　80\n3.2　MVP　　82\n3.2.1　MVP 的类型　　83\n3.2.2　关注差异性　　87\n3.2.3　购买MVP　　89\n3.2.4　创业须从无法规模化的事情做起　　91\n3.3　小结　　92\n第4章　数据与营销　　94\n4.1　数据　　94\n4.1.1　需要跟踪的指标　　96\n4.1.2　数据驱动开发　　99\n4.2　营销　　103\n4.2.1　口口相传　　104\n4.2.2　市场推广　　109\n4.2.3　销售　　112\n4.2.4　品牌化　　114\n4.3　小结　　116\n第二部分　技术\n第5章　技术栈的选择　　120\n5.1　关于技术栈的考虑　　120\n5.2　技术栈的进化　　121\n5.3　内部实现、购买商业产品，还是使用开源产品\n5.3.1　内部实现　　125\n5.3.2　购买商业产品　　125\n5.3.3　使用开源产品　　126\n5.3.4　永远不要自己实现的技术　　126\n5.3.5　结语　　127\n5.4　选择编程语言　　128\n5.4.1　编程范式　　129\n5.4.2　适用问题　　131\n5.4.3　性能　　131\n5.4.4　生产效率　　131\n5.4.5　结语　　132\n5.5　选择服务器端框架　　133\n5.5.1　适用问题　　134\n5.5.2　数据层　　134\n5.5.3　视图层　　135\n5.5.4　测试　　138\n5.5.5　可扩展性　　138\n5.5.6　部署　　139\n5.5.7　安全　　139\n5.5.8　结语　　141\n5.6　选择数据库　　142\n5.6.1　关系型数据库　　142\n5.6.2　NoSQL数据库　　144\n5.6.3　读取数据　　148\n5.6.4　写入数据　　150\n5.6.5　模式　　151\n5.6.6　可扩展性　　153\n5.6.7　故障模式　　157\n5.6.8　成熟度　　157\n5.6.9　结语　　158\n5.7　小结　　159\n第6章　整洁的代码　　162\n6.1　代码是给人阅读的　　162\n6.2　代码布局　　164\n6.3　命名　　166\n6.3.1　回答所有重要的问题　　166\n6.3.2　要精确　　167\n6.3.3　要全面　　168\n6.3.4　揭示意图　　169\n6.3.5　遵循约定　　170\n6.3.6　命名真难　　171\n6.4　错误处理　　171\n6.5　不要重复自己　　172\n6.6　单一职责原则　　175\n6.7　函数式编程　　176\n6.7.1　不可变数据　　176\n6.7.2　高阶函数　　179\n6.7.3　纯函数　　181\n6.8　松耦合　　184\n6.8.1　内部实现依赖性　　186\n6.8.2　系统依赖性　　186\n6.8.3　库依赖性　　187\n6.8.4　全局变量　　188\n6.9　高内聚　　190\n6.10　注释　　192\n6.11　重构　　193\n6.12　小结　　194\n第7章　可扩展性　　196\n7.1　创业的扩展　　196\n7.2　编码实践的扩展　　196\n7.2.1　自动化测试　　197\n7.2.2　代码分离　　216\n7.2.3　代码评审　　220\n7.2.4　文档　　223\n7.3　性能的扩展　　227\n7.3.1　测量　　228\n7.3.2　优化　　229\n7.4　小结　　231\n第8章　软件交付　　234\n8.1　完成意味着交付　　234\n8.2　手工交付：一个恐怖的故事　　234\n8.3　构建　　235\n8.3.1　版本控制　　236\n8.3.2　构建工具　　239\n8.3.3　持续集成　　239\n8.4　部署　　244\n8.4.1　托管　　244\n8.4.2　配置管理　　245\n8.4.3　持续交付　　248\n8.5　监控　　250\n8.5.1　日志记录　　250\n8.5.2　指标　　253\n8.5.3　报警　　254\n8.6　小结　　254\n第三部分　团队\n第9章　创业文化　　258\n9.1　要行动，不要口号　　258\n9.2　核心理念　　258\n9.2.1　使命　　259\n9.2.2　核心价值　　262\n9.3　组织设计　　263\n9.3.1　经理驱动等级结构　　263\n9.3.2　分布式组织　　264\n9.4　招聘与晋升　　267\n9.4.1　彼得原理　　267\n9.4.2　以管理作为晋升　　267\n9.5　激励　　269\n9.5.1　自主权　　271\n9.5.2　专业能力　　272\n9.5.3　目标　　273\n9.6　办公室　　274\n9.6.1　一个可以和他人一起工作的地方　　276\n9.6.2　一个可以独处专注工作的地方　　276\n9.6.3　一个可以放下工作的地方　　279\n9.6.4　一种可以根据个人需要布置办公室的方法　　280\n9.7　远程办公　　282\n9.7.1　优点　　282\n9.7.2　缺点　　283\n9.7.3　最佳实践　　284\n9.8　沟通　　285\n9.8.1　内部沟通　　285\n9.8.2　外部沟通　　287\n9.9　过程　　287\n9.9.1　采用出色的判断　　288\n9.9.2　软件方法论　　289\n9.10　小结　　290\n第10章　求职之路　　292\n10.1　寻找创业公司的工作　　292\n10.1.1　利用人脉　　293\n10.1.2　发展人脉　　294\n10.1.3　创建网络身份　　295\n10.1.4　在线职位搜索　　298\n10.2　通过面试　　298\n10.2.1　在白板上编程　　298\n10.2.2　把思考的过程说出来　　298\n10.2.3　了解自己　　299\n10.2.4　了解公司　　299\n10.2.5　简短的、重复的计算机基础问题　　299\n10.3　如何对工作机会进行评估和谈判　　300\n10.3.1　薪水　　300\n10.3.2　股权　　301\n10.3.3　福利　　307\n10.3.4　谈判　　307\n10.4　小结　　309\n第11章　招兵买马　　311\n11.1　创业与人密不可分　　311\n11.2　招聘什么人　　311\n11.2.1　合伙人　　312\n11.2.2　早期员工　　313\n11.2.3　后期员工　　314\n11.2.4　10倍能力的开发人员　　314\n11.2.5　寻找什么　　316\n11.3　寻找出色的人选　　319\n11.3.1　推荐　　319\n11.3.2　雇主品牌化　　320\n11.3.3　在线搜索　　321\n11.3.4　专职招聘人员　　322\n11.3.5　过早优化　　322\n11.4　面试　　324\n11.4.1　面试过程　　325\n11.4.2　面试问题　　325\n11.5　录用　　330\n11.5.1　应该提供什么　　331\n11.5.2　跟进和谈判　　334\n11.6　小结　　334\n第12章　学习　　336\n12.1　学习的原理　　336\n12.1.1　明智地选择技能　　337\n12.1.2　投入时间去学习　　338\n12.1.3　让学习成为工作的一部分　　339\n12.2　学习的技巧　　339\n12.2.1　研究　　339\n12.2.2　实现　　341\n12.2.3　分享　　342\n12.3　经验教训　　344\n12.4　小结　　348\n关于作者　　350",
    "pages": "376",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29816092.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29816092.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29816092.jpg"
    },
    "alt": "https://book.douban.com/subject/30271075/",
    "id": "30271075",
    "publisher": "人民邮电出版社",
    "isbn10": "7115483663",
    "isbn13": "9787115483669",
    "title": "奔跑吧，程序员",
    "url": "https://api.douban.com/v2/book/30271075",
    "alt_title": "Hello, Startup: A Programmer's Guide to Building Products, Technology, and Teams",
    "author_intro": "叶夫根尼•布里克曼（Yevgeniy Brikman）\n程序员出身的创业者，DevOps服务公司Gruntwork联合创始人，在打造产品、技术和团队方面经验丰富，曾先后供职于Linkedln、TripAdvisor、思科和Thomson Financial。",
    "summary": "本书以软件工程师出身的创业者的角度，全面介绍了创业公司该如何打造产品、实现技术和建立团队，既是为创业者打造的一份实用入门指南，又适合所有程序员系统认识IT行业。书中内容分为三部分——技术、产品和团队，详细描绘创业的原始景象，具体内容包括：创业点子、产品设计、数据与营销、技术栈的选择、整洁的代码、软件交付、创业文化、招兵买马，等等。",
    "price": "99.00元"
  },
  "9787115465634": {
    "rating": { "max": 10, "numRaters": 61, "average": "8.3", "min": 0 },
    "subtitle": "",
    "author": ["[美] 詹姆斯 · 格雷克"],
    "pubdate": "2017-10",
    "tags": [
      { "count": 65, "name": "科普", "title": "科普" },
      { "count": 32, "name": "物理", "title": "物理" },
      { "count": 26, "name": "科学", "title": "科学" },
      { "count": 17, "name": "时间", "title": "时间" },
      { "count": 16, "name": "哲学", "title": "哲学" },
      { "count": 12, "name": "美国", "title": "美国" },
      { "count": 10, "name": "理论", "title": "理论" },
      { "count": 8, "name": "科技简史类", "title": "科技简史类" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s29577588.jpg",
    "binding": "平装",
    "translator": ["楼伟珊"],
    "catalog": "第一章　机器\n第二章　世纪末\n第三章　哲学家与廉价杂志\n第四章　远古之光\n第五章　自力更生\n第六章　时间箭头\n第七章　河流，小径，迷宫\n第八章　永恒\n第九章　被掩埋的时间\n第十章　往后\n第十一章　悖论之种种\n第十二章　时间是什么？\n第十三章　我们仅有的船只\n第十四章　在现在\n注释\n参考文献与进一步阅读\n致谢",
    "ebook_url": "https://read.douban.com/ebook/42792656/",
    "pages": "320",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s29577588.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s29577588.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s29577588.jpg"
    },
    "alt": "https://book.douban.com/subject/27169871/",
    "id": "27169871",
    "publisher": "人民邮电出版社",
    "isbn10": "7115465630",
    "isbn13": "9787115465634",
    "title": "时间旅行简史",
    "url": "https://api.douban.com/v2/book/27169871",
    "alt_title": "",
    "author_intro": "詹姆斯•格雷克（James Gleick）\n国际知名的科普作家。1987年，他的首部作品《混沌》入围美国国家图书奖和普利策奖决赛，并成为畅销书，使得“混沌”、“蝴蝶效应”的说法家喻户晓。其后他又陆续出版了《费曼传》（1992）、《越来越快》（1999）、《牛顿传》（2003）等书。他的上一部书《信息简史》（2011）荣获英国皇家学会科普图书奖、美国笔会爱德华•威尔逊科普文学奖、英国笔会赫塞尔-蒂尔特曼奖（简体中文版荣获2014年第九届文津图书奖），并成为国际性畅销书。他的作品已被翻译成三十种语言。",
    "summary": "现如今，时间旅行已经深深渗透进我们的文化，几乎随处可见。但可能出乎我们大多数人意料，时间旅行其实是一个晚近的发明，“一种现代幻想”。当H.G. 威尔斯在十九世纪末想像出一部时间机器时，他也发明了“一种新的思维方式”。那么为什么不见于之前？又为什么是现在？\n进入二十世纪，时间旅行及其引发的种种哲学论争和悖论，不仅吸引了科幻作家，更吸引了现代主义文学家、哲学家以及科学家的关注。从海因莱因、阿西莫夫到普鲁斯特、博尔赫斯，从柏格森、詹姆斯到爱因斯坦、哥德尔，从文学到心理学、量子理论，从小说、诗歌到电影，从宿命论到记忆、意识，各种形式的时间旅行或许可以帮助我们更好地理解那个古老而深刻的问题：时间是什么？\n而进入二十一世纪，人类与时间的关系再次悄然发生改变。在这个相互连接日益密切的世界，无止尽的现在把过去和未来都吞并了进来：一切都是现在时。那么为什么我们现在仍想要时间旅行？而要是你有机会乘坐一次时间机器，你会选择哪个方向？未来，还是过去？",
    "ebook_price": "24.99",
    "price": "49.00元"
  },
  "9787115482495": {
    "rating": { "max": 10, "numRaters": 351, "average": "8.0", "min": 0 },
    "subtitle": "",
    "author": ["阮一峰"],
    "pubdate": "2018-6-1",
    "tags": [
      { "count": 103, "name": "阮一峰", "title": "阮一峰" },
      { "count": 76, "name": "未来", "title": "未来" },
      { "count": 61, "name": "计算机", "title": "计算机" },
      { "count": 59, "name": "社会", "title": "社会" },
      { "count": 58, "name": "科技", "title": "科技" },
      { "count": 48, "name": "思维", "title": "思维" },
      { "count": 41, "name": "随笔", "title": "随笔" },
      { "count": 41, "name": "思考", "title": "思考" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s29804420.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "▌现实篇\n世界会走向哪里？\n白领岗位的消亡\n为什么世界上没有安全的工作？\n那些无用的人\n穷忙的人生\n为什么你可以不读大学\n▌职业篇\n为什么雇用制度对工人不利？\n母鸡与前端工程师\n你的命运不是一头骡子\n从日本70 岁退休谈起……\n45 岁以后的人生\n你的 B 计划在哪里？\n▌方法篇\n为什么创业？\n如何确定创业方向？\n不要在功能上竞争\n大坑和小铲子\n富爸爸，穷爸爸\nDan 计划：重新定义人生的10 000 个小时\n软件工程师的职业建议\n为什么起床后不能收邮件？\n▌案例篇\n个性也是一种竞争力\n要聊天，先付费\n即将来临的卖文时代\n微媒体时代\n未来的娱乐业\n技术教育的兴起\n▌未来篇\n高级人类的崛起\n换头术\n你的鞋都比你聪明\n技术的边界\n熵：宇宙的终极规则\n技术决定历史\n卡辛斯基的警告",
    "ebook_url": "https://read.douban.com/ebook/54850954/",
    "pages": "160",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s29804420.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s29804420.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s29804420.jpg"
    },
    "alt": "https://book.douban.com/subject/30259509/",
    "id": "30259509",
    "publisher": "人民邮电出版社",
    "isbn10": "7115482497",
    "isbn13": "9787115482495",
    "title": "未来世界的幸存者",
    "url": "https://api.douban.com/v2/book/30259509",
    "alt_title": "",
    "author_intro": "阮一峰IT 技术作家，长期写作个人技术博客。当过高校教师，也当过阿里巴巴集团软件工程师。\n于2003年开始在网络上写日志，文章包含的内容非常广博，涉及读书、版权制度、经济学、英语、历史、IT技术、医学、电影、音乐和美术、政治学、科学、创业、互联网等23个大的分类。\n曾出 版译著《黑客与画家》《软件随想录》，技术专著《ES6 标准入门》。\n著作：《如何变得有思想》 、《前方的路》。",
    "summary": "本书为阮一峰博客文集，主要收录的是作者对技术变革的影响的一些思考，希望能够藉此书让读者意识到世界正在剧烈变化，洪水就在不远处，从而早早准备出路。本书适合所有乐于思考的读者。",
    "ebook_price": "19.99",
    "series": { "id": "43672", "title": "阮一峰文集" },
    "price": "39.00 元"
  },
  "9787121139512": {
    "rating": { "max": 10, "numRaters": 21022, "average": "9.1", "min": 0 },
    "subtitle": "",
    "author": ["吴军"],
    "pubdate": "2011-8",
    "tags": [
      { "count": 12906, "name": "互联网", "title": "互联网" },
      { "count": 9402, "name": "IT", "title": "IT" },
      { "count": 6795, "name": "商业", "title": "商业" },
      { "count": 4916, "name": "计算机", "title": "计算机" },
      { "count": 4840, "name": "浪潮之巅", "title": "浪潮之巅" },
      { "count": 3864, "name": "历史", "title": "历史" },
      { "count": 1968, "name": "管理", "title": "管理" },
      { "count": 1656, "name": "投资", "title": "投资" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s6807265.jpg",
    "binding": "平装",
    "translator": [],
    "catalog": "i\t序言（李开复）\niii\t前言　有幸见证历史\n1\t第 1 章　帝国的余辉—AT&T 公司\nAT&T 100年 来 发 展 得 非 常 健 康。 虽 然 它 一 直 受 反 垄断法的约束，但是美国政府司法部并没有真正要过它的命，每一次反垄断其实是帮助AT&T修枝剪叶，然后让它发展得更好。\n1　百年帝国\n2　几度繁荣\n3　利令智昏\n4　外来冲击\n结束语\n15\t第 2 章　蓝色巨人—IBM 公司\n郭士纳在到IBM以前也是做(芯)片的，但是，是土豆芯片\n1　赶上机械革命的最后一次浪潮\n2　领导电子技术革命的浪潮\n3　错过全球信息化的大潮\n4　他也是做（芯）片的\n5　保守的创新者\n6   内部的优胜劣汰\n7　后金融危机时代\n结束语\n38\t第 3 章　“水果”公司的复兴—乔布斯和苹果公司\n在每一次技术革命中，新技术必须比老的技术有数量 级的进步才能站住脚。\n1　传奇小子\n2　迷失方向\n3　再创辉煌\n4　大难不死\n5　i 十年\n结束语\n54\t第 4 章　计算机工业的生态链\n一 个IT公 司 如 果 今 天 和18个 月 前 卖 掉 同 样 多 的、 同\n样的产品，它的营业额就要降一半。\n1　摩尔定律\n2　安迪 – 比尔定律\n3　反摩尔定律\n结束语\n66\t第 5 章　奔腾的芯 — 英特尔公司\n英特尔的CEO格罗夫虽然是学者出身，但他同时也是微机时代最优秀的领导者和管理者，数次被评为世界上最好的CEO。\n1　时势造英雄\n2　英特尔、摩托罗拉之战\n3　指令集之争\n4　英特尔和 AMD 的关系\n5　举步艰难\n结束语\n82\t第 6 章　IT 领域的罗马帝国—微软公司\n当乔布斯给盖茨看了新设计的麦金托什个人电脑，以 及漂亮的基于图形界面的操作系统时，盖茨惊呆了。 那一年，乔布斯和盖茨都是 26岁。\n1　双雄会\n2　亡羊补牢\n3　人民战争\n4　帝国的诞生\n5　当世拿破仑\n6　尾大不掉\n7　条顿堡之战\n8　客厅争夺战\n结束语\n110\t第 7 章　互联网的金门大桥—思科公司\n据说斯坦福两个系的计算中心主管莱昂纳多•波萨卡 和桑迪•勒纳要在计算机上写情书，由于各自管理的 网络不同，设备又是乱七八糟，什么厂家的、什么协 议的都有，互不兼容，情书传递起来很不方便，于是 两人干脆发明了一种能支持各种网络服务器、各种网 络协议的路由器。于是思科公司赖以生存的“多协议 路由器”便诞生了。\n1　好风凭借力\n2　持续发展的绝招\n3　竞争者\n4　诺威格定律的宿命\n结束语\n125\t第 8 章　英名不朽—杨致远、菲洛和雅虎公司\n一百年后，如果人们只记得两个对互联网贡献最大的 人，那么这两个人很可能就是杨致远和菲洛。\n1　当世福特\n2　流量、流量、流量\n3　成也萧何，败也萧何\n4　既生瑜，何生亮\n5　红巨星\n6　自废武功\n结束语\n147\t第 9 章　硅谷的见证人—惠普公司\n作为硅谷最早的公司，惠普见证了硅谷发展的全过程， 从无到有，从硬件到软件，惠普的历史从某种程度上 讲就是硅谷历史的缩影。\n1　昔日硅谷之星\n2　有争议的生死抉择\n3　最有争议的 CEO\n4　亚洲制造的冲击\n5　峰回路转\n结束语\n163\t第 10 章　没落的贵族—摩托罗拉公司\n如果我们认为公司之中也有所谓的贵族，摩托罗拉无 疑可以算一个。曾几何时，摩托罗拉就是无线通信的 代名词，同时它还是技术和品质的结晶。\n1　二战的品牌\n2　黄金时代\n3　基因决定定律\n4　铱星计划\n5　全线溃败\n6　回天乏力\n结束语\n182\t第 11 章　硅谷的另一面\n美国的硅谷只占国土面积万分之五，却创造了无数的商 业神话。在这里，大约每10天便有一家公司上市。美 国前100强的公司中，硅谷占了四成。\n1　成王败寇\n2　嗜血的地方\n3　机会均等\n4　硅含量不断降低\n5　亘古而常青 结束语\n204\t第 12 章　短暂的春秋—与机会失之交臂的公司\n在人类命运降临的伟大瞬间，市民的一切美德 — 小 心、顺从、勤勉、谨慎，都无济于事，它始终只要求 天才人物，并且将他造就成不朽的形象。命运鄙视地 把畏首畏尾的人拒之门外。命运 — 这世上的另一位 神，只愿意用热烈的双臂把勇敢者高高举起，送上英 雄们的天堂。\n1　太阳公司\n2　Novell 公司\n3　网景公司\n4　RealNetworks\n结束语\n236\t第 13 章　幕后的英雄—风险投资\n对于想找投资的新创业公司，红杉资本有一些基本要 求 — 公司的业务要能几句话就讲得清楚。红杉资本 的投资人会给你一张名片，看你能不能在名片背面的 一点点地方把你想做的事情写清楚。\n1　风投的起源\n2　风投的结构\n3　风投的过程\n4　投资的决策和公司的估价\n5　风投的角色\n6　著名的风投公司\n结束语\n265\t第 14 章　信息产业的规律性\n人类的文明和技术是不断进步的，旧的不去，新的不 来，只有清除掉阻碍我们进步的那些庞大的恐龙，才 能为人类提供新的发展空间。从这个角度讲，一个昔 日跨国公司的衰亡，也许是它为我们这个社会做的最 后一次贡献。\n1   70–20–10 律\n2　诺威格定律\n3　基因决定定律\n结束语\n286\t第 15 章　硅谷的摇篮—斯坦福大学\n二战后，帮助斯坦福大学解决财政危机的是它的一位 教授弗里德里克•特曼，他后来被称为“硅谷之父”。 他仔细研究了斯坦福夫妇的遗嘱，发现里面没有限制 大学出租土地，于是他兴奋地声称找到了解决问题的 秘密武器 — 建立斯坦福科技园。\n1　充满传奇的大学\n2　硅谷的支柱\n3　纽曼加洪堡的教育模式\n4　创业的孵化器\n结束语\n313\t第 16 章　科技公司的吹鼓手—投资银行\n华尔街的贪婪既会捧起，也会扼杀一个科技新星。\n1　华尔街和美国的金融体系\n2　著名的投资公司\n3　科技公司的上市过程\n4　成也萧何，败也萧何\n5　华尔街与微软、雅虎和 Google 的三国演义\n结束语\n341\t第 17 章　挑战者—Google 公司\nGoogle是个奇怪的地方。也许是因为Google的年轻人太多，他们不懂得传统也不拘泥传统，只要认准了对公司对社会有用，就大胆去干了。\n1　历史上最轰动的 IPO\n2　早期岁月\n3　商业模式\n4　个人英雄主义和群众路线\n5　绝代双骄\n6　感谢上帝，今天是星期五（TGIF）\n7　不作恶\n8　不败的神话\n9　秘密军团\n10　云计算和数据中心\n11　Google 的新气象\n12　3G 时代\n13　进攻，永远是最好的防守\n结束语\n396\t第 18 章　成功的转基因—诺基亚、3M、GE 公司\n由于科学技术是最革命、发展最快的生产力，一家科 技公司要想在几次技术革命大潮中都能够立于浪潮之 巅是一件极不容易的事。\n1　从木工厂到手机之王（诺基亚公司）\n2　道琼斯指数中的常青树（3M 公司）\n3　世界最大的联合体（GE 公司）\n结束语\n423\t第 19 章　印钞机—最佳的商业模式\n所有成功的大公司都有好的商业模式，很多大公司的 兴起，不是靠技术的革新而是靠商业模式的转变。\n1　Google 的广告系统\n2　eBay 和亚马逊的在线市场\n3　戴尔的虚拟工厂\n4　腾讯的虚拟物品和服务\n结束语\n442\t第 20 章　互联网 2.0\n互联网2.0最重要的是提供了一个开放的平台，让用户可以在平台上开发自己的应用程序，并且提供给其 他用户使用。\n1　互联网的前世今生\n2　互联网 2.0 的特征\n3　著名的互联网 2.0 公司\n4　是革命还是泡沫\n结束语\n467\t第 21 章　金融风暴的冲击\n虽然全世界在2008年的最后一个季度里陷入严重的 衰退，同时人们的恐惧心理加重了这场危机，虽然在 更 长 一 些 时 间 里 我 们 仍 将 处 于 衰 退， 但 是， 明 天 仍 然 会 好 起 来。 今 后 的44年 里 我 们 的 经 济、 我 们 的 社会 都 将 获 得 长 足 的 发 展， 就 如 同 过 去 的44年 一 样。\n— 沃伦•巴菲特\n1　金融危机的成因\n2　瑞雪兆丰年：优胜劣汰\n3　潜在的商机到处都是\n4　格局的变迁\n结束语\n497\t第 22 章 　云计算\n云计算保证用户可以随时随地访问和处理信息，并且 可以非常方便地与人共享信息。 它的好处是让全社会 的计算资源得到最有效的利用。\n1　云计算的起源\n2　云计算的本质\n3　云计算的核心技术和工程\n4　对 IT 产业链的颠覆\n结束语\n513\t第 23 章　下一个 Google\n虽然我们不知道下一个Google在哪里，但是可以肯\n定它不在搜索领域，这就如同几年前我们寻找的“下 一个微软”不会是一家软件公司，而最终是一家互联 网公司一样。\n1　千亿俱乐部\n2　岁岁年年人不同\n3　新领域\n4　关注亚太地区\n结束语\n537\t后记\n541\t索引",
    "pages": "584",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s6807265.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s6807265.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s6807265.jpg"
    },
    "alt": "https://book.douban.com/subject/6709783/",
    "id": "6709783",
    "publisher": "电子工业出版社",
    "isbn10": "7121139510",
    "isbn13": "9787121139512",
    "title": "浪潮之巅",
    "url": "https://api.douban.com/v2/book/6709783",
    "alt_title": "",
    "author_intro": "吴军博士，毕业于清华大学计算机系（本科）、电子工程系（硕士）和美国约翰 · 霍普金斯大学计算机科学系（博士）。在清华大学和约翰 · 霍普金斯大学期间，吴军博士致力于语音识别、自然语言处理，特别是统计语言模型的研究。他曾获得1995年全国人机语音智能接口会议的最佳论文奖和2000年Eurospeech的最佳论文奖。\n吴军博士于2002年加入Google公司。在Google，他和Amit Singhal（Google院士，世界著名搜索专家）、Matt Cutts（Google反作弊官方发言人）等三位同事一起开创了网络搜索反作弊的研究领域，并因此获得Google工程奖。2003年，他和Google全球架构的总工程师朱会灿博士等共同成立了中日韩文搜索部门。吴军博士是当前Google中日韩文搜索算法的主要设计者。在Google其间，他还领导了许多研发项目，包括许多与中文相关的产品和自然语言处理的项目，并得到了当时公司首席执行官埃里克 · 施密特和创始人谢尔盖 · 布林的高度评价。此外，他还在谷歌黑板报上发表了《数学之美》系列博客。\n吴军博士在国内外发表过数十篇论文，并获得和申请了十余项美国和国际专利。他于2005年起，当选为约翰 · 霍普金斯大学计算机系董事会董事。2007起担任风险投资基金中国世纪基金的董事。\n2010年，吴军博士离开Google,加盟腾讯公司，担任负责搜索业务的副总裁。并担任国家重大专项“新一代搜索引擎和浏览器”项目的总负责人。",
    "summary": "近一百多年来，总有一些公司很幸运地、有意识或无意识地站在技术革命的浪尖之上。在这十几年间，它们代表着科技的浪潮，直到下一波浪潮的来临。\n从一百年前算起，AT&T 公司、IBM 公司、苹果公司、英特尔公司、微软公司、思科公司、雅虎公司和Google公司都先后被幸运地推到了浪尖。虽然，它们来自不同的领域，中间有些已经衰落或正在衰落，但是它们都极度辉煌过。本书系统地介绍了这些公司成功的本质原因及科技工业一百多年的发展。\n在极度商业化的今天，科技的进步和商机是分不开的。因此，本书也系统地介绍了影响到科技浪潮的风险投资公司，诸如 KPCB 和红杉资本，以及百年来为科技捧场的投资银行，例如高盛公司，等等。\n在这些公司兴衰的背后，有着它必然的规律。本书不仅讲述科技工业的历史，更重在揭示它的规律性。",
    "price": "55.00元"
  },
  "9787121123368": {
    "rating": { "max": 10, "numRaters": 888, "average": "8.8", "min": 0 },
    "subtitle": "从小工到专家",
    "author": ["Andrew Hunt", "David Thomas"],
    "pubdate": "2011-1",
    "tags": [
      { "count": 547, "name": "编程", "title": "编程" },
      { "count": 542, "name": "程序员", "title": "程序员" },
      { "count": 359, "name": "计算机", "title": "计算机" },
      { "count": 310, "name": "程序员的修炼之道", "title": "程序员的修炼之道" },
      { "count": 271, "name": "软件开发", "title": "软件开发" },
      { "count": 247, "name": "思维", "title": "思维" },
      { "count": 220, "name": "软件工程", "title": "软件工程" },
      { "count": 178, "name": "程序设计", "title": "程序设计" }
    ],
    "origin_title": "The Pragmatic Programmer: From Journeyman to Master",
    "image": "https://img3.doubanio.com/view/subject/m/public/s4646956.jpg",
    "binding": "平装",
    "translator": ["马维达"],
    "catalog": "前言\n序\n第1章 注重实效的哲学\n1 我的源码让猫给吃了\n2 软件的熵\n3 石头汤与煮青蛙\n4 足够好的软件\n5 你的知识资产\n6 交流\n第2章 注重实效的途径\n7 重复的危害\n8 正交性\n9 可撤消性\n10 曳光弹\n11 原型与便笺\n12 领域语言\n13 估算\n第3章 基本工具\n14 纯文本的威力\n15 shell游戏\n16 强力编辑\n17 源码控制\n18 调试\n19 文本操纵\n20 代码生成器\n第4章 注重实效的偏执\n21 按合约设计\n22 死程序不说谎\n23 断言式编程\n24 何时使用异常\n25 怎样配平资源\n第5章 弯曲，或折断\n26 解耦与得墨忒耳法则\n27 元程序设计\n28 时间耦合\n29 它只是视图\n30 黑板\n第6章 当你编码时\n31 靠巧合编程\n32 算法速率\n33 重构\n34 易于测试的代码\n35 邪恶的向导\n第7章 在项目开始之前\n36 需求之坑\n37 解开不可能解开的谜题\n38 等你准备好\n39 规范陷阱\n40 圆圈与箭头\n第8章 注重实效的项目\n41 注重实效的团队\n42 无处不在的自动化\n43 无情的测试\n44 全都是写\n45 极大的期望\n46 傲慢与偏见\n附录A 资源\n专业协会\n建设藏书库\nInternet资源\n参考文献\n附录B 练习解答\n索引\n注重实效的程序员之快速参考指南",
    "pages": "272",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s4646956.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s4646956.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s4646956.jpg"
    },
    "alt": "https://book.douban.com/subject/5387402/",
    "id": "5387402",
    "publisher": "电子工业出版社",
    "isbn10": "7121123363",
    "isbn13": "9787121123368",
    "title": "程序员修炼之道",
    "url": "https://api.douban.com/v2/book/5387402",
    "alt_title": "The Pragmatic Programmer: From Journeyman to Master",
    "author_intro": "Andrew Hunt是世界知名的软件技术专家。他从事软件开发和咨询多年，涉及电信、银行、金融服务、公共服务、医学成像等各种领域。以本获得世界级声誉后，他与David Thomas合作开办了一家专业的软件咨询和出版机构The Pragrammers,并撰写或组织出版了Programming Ruby和Agile Web Development With Rails 等名著，直接推动了RUBY和ROR的兴起，Andrew Hunt与合作人的PRACTICES OF AN AGILE David一书（中文版即将由人民邮电出版社出版），延续了本书的风格，同样也已成为经典。\n    Dave Thomas 喜欢驾驶单引擎飞机飞行，并通过这样的方式为他的习惯付账：为各种难题寻找优雅的解决方案，提供诸多领域里的咨询服务——航空、银行、金融服务、服务、电信、交通运输及Internet。\n    马维达，《C++网络编程（卷2）》与，《ACE自适配通信环境技术文档》的译者",
    "summary": "《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成，涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术，利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比，全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。",
    "series": { "id": "6628", "title": "传世经典书丛" },
    "price": "55.00元"
  },
  "9787115392275": {
    "rating": { "max": 10, "numRaters": 303, "average": "7.5", "min": 0 },
    "subtitle": "",
    "author": ["[日] 矢泽久雄"],
    "pubdate": "2015-5",
    "tags": [
      { "count": 217, "name": "计算机", "title": "计算机" },
      { "count": 135, "name": "计算机科学", "title": "计算机科学" },
      { "count": 100, "name": "科普", "title": "科普" },
      { "count": 82, "name": "计算机原理", "title": "计算机原理" },
      { "count": 65, "name": "计算机组成原理", "title": "计算机组成原理" },
      { "count": 59, "name": "编程", "title": "编程" },
      { "count": 39, "name": "初级", "title": "初级" },
      { "count": 32, "name": "矢泽久雄", "title": "矢泽久雄" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s28079818.jpg",
    "binding": "平装",
    "translator": ["胡屹"],
    "catalog": "第1章　计算机的三大原则　　1\n1.1　计算机的三个根本性基础　　3\n1.2　输入、运算、输出是硬件的基础　　4\n1.3　软件是指令和数据的集合　　6\n1.4　对计算机来说什么都是数字　　8\n1.5　只要理解了三大原则，即使遇到难懂的最新技术，也能轻松应对　　9\n1.6　为了贴近人类，计算机在不断地进化　　10\n1.7　稍微预习一下第2章　　13\n第2章　试着制造一台计算机吧　　15\n2.1　制作微型计算机所必需的元件　　17\n2.2　电路图的读法　　21\n2.3　连接电源、数据和地址总线　　23\n2.4　连接I/O　　26\n2.5　连接时钟信号　　27\n2.6　连接用于区分读写对象是内存还是I/O的引脚　　28\n2.7　连接剩余的控制引脚　　29\n2.8　连接外部设备，通过DMA输入程序　　34\n2.9　连接用于输入输出的外部设备　　35\n2.10　输入测试程序并进行调试　　36\n第3章　体验一次手工汇编　　39\n3.1　从程序员的角度看硬件　　41\n3.2　机器语言和汇编语言　　44\n3.3　Z80 CPU的寄存器结构　　49\n3.4　追踪程序的运行过程　　52\n3.5　尝试手工汇编　　54\n3.6　尝试估算程序的执行时间　　57\n第4章　程序像河水一样流动着　　59\n4.1　程序的流程分为三种　　61\n4.2　用流程图表示程序的流程　　65\n4.3　表示循环程序块的“帽子”和“短裤”　　68\n4.4　结构化程序设计　　72\n4.5　画流程图来思考算法　　75\n4.6　特殊的程序流程——中断处理　　77\n4.7　特殊的程序流程——事件驱动　　78\nCOLUMN　来自企业培训现场　　电阻颜色代码的谐音助记口诀　　82\n第5章　与算法成为好朋友的七个要点　　85\n5.1　算法是程序设计的“熟语”　　87\n5.2　要点1：算法中解决问题的步骤是明确且有限的　　88\n5.3　要点2：计算机不靠直觉而是机械地解决问题　　89\n5.4　要点3：了解并应用典型算法　　91\n5.5　要点4：利用计算机的处理速度　　92\n5.6　要点5：使用编程技巧提升程序执行速度　　95\n5.7　要点6：找出数字间的规律　　99\n5.8　要点7：先在纸上考虑算法　　101\n第6章　与数据结构成为好朋友的七个要点　　103\n6.1　要点1：了解内存和变量的关系　　105\n6.2　要点2：了解作为数据结构基础的数组　　108\n6.3　要点3：了解数组的应用——作为典型算法的数据结构　　109\n6.4　要点4：了解并掌握典型数据结构的类型和概念　　111\n6.5　要点5：了解栈和队列的实现方法　　114\n6.6　要点6：了解结构体的组成　　118\n6.7　要点7：了解链表和二叉树的实现方法　　120\n第7章　成为会使用面向对象编程的程序员吧　　125\n7.1　面向对象编程　　127\n7.2　对OOP的多种理解方法　　128\n7.3　观点1：面向对象编程通过把组件拼装到一起构建程序　　130\n7.4　观点2：面向对象编程能够提升程序的开发效率和可维护性　　132\n7.5　观点3：面向对象编程是适用于大型程序的开发方法　　134\n7.6　观点4：面向对象编程就是在为现实世界建模　　134\n7.7　观点5：面向对象编程可以借助UML设计程序　　135\n7.8　观点6：面向对象编程通过在对象间传递消息驱动程序　　137\n7.9　观点7：在面向对象编程中使用继承、封装和多态　　140\n7.10　类和对象的区别　　141\n7.11　类有三种使用方法　　143\n7.12　在Java和.NET中有关OOP的知识不能少　　145\n第8章　一用就会的数据库　　147\n8.1　数据库是数据的基地　　149\n8.2　数据文件、DBMS和数据库应用程序　　151\n8.3　设计数据库　　154\n8.4　通过拆表和整理数据实现规范化　　157\n8.5　用主键和外键在表间建立关系　　159\n8.6　索引能够提升数据的检索速度　　162\n8.7　设计用户界面　　164\n8.8　向DBMS发送CRUD操作的SQL语句　　165\n8.9　使用数据对象向DBMS发送SQL语句　　167\n8.10　事务控制也可以交给DBMS处理　　170\nCOLUMN　来自企业培训现场　　培训新人编程时推荐使用什么编程语言？　　172\n第9章　通过七个简单的实验理解TCP/IP网络　　175\n9.1　实验环境　　177\n9.2　实验1：查看网卡的MAC地址　　179\n9.3　实验2：查看计算机的IP地址　　182\n9.4　实验3：了解DHCP服务器的作用　　184\n9.5　实验4：路由器是数据传输过程中的指路人　　186\n9.6　实验5：查看路由器的路由过程　　188\n9.7　实验6：DNS服务器可以把主机名解析成IP地址　　190\n9.8　实验7：查看IP地址和MAC地址的对应关系　　192\n9.9　TCP的作用及TCP/IP网络的层级模型　　193\n第10章　试着加密数据吧　　197\n10.1　先来明确一下什么是加密　　199\n10.2　错开字符编码的加密方式　　201\n10.3　密钥越长，解密越困难　　205\n10.4　适用于互联网的公开密钥加密技术　　208\n10.5　数字签名可以证明数据的发送者是谁　　211\n第11章　XML究竟是什么　　215\n11.1　XML是标记语言　　217\n11.2　XML是可扩展的语言　　219\n11.3　XML是元语言　　220\n11.4　XML可以为信息赋予意义　　224\n11.5　XML是通用的数据交换格式　　227\n11.6　可以为XML标签设定命名空间　　230\n11.7　可以严格地定义　　XML的文档结构　　232\n11.8　用于解析XML的组件　　233\n11.9　XML可用于各种各样的领域　　235\n第12章　SE负责监管计算机系统的构建　　239\n12.1　SE是自始至终参与系统开发过程的工程师　　241\n12.2　SE未必担任过程序员　　243\n12.3　系统开发过程的规范　　243\n12.4　各个阶段的工作内容及文档　　245\n12.5　所谓设计，就是拆解　　247\n12.6　面向对象法简化了系统维护工作　　249\n12.7　技术能力和沟通能力　　250\n12.8　IT不等于引进计算机　　252\n12.9　计算机系统的成功与失败　　253\n12.10　大幅提升设备利用率的多机备份　　255",
    "pages": "272",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s28079818.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s28079818.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s28079818.jpg"
    },
    "alt": "https://book.douban.com/subject/26397183/",
    "id": "26397183",
    "publisher": "人民邮电出版社",
    "isbn10": "7115392277",
    "isbn13": "9787115392275",
    "title": "计算机是怎样跑起来的",
    "url": "https://api.douban.com/v2/book/26397183",
    "alt_title": "",
    "author_intro": "作者简介：\n矢泽久雄\nYAZAWA股份有限公司董事长兼总经理。GrapeCity信息技术集团顾问。电脑作家之友会会长。\n曾在某大型电子公司从事过电脑生产，在Software House做过程序员，现主要从事软件开发工作。工作之余笔耕不辍，从电路到编程语言均有涉及。代表作有《程序是怎样跑起来的》《使用C语言学习程序设计的基础》《征服C++类和继承》等。自称软件艺人。\n译者简介：\n胡屹\n多年从事Web开发工作。热爱编程，关注设计模式，致力于提升软件开发的质量。曾获得SCJP和PHP ZCE证书。",
    "summary": "本书倡导在计算机迅速发展、技术不断革新的今天，回归到计算机的基础知识上。通过探究计算机的本质，提升工程师对计算机的兴趣，在面对复杂的最新技术时，能够迅速掌握其要点并灵活运用。\n本书以图配文，以计算机的三大原则为开端、相继介绍了计算机的结构、手工汇编、程序流程、算法、数据结构、面向对象编程、数据库、TCP/IP 网络、数据加密、XML、计算机系统开发以及SE 的相关知识。\n图文并茂，通俗易懂，非常适合计算机爱好者和相关从业人员阅读。",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "39.00元"
  },
  "9787115295941": {
    "rating": { "max": 10, "numRaters": 53, "average": "7.5", "min": 0 },
    "subtitle": "工具与方法",
    "author": ["［日］ 池田尚史", "［日］ 藤仓和明", "［日］ 井上史彰"],
    "pubdate": "2015-7",
    "tags": [
      { "count": 45, "name": "项目管理", "title": "项目管理" },
      { "count": 28, "name": "软件工程", "title": "软件工程" },
      { "count": 27, "name": "管理", "title": "管理" },
      { "count": 15, "name": "软件开发", "title": "软件开发" },
      { "count": 12, "name": "IT", "title": "IT" },
      { "count": 11, "name": "效率", "title": "效率" },
      { "count": 11, "name": "工具", "title": "工具" },
      { "count": 5, "name": "技术", "title": "技术" }
    ],
    "origin_title": "",
    "image": "https://img3.doubanio.com/view/subject/m/public/s28117176.jpg",
    "binding": "平装",
    "translator": ["严圣逸"],
    "catalog": "第1章　什么是团队开发　　1\n1.1　一个人也能进行开发　　2\n1.2　团队开发面临的问题　　3\n1.3　如何解决这些问题　　4\n1.4　本书的构成　　5\n1.4.1　第2章：案例分析　　5\n1.4.2　第3～5章：基础实践　　5\n1.4.3　第6～7章：持续交付和回归测试　　6\n1.5　阅读本书前的注意事项　　7\n1.5.1　最好的方法是具体问题具体分析　　7\n1.5.2　没有最好的工具　　7\n第2章　团队开发中发生的问题　　9\n2.1　案例分析的前提　　10\n2.1.1　项目的前提条件　　10\n2.2　案例分析（第1天）　　11\n2.2.1　问题1：重要的邮件太多，无法确定处理的优先顺序　　11\n2.2.2　问题2：没有能用于验证的环境　　11\n2.2.3　问题3：用别名目录管理分支　　12\n2.2.4　问题4：重新制作数据库比较困难　　14\n2.3　案例分析（第1天）中的问题点　　16\n2.3.1　问题1：重要的邮件太多，无法确定处理的优先顺序　　16\n邮件的数量太多，导致重要的邮件被埋没　　16\n无法进行状态管理　　17\n直观性、检索性较弱　　17\n用邮件来管理项目的课题　　17\n2.3.2　问题2：没有能用于验证的环境　　18\n2.3.3　问题3：用别名目录管理分支　　18\n2.3.4　问题4：重新制作数据库比较困难　　19\n2.4　案例分析（第2天）　　22\n2.4.1　问题5：不运行系统就无法察觉问题　　22\n2.4.2　问题6：覆盖了其他组员修正的代码　　22\n2.4.3　问题7：无法自信地进行代码重构　　24\n2.4.4　问题8：不知道bug的修正日期，也不能追踪退化　　25\n2.4.5　问题9：没有灵活使用分支和标签　　26\n2.4.6　问题10：在测试环境、正式环境上无法运行　　28\n2.4.7　问题11：发布太复杂，以至于需要发布手册　　28\n2.5　案例分析（第2天）中的问题点　　30\n2.5.1　问题5：不运行系统就无法察觉问题　　30\n2.5.2　问题6：覆盖了其他组员修正的代码　　31\n2.5.3　问题7：无法自信地进行代码重构　　31\n2.5.4　问题8：不知道bug的修正日期，也不能追踪退化　　33\n2.5.5　问题9：没有灵活使用分支和标签　　35\n2.5.6　问题10：在测试环境、正式环境上无法运行　　35\n2.5.7　问题11：发布太复杂，以至于需要发布手册　　36\n2.6　什么是理想的项目　　37\n2.6.1　使用缺陷管理系统对课题等进行统筹管理　　38\n2.6.2　尽量使用版本管理系统　　38\n2.6.3　准备可以反复验证的CI系统　　38\n2.6.4　将环境的影响控制在最小限度，并随时可以发布　　39\n2.6.5　保留所有记录以便日后追踪　　39\n2.7　本章总结　　40\n第3章　版本管理　　41\n3.1　版本管理系统　　42\n3.1.1　什么是版本管理系统　　42\n3.1.2　为什么使用版本管理系统能带来便利　　42\n能够保留修改内容这一最基本的记录　　43\n能够方便地查看版本之间的差异　　43\n能够防止错误地覆盖他人修改的代码　　43\n专栏　锁模式和合并模式 　　44\n能够还原到任意时间点的状态　　48\n专栏　基于文件和基于变更集 　　49\n能够生成多个派生（分支和标签），保留当时项目状态的断面　　 49\n3.2　版本管理系统的发展变迁　　51\n3.2.1　没有版本管理系统的时代（20世纪70年代以前）　　52\n3.2.2　RCS 的时代（20世纪80年代）　　52\n3.2.3　CVS 的诞生（20世纪90年代）　　52\n3.2.4　VSS、Perforce等商用工具的诞生（20 世纪90 年代）　　53\n3.2.5　Subversion 的诞生（2000 年以后）　　54\n3.2.6　分布式版本管理系统的诞生（2005 年以后）　　54\n3.2.7　番外篇：GitHub的诞生　　55\n3.2.8　版本管理系统的导入情况　　57\n3.3　分布式版本管理系统　　59\n3.3.1　使用分布式版本管理系统的5 大原因　　59\n能将代码库完整地复制到本地　　59\n运行速度快　　59\n临时作业的提交易于管理　　59\n分支、合并简单方便　　59\n可以不受地点的限制进行协作开发　　60\n3.3.2　分布式版本管理系统的缺点　　60\n系统中没有真正意义上的最新版本　　60\n没有真正意义上的版本号　　60\n工作流程的配置过于灵活，容易产生混乱　　61\n思维方式的习惯需要一定的时间　　61\n3.4　如何使用版本管理系统　　62\n3.4.1　前提　　62\n3.4.2　版本管理系统管理的对象　　62\n代码　　63\n需求资料、设计资料等文档　　64\n数据库模式、数据　　64\n配置文件　　64\n库的依赖关系定义　　65\n3.5　使用Git顺利地推进并行开发　　66\n3.5.1　分支的用法　　66\n什么是分支　　66\n什么是发布分支（release branch）　　66\n克隆和建立分支　　67\n提交和提交记录　　67\n分支的切换　　68\n修正bug后的提交　　69\n合并到master　　70\n向master进行Push　　71\n分支使用方法总结　　72\n3.5.2　标签的使用方法　　72\n什么是标签　　72\n新建标签　　72\n标签的确认　　73\n标签的取得　　73\n专栏　避免使用相同的标签名和分支名 　　74\n标签使用方法总结　　75\n专栏　什么是Detached HEAD 　　76\n3.6　Git的开发流程　　77\n3.6.1　Git工作流的模式　　77\n中央集权型工作流　　77\nGitHub型工作流　　78\n3.6.2　分支策略的模式　　79\ngit-flow　　79\ngithub-flow　　82\n笔者的例子（折衷方案）　　83\n3.6.3　最合适的流程和分支策略因项目而异　　84\n3.7　数据库模式和数据的管理　　85\n3.7.1　需要对数据库模式进行管理的原因　　85\n由数据库管理员负责对修改进行管理的情况 　　85\n修改共享数据库的模式的情况 　　85\n3.7.2　应该如何管理数据库模式　　86\n版本管理的必要条件　　86\n什么是数据库迁移　　86\n数据库迁移的功能　　87\n3.7.3　数据库迁移工具　　88\nMigration（Ruby on Rails） 　　88\nsouth（Django）　　88\nMigrations Plugin（CakePHP）　　89\nEvolution（Play Framework）　　89\n3.7.4　具体用法（Evolution）　　89\n规定　　89\nSQL文件的执行　　90\n开发者之间数据库模式的同步 　　91\n一致性问题的管理　　93\n3.7.5　数据库迁移中的注意点　　94\n3.8　配置文件的管理　　96\n3.9　依赖关系的管理　　97\n3.9.1　依赖关系管理系统　　97\nJVM 语言　　97\n脚本语言　　98\n管理依赖关系的优点　　98\n3.10　本章总结　　100\n第4章　缺陷管理　　101\n4.1　缺陷管理系统　　102\n4.1.1　项目进展不顺利的原因　　102\n4.1.2　用纸、邮件、Excel进行任务管理时的问题　　103\n4.1.3　导入缺陷管理系统的优点　　104\n具有任务管理所需的基本功能　　104\n直观性、检索性较强　　104\n能够对信息进行统一管理及共享　　104\n能够生成各类报表　　105\n能够和其他系统进行关联，具有可扩展性　　105\n4.1.4　什么是缺陷驱动开发　　106\n缺陷驱动开发的具体步骤　　106\n专栏　彻底贯彻缺陷驱动开发的情况 　　107\n4.2　主要的缺陷管理系统　　108\n4.2.1　OSS产品　　108\nTrac　　108\nRedmine　　109\nBugzilla　　110\nMantis　　111\n4.2.2　商用产品　　112\nJIRA　　112\nYouTRACK　　113\nPivotal Tracker　　113\nBacklog　　114\nGitHub　　115\n4.2.3　选择工具（缺陷管理系统）的要点　　116\n专栏　缺陷管理系统的应用事例 　　117\n4.3　缺陷管理系统与版本管理系统的关联　　118\n4.3.1　通过关联实现的功能　　118\n从提交链接到问题票　　118\n从问题票链接到提交　　118\n提交的同时修改问题票的状态　　119\n4.3.2　关联的配置方法　　119\n4.3.3　GitHub　　119\nGitHub的issue　　119\nService Hooks　　120\nGitHub和Pivotal Tracker的关联　　121\nGitHub和JIRA的关联　　123\n4.3.4　Trac/Redmine　　124\n4.3.5　Backlog　　124\nBacklog和Git的关联　　125\nBacklog和GitHub的关联　　126\n4.3.6　Git自带的Hook的使用方法　　127\n4.4　新功能开发、修改bug时的工作流程　　128\n4.4.1　工作流程　　128\nA建立问题票　　128\nB指定负责人　　129\nC开发　　129\nD提交　　129\nE Push到代码库　　129\n4.5　回答“那个bug是什么时候修正的”的问题　　 131\n4.5.1　Pivotal Tracker的例子　　131\n用记忆中残留的关键字进行检索　　131\n检索　　131\n通过问题票查找代码修改　　132\n4.5.2　Backlog的例子　　133\n检索　　134\n4.6　回答“为什么要这样修改”的问题　　136\n4.7　本章总结　　137\n专栏　缺陷管理、bug 管理以及需求管理 　　137\n第5章　CI（持续集成）　　141\n5.1　CI（持续集成）　　142\n5.1.1　什么是CI（持续集成）　　142\n集成（integration）　　142\n持续地进行集成就是CI　　142\n5.1.2　使开发敏捷化　　143\n瀑布式开发的开发阶段　　143\n敏捷开发的开发阶段　　144\n5.1.3　为什么要进行CI 这样的实践　　147\n成本效益　　147\n市场变化的速度　　148\n兼顾开发速度和质量　　148\n5.1.4　CI的必要条件　　149\n版本管理系统　　149\nbuild 工具　　149\n测试代码　　151\nCI 工具　　151\n5.1.5　编写测试代码所需的框架　　151\n测试驱动开发（TDD）的框架　　151\n行为驱动开发（BDD）的框架　　152\n5.1.6　主要的CI 工具　　154\nJenkins　　154\nTravisCI　　155\n5.2　build工具的使用方法　　157\n5.2.1　新建工程的情况　　157\n建立工程雏形　　158\n依赖关系的定义　　160\n执行测试　　161\n导入Eclipse　　162\n5.2.2　为已有工程添加自动build 功能　　162\n5.2.3　build工具的总结　　163\n5.3　测试代码的写法　　164\n5.3.1　作为CI的对象的测试的种类　　164\n5.3.2　何时编写测试　　165\n新建工程的情况　　165\n已有工程中没有测试的情况　　165\n修改bug或添加新功能的情况　　166\n5.3.3　棘手的测试该如何写　　166\n和外部系统有交互的测试　　166\n使用mocking框架进行测试　　167\n使用内存数据库进行测试　　168\n数据库变更管理和配置文件管理的测试　　169\nUI 相关的测试　　169\n棘手的测试要权衡工数　　170\n5.4　执行基于Jenkins 的CI　　171\n5.4.1　Jenkins的安装　　171\n使用本地安装包进行安装　　172\n5.4.2　Jenkins能干些什么　　172\n5.4.3　新建任务　　173\n5.4.4　下载代码　　173\n5.4.5　自动执行build 和测试　　175\n定期执行　　175\n轮询版本管理系统　　175\n专栏　 从版本管理系统进行Push 　　176\nbuild 的记述　　177\n5.4.6　统计结果并生成报表　　178\n专栏　以JUnitXML 的形式输出报表比较高效 　　179\n5.4.7　统计覆盖率　　179\n覆盖率统计工具　　180\nMaven Cobertura插件的安装　　180\n专栏　Java 程序库的查找方法 　　182\nJenkins 插件的配置　　183\n5.4.8　静态分析　　184\n5.4.9　配置通知　　185\n5.5　CI 的运用　　187\n5.5.1　build 失败了该怎么办　　187\nSubversion 等中央集权型版本管理系统的情况　　187\nGit 等分布式管理系统的情况　　187\n专栏　造成build 失败后的惩罚游戏 　　188\n测试后合并　　189\n5.5.2　确保可追溯性　　193\n关联build 和提交　　193\n关联缺陷管理　　194\n5.6　本章总结——借助CI 能够实现的事　　198\n第6章　部署的自动化（持续交付）　　199\n6.1　应该如何部署　　200\n6.1.1　部署自动化带来的好处　　200\n细粒度、频繁地发布可以使风险可控　　200\n能尽快地获得用户的反馈　　200\n团队的规模可控　　201\n6.2　部署的自动化　　202\n6.2.1　部署自动化方面的共识　　202\n6.2.2　部署流水线　　203\n通过自动化加快部署速度　　204\n任何人都能够实施部署是很重要的　　204\n6.2.3　服务提供工具链（provisioning tool chain）　　204\n6.3　引导（Bootstrapping）　　206\n6.3.1　Kickstart　　206\nKickstart 的使用方法　　206\n使用时的注意事项　　206\nKickstart 的配置示例　　207\n6.3.2　Vagrant　　208\n为每一位开发人员准备实体电脑比较困难　　208\n使用虚拟机时的注意事项　　209\n什么是Vagrant　　209\nVagrant的安装及运行方法　　209\n6.4　配置（Configuration）　　212\n6.4.1　不使用自动化时的问题　　212\n6.4.2　Chef　　213\nChef的构成　　213\n目录构成和文件配置　　215\nnode.json　　215\nsetup.json　　216\nsolo.rb　　216\ndefault.rb　　217\nvirtualhost.conf.erb　　218\nChef的运行方法和运行结果　　218\n使用Chef的优点　　219\n使用Chef时的注意事项　　220\n使用Chef的时间点　　220\n6.4.3　serverspec　　221\n什么是serverspec　　221\nserverspec的安装　　221\n测试文件的记述方式　　222\nhttpd_spec.rb　　222\ngit_spec.rb　　223\nserverspec的执行方法及执行结果　　223\nserverspec的优点　　224\n6.4.4　最佳实践（其1）　　224\nVagrantfile　　226\ndefault.rb　　227\n6.4.5　最佳实践（其2）　　227\n6.4.6　实现物理服务器投入运营为止的所有步骤的自动化　　229\n6.5　编配（Orchestration）　　230\n6.5.1　发布作业的反面教材　　230\n6.5.2　Capistrano　　231\nCapistrano的系统构成　　231\nCapistrano的安装　　232\ndeploy.rb　　232\nCapistrano 的执行方法　　233\n6.5.3　Fabric　　233\nFabric（串行执行）的情况　　234\nCapistrano（并行执行）的情况　　234\n理解本地服务器和远程服务器操作上的区别　　234\nFabric的运行方法　　236\n6.5.4　Jenkins　　237\n主节点（master node）和从节点（slave node）的协作　　237\n从节点的添加　　238\n任务的添加　　240\n任务的执行　　242\n6.5.5　最佳实践　　243\n结合Jenkins和Fabric　　243\n6.5.6　考虑安全问题　　244\n专栏　手动部署的例子 　　245\n6.6　考虑运用相关的问题　　247\n6.6.1　不中断服务的部署方法　　247\n6.6.2　蓝绿部署（blue-green deployment）　　247\n6.6.3　云（cloud）时代的蓝绿部署　　250\n6.6.4　回滚（rollback）相关问题的考察　　251\n随时准备好退路　　251\n数据库模式的版本管理　　251\n回滚的验证　　252\n只更新代码的发布时的回滚　　252\n数据库模式更新时的回滚　　253\n6.7　本章总结　　255\n专栏　PaaS的使用方式 　　255\n第7章　回归测试　　259\n7.1　回归测试　　260\n7.1.1　什么是回归测试　　260\n7.1.2　测试分类的整理　　261\n支持团队的技术层面的测试（第1 象限）　　262\n支持团队的业务层面的测试（第2 象限）　　262\n评价产品的业务层面的测试（第3象限）　　262\n使用技术层面测试的产品评价（第4象限）　　263\n7.1.3　回归测试的必要性　　263\n退化（degrade）的发生　　263\n应该实现自动测试的原因　　263\n7.1.4　回归测试自动化的目标　　265\n7.2　Selenium　　266\n7.2.1　什么是Selenium　　266\n7.2.2　Selenium的优点　　266\n自动化测试用例制作简单　　266\n支持多种浏览器及OS　　266\n7.2.3　Selenium的组件　　267\nSelenium IDE　　267\nSelenium Remote Control（Selenium RC）　　268\nSelenium WebDriver　　269\n7.2.4　测试用例的制作和执行　　271\nSelemium IDE的安装和运行　　271\nSelenium的测试用例　　271\n什么是好的测试用例　　274\n用Selenium Server来运行测试　　274\n7.2.5　Selenium的实际应用　　276\n测试页面是否有改动　　276\n使Selenium测试稳定运行　　278\n7.3　Jenkins和Selenium的协作　　282\n7.3.1　关联Jenkins和Selenium的步骤　　282\n7.4　Selenium测试的高速化　　287\n7.4.1　利用Jenkins的分布式构建实现测试的并行执行　　288\nJenkins的分布式构建的构成　　288\n分布式构建的配置　　289\n7.4.2　Selenium测试并行化中的难点　　291\n7.5　多个应用程序版本的测试　　295\n7.5.1　应用的部署　　296\n7.5.2　从版本管理系统下载测试用例　　296\n7.5.3　用Selenium测试　　296",
    "pages": "320",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s28117176.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s28117176.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s28117176.jpg"
    },
    "alt": "https://book.douban.com/subject/26432720/",
    "id": "26432720",
    "publisher": "人民邮电出版社",
    "isbn10": "7115295948",
    "isbn13": "9787115295941",
    "title": "高效团队开发",
    "url": "https://api.douban.com/v2/book/26432720",
    "alt_title": "",
    "author_intro": "作者简介：\n池田尚史\nDeNA软件开发工程师。曾做过IT顾问、程序员，从事过软件包开发、Web服务开发。Java的Web应用框架Play Framework 1的提交者。负责本书第1章~第5章，其中第2章的案例分析都是基于自身的实际经验编写的。\nTwitter　@ikeike443\n藤仓和明\n想能（SHANON）基础设施工程师。负责公司内部基础设施及服务环境的安全保障，致力于推动应用部署的自动化，并基于这方面丰富的实践经验，完成了本书第6章。喜欢OpenVZ、LXC等容器型虚拟化技术。\nTwitter　@fujya\n井上史彰\n想能（SHANON）软件工程师、QA工程师，现为想能信息科技（上海）有限公司总经理。开发经验丰富，致力于推动高效的自动化测试。负责本书第7章。\nE-mail　fu.inoue@gmail.com\n译者简介：\n严圣逸\n毕业于上海交通大学。8年软件开发经验，期间赴日本工作。现就职于想能信息科技（上海）有限公司，从事基于云平台的客户关系管理及各类营销自动化系统的开发，侧重于对持续集成、自动化部署、自动化测试以及相关的开源工具的研究。本书所介绍的即是译者日常工作中所应用的开发流程以及工具。",
    "summary": "本书以团队开发中所必需的工具的导入方法和使用方法为核心，对团队开发的整体结构进行概括性的说明。内容涉及团队开发中发生的问题、版本管理系统、缺陷管理系统、持续集成、持续交付以及回归测试，并且对“为什么用那个工具”“为什么要这样使用”等开发现场常有的问题进行举例说明。\n本书适合初次接手开发团队的项目经理，计划开始新项目的项目经理、Scrum Master，以及现有项目中返工、延期问题频发的开发人员阅读。",
    "price": "49.00"
  },
  "9787115293817": {
    "rating": { "max": 10, "numRaters": 326, "average": "7.4", "min": 0 },
    "subtitle": "数据可视化指南",
    "author": ["[美] Nathan Yau"],
    "pubdate": "2012-10-1",
    "tags": [
      { "count": 537, "name": "数据可视化", "title": "数据可视化" },
      { "count": 320, "name": "数据分析", "title": "数据分析" },
      { "count": 165, "name": "数据", "title": "数据" },
      { "count": 142, "name": "可视化", "title": "可视化" },
      { "count": 87, "name": "计算机", "title": "计算机" },
      { "count": 83, "name": "设计", "title": "设计" },
      { "count": 80, "name": "数据挖掘", "title": "数据挖掘" },
      { "count": 65, "name": "互联网", "title": "互联网" }
    ],
    "origin_title": "",
    "image": "https://img1.doubanio.com/view/subject/m/public/s27254568.jpg",
    "binding": "平装",
    "translator": ["向怡宁"],
    "catalog": "第1章　 用数据讲故事　 　 1\n1.1　 不只是数字　 　 2\n1.1.1　 新闻报道　 　 2\n1.1.2　 艺术　 　 3\n1.1.3　 娱乐　 　 5\n1.1.4　 引人注目　 　 6\n1.2　 我们要寻求什么　 　 7\n1.2.1　 模式　 　 7\n1.2.2　 相互关系　 　 9\n1.2.3　 有问题的数据　 　 10\n1.3　 设计　 　 11\n1.3.1　 解释编码　 　 11\n1.3.2　 标注坐标轴　 　 13\n1.3.3　 确保几何上的正确性　 　 15\n1.3.4　 提供数据来源　 　 16\n1.3.5　 考虑你的受众　 　 16\n1.4　 小结　 　 17\n第2章　 处理数据　 　 18\n2.1　 收集数据　 　 19\n2.1.1　 由他人提供　 　 19\n2.1.2　 寻找数据源　 　 19\n2.1.3　 自动搜集数据　 　 22\n2.2　 设置数据的格式　 　 32\n2.2.1　 数据格式　 　 32\n2.2.2　 格式化工具　 　 34\n2.2.3　 用代码来格式化　 　 38\n2.3　 小结　 　 42\n第3章　 选择可视化工具　 　 44\n3.1　 开箱即用的可视化工具　 　 45\n3.1.1　 可选项　 　 45\n3.1.2　 取舍　 　 52\n3.2　 编程工具　 　 52\n3.2.1　 可选项　 　 52\n3.2.2　 取舍　 　 61\n3.3　 绘图软件　 　 62\n3.3.1　 可选项　 　 63\n3.3.2　 取舍　 　 65\n3.4　 地图绘制工具　 　 65\n3.4.1　 可选项　 　 66\n3.4.2　 取舍　 　 71\n3.5　 衡量各种可选项　 　 71\n3.6　 小结　 　 72\n第4章　 有关时间趋势的可视化　 　 73\n4.1　 在时间中寻求什么　 　 74\n4.2　 时间中的离散点　 　 75\n4.2.1　 柱形　 　 75\n4.2.2　 柱形的堆叠　 　 88\n4.2.3　 圆点　 　 92\n4.3　 延续性数据　 　 97\n4.3.1　 点与点相连　 　 98\n4.3.2　 一步一个台阶　 　 102\n4.3.3　 平滑和估算　 　 106\n4.4　 小结　 　 110\n第5章　 有关比例的可视化　 　 111\n5.1　 在比例中寻求什么　 　 112\n5.2　 整体中的各个部分　 　 112\n5.2.1　 饼图　 　 112\n5.2.2　 面包圈图　 　 116\n5.2.3　 比例中的堆叠　 　 121\n5.2.4　 层级和矩形　 　 128\n5.3　 带时间属性的比例　 　 132\n5.3.1　 堆叠的延续　 　 133\n5.3.2　 逐点详述　 　 144\n5.4　 小结　 　 145\n第6章　 有关关系的可视化　 　 146\n6.1　 在关系中寻求什么　 　 147\n6.2　 关联性　 　 147\n6.2.1　 更多的圆点　 　 147\n6.2.2　 探索更多的变量　 　 152\n6.2.3　 气泡　 　 156\n6.3　 分布　 　 162\n6.3.1　 老式的分布图表　 　 163\n6.3.2　 有关分布的柱形　 　 165\n6.3.3　 延续性的密度　 　 168\n6.4　 对照和比较　 　 173\n6.5　 小结　 　 184\n第7章　 发现差异　 　 185\n7.1　 在差异中寻求什么　 　 186\n7.2　 在多个变量间比较　 　 186\n7.2.1　 热身　 　 186\n7.2.2　 相面术　 　 195\n7.2.3　 星光灿烂　 　 200\n7.2.4　 平行前进　 　 207\n7.3　 减少维度　 　 213\n7.4　 寻找异常值　 　 218\n7.5　 小结　 　 222\n第8章　 有关空间关系的可视化　 　 223\n8.1　 在空间中寻求什么　 　 224\n8.2　 具体位置　 　 224\n8.2.1　 找到纬度和经度　 　 225\n8.2.2　 单纯的点　 　 227\n8.2.3　 有大有小的点　 　 233\n8.3　 地区　 　 235\n8.4　 跨越空间和时间　 　 248\n8.4.1　 系列组图　 　 249\n8.4.2　 抓住差额　 　 251\n8.4.3　 动画　 　 253\n8.5　 小结　 　 268\n第9章　 有目的地设计　 　 269\n9.1　 让自己作好准备　 　 270\n9.2　 让读者作好准备　 　 271\n9.3　 视觉提示　 　 275\n9.4　 好的可视化　 　 280\n9.5　 小结　 　 280",
    "ebook_url": "https://read.douban.com/ebook/1052447/",
    "pages": "281",
    "images": {
      "small": "https://img1.doubanio.com/view/subject/s/public/s27254568.jpg",
      "large": "https://img1.doubanio.com/view/subject/l/public/s27254568.jpg",
      "medium": "https://img1.doubanio.com/view/subject/m/public/s27254568.jpg"
    },
    "alt": "https://book.douban.com/subject/19952397/",
    "id": "19952397",
    "publisher": "人民邮电出版社",
    "isbn10": "7115293813",
    "isbn13": "9787115293817",
    "title": "鲜活的数据",
    "url": "https://api.douban.com/v2/book/19952397",
    "alt_title": "",
    "author_intro": "Nathan Yau 加州大学洛杉矶分校统计学专业在读博士、超级数据迷，专注于数据可视化与个人数据收集。他曾在《纽约时报》、CNN、Mozilla和SyFy工作过，认为数据和信息图不仅适用于分析，用来讲述与数据有关的故事也非常合适。Yau的目标是让非专业人士读懂并用好数据。他创建了一个设计、可视化和统计方面的博http://flowingdata.com，你可以从中欣赏到他最新的数据可视化实验作品。\n向怡宁 交互和视觉设计师、摇滚乐手，同时还热衷于翻译和写作。著有《Flash组件、游戏、SWF加解密》及《就这么简单：Web开发中的可用性和用户体验》，译有《奇思妙想：15位计算机天才及其重大发现》、《瞬间之美：Web界面设计如何让用户心动》、《网站设计解构：有效的交互设计框架和模式》、《网站搜索设计：兼顾SEO及可用性的网站设计心得》等书。他认为“一个不会弹吉他的设计师不是个好译者”。",
    "summary": "在生活中，数据几乎无处不在，任我们取用。然而，同样的数据给人的感觉可能会千差万别：或冰冷枯燥，让人望而生畏、百思不解其意；或生动有趣，让人一目了然、豁然开朗。为了达到后一种效果，我们需要采用一种特别的方式来展示数据，来解释、分析和应用它。这就是数据可视化技术。Nath an Yau是这一创新领域的先锋。在本书中，他根据数据可视化的工作流程，先后介绍了如何获取数据，将数据格式化，用可视化工具（如R）生成图表，以及在图形编辑软件（如Illustrator）中修改以使图表达到最佳效果。本书介绍了数十种方法（如柱形图、饼图、折线图和散点图等），以创造性的视觉方式生动讲述了有关数据的故事。",
    "ebook_price": "30.00",
    "series": { "id": "660", "title": "图灵程序设计丛书" },
    "price": "69.00元"
  },
  "9787115249494": {
    "rating": { "max": 10, "numRaters": 15996, "average": "8.8", "min": 0 },
    "subtitle": "硅谷创业之父Paul Graham文集",
    "author": ["[美] Paul Graham"],
    "pubdate": "2011-4",
    "tags": [
      { "count": 7897, "name": "计算机", "title": "计算机" },
      { "count": 6302, "name": "互联网", "title": "互联网" },
      { "count": 6017, "name": "黑客", "title": "黑客" },
      { "count": 4712, "name": "创业", "title": "创业" },
      { "count": 2953, "name": "编程", "title": "编程" },
      { "count": 1331, "name": "软件开发", "title": "软件开发" },
      { "count": 1285, "name": "阮一峰", "title": "阮一峰" },
      { "count": 1021, "name": "美国", "title": "美国" }
    ],
    "origin_title": "Hackers and Painters: Big Ideas from the Computer Age",
    "image": "https://img3.doubanio.com/view/subject/m/public/s4669554.jpg",
    "binding": "平装",
    "translator": ["阮一峰"],
    "catalog": "1  为什么书呆子不受欢迎\t1\n他们的心思在别的地方。\n2  黑客与画家\t18\n黑客也是创造者，与画家、建筑师、作家一样。\n3  不能说的话\t34\n如果你的想法是社会无法容忍的，你怎么办？\n4  良好的坏习惯\t52\n与其他美国人一样，黑客的成功秘诀就是打破常规。\n5  另一条路\t59\n互联网软件是微机诞生后的最大机会。\n6  如何创造财富\t90\n致富的最好方法就是为社会创造财富。创造财富的最好方法就是创业。\n7  关注贫富分化\t111\n“收入分配不平等”的危害，会不会没有我们想的那样严重？\n8  防止垃圾邮件的一种方法\t124\n不久前，许多专家还认为无法有效地过滤垃圾邮件。本文改变了他们的想法。\n9  设计者的品味\t133\n如何做出优秀的东西？\n10  编程语言解析\t148\n什么是编程语言？为什么它们现在很热门？\n11  一百年后的编程语言\t156\n一百年后，人类怎样编程？为什么不从现在开始就这样编程呢？\n12  拒绝平庸\t169\n别忘了你的对手与你一样，能用任何想用的语言编写互联网软件。\n13  书呆子的复仇\t180\n在高科技行业，只有失败者采用“业界最佳实践”。\n14  梦寐以求的编程语言\t198\n一种好的编程语言，是让黑客可以随心所欲使用的语言。\n15  设计与研究\t213\n研究必须是“新”的，而设计必须是“好”的。\n志谢\t219\n术语解释\t221\n图片授权说明\t236",
    "ebook_url": "https://read.douban.com/ebook/387525/",
    "pages": "264",
    "images": {
      "small": "https://img3.doubanio.com/view/subject/s/public/s4669554.jpg",
      "large": "https://img3.doubanio.com/view/subject/l/public/s4669554.jpg",
      "medium": "https://img3.doubanio.com/view/subject/m/public/s4669554.jpg"
    },
    "alt": "https://book.douban.com/subject/6021440/",
    "id": "6021440",
    "publisher": "人民邮电出版社",
    "isbn10": "7115249490",
    "isbn13": "9787115249494",
    "title": "黑客与画家",
    "url": "https://api.douban.com/v2/book/6021440",
    "alt_title": "Hackers and Painters: Big Ideas from the Computer Age",
    "author_intro": "保罗•格雷厄姆，《黑客与画家》一书的作者，硅谷创业之父。1964年，出生于匹兹堡郊区的一个中产阶级家庭。父亲是设计核反应堆的物理学家，母亲在家照看他和他的妹妹。青少年时代，格雷厄姆就开始编程。但是，他还喜欢许多与计算机无关的东西，这在编程高手之中是很少见的。\n保罗•格雷厄姆在康奈尔大学读完本科，然后在哈佛大学获得计算机科学博士学位。1995年，他创办了Viaweb，帮助个人用户在网上开店，这是世界上第一个互联网应用程序。1998年夏天，Yahoo!公司收购了Viaweb，收购价约为5000万美元。\n此后，他架起了个人网站paulgraham.com，在上面撰写了许许多多关于软件和创业的文章，以深刻的见解和清晰的表达而著称，迅速引起了轰动。2005年，他身体力行，创建了风险投资公司Y Combinator，将自己的理论转化为实践，目前已经资助了80多家创业公司。现在，他是公认的互联网创业权威。",
    "summary": "本书是硅谷创业之父Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。\n本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。",
    "ebook_price": "12.00",
    "price": "49.00元"
  },
  "9787115451699": {
    "rating": { "average": "8.5" },
    "title": "图解物联网",
    "subtitle": "",
    "alt": "https://book.douban.com/subject/27016248/"
  },
  "9787115458414": {
    "rating": { "average": "9.5" },
    "title": "Head First JavaScript程序设计",
    "subtitle": "",
    "alt": "https://book.douban.com/subject/27120520/"
  },
  "9787115276117": {
    "rating": { "average": "8.1" },
    "title": "七周七语言",
    "subtitle": "理解多种编程范型",
    "alt": "https://book.douban.com/subject/10555435/"
  },
  "9787115485182": {
    "rating": { "average": "8.3" },
    "title": "别拿相关当因果！因果关系简易入门",
    "subtitle": "",
    "alt": "https://book.douban.com/subject/30271228/"
  }
}
